{"mappings":"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","sources":["<anon>","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/app/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/app/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/app/ResizePlugin.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/app/ResizePlugin.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/app/TickerPlugin.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/app/TickerPlugin.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/graphics/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/graphics/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/mesh/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/mesh/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/particle-container/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/particle-container/shared/GlParticleContainerPipe.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/particle-container/gl/GlParticleContainerAdaptor.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainerPipe.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/particle-container/shared/utils/createIndicesForQuads.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/particle-container/shared/shader/ParticleShader.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/particle-container/shared/GpuParticleContainerPipe.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/particle-container/gpu/GpuParticleContainerAdaptor.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text/utils/updateTextBounds.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text/canvas/BatchableText.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-bitmap/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-bitmap/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/BatchableHTMLText.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/utils/browser/isSafari.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/utils/browser/isSafari.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/HTMLTextStyle.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/utils/textStyleToCSS.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/sprite-tiling/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/filters/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/filters/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/filters/FilterPipe.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/filters/FilterPipe.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/filters/FilterSystem.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/filters/FilterSystem.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire792f\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"5eFmp\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $83OKg = parcelRequire(\"83OKg\");\n\nvar $i3qqe = parcelRequire(\"i3qqe\");\n\"use strict\";\n(0, $arnWa.extensions).add((0, $83OKg.ResizePlugin));\n(0, $arnWa.extensions).add((0, $i3qqe.TickerPlugin));\n\n});\nparcelRegister(\"83OKg\", function(module, exports) {\n\n$parcel$export(module.exports, \"ResizePlugin\", () => $422035d31f142a1f$export$6453cd852defe94a);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\"use strict\";\nclass $422035d31f142a1f$export$6453cd852defe94a {\n    /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */ static init(options) {\n        Object.defineProperty(this, \"resizeTo\", {\n            set (dom) {\n                globalThis.removeEventListener(\"resize\", this.queueResize);\n                this._resizeTo = dom;\n                if (dom) {\n                    globalThis.addEventListener(\"resize\", this.queueResize);\n                    this.resize();\n                }\n            },\n            get () {\n                return this._resizeTo;\n            }\n        });\n        this.queueResize = ()=>{\n            if (!this._resizeTo) return;\n            this._cancelResize();\n            this._resizeId = requestAnimationFrame(()=>this.resize());\n        };\n        this._cancelResize = ()=>{\n            if (this._resizeId) {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n        this.resize = ()=>{\n            if (!this._resizeTo) return;\n            this._cancelResize();\n            let width;\n            let height;\n            if (this._resizeTo === globalThis.window) {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            } else {\n                const { clientWidth: clientWidth, clientHeight: clientHeight } = this._resizeTo;\n                width = clientWidth;\n                height = clientHeight;\n            }\n            this.renderer.resize(width, height);\n            this.render();\n        };\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n    /**\n   * Clean up the ticker, scoped to application\n   * @private\n   */ static destroy() {\n        globalThis.removeEventListener(\"resize\", this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n/** @ignore */ $422035d31f142a1f$export$6453cd852defe94a.extension = (0, $arnWa.ExtensionType).Application;\n\n});\n\nparcelRegister(\"i3qqe\", function(module, exports) {\n\n$parcel$export(module.exports, \"TickerPlugin\", () => $59a629c0f9e6fd05$export$50c361ceb4e2f4f0);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $kfZeU = parcelRequire(\"kfZeU\");\n\nvar $7LZE9 = parcelRequire(\"7LZE9\");\n\"use strict\";\nclass $59a629c0f9e6fd05$export$50c361ceb4e2f4f0 {\n    /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */ static init(options) {\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false\n        }, options);\n        Object.defineProperty(this, \"ticker\", {\n            set (ticker) {\n                if (this._ticker) this._ticker.remove(this.render, this);\n                this._ticker = ticker;\n                if (ticker) ticker.add(this.render, this, (0, $kfZeU.UPDATE_PRIORITY).LOW);\n            },\n            get () {\n                return this._ticker;\n            }\n        });\n        this.stop = ()=>{\n            this._ticker.stop();\n        };\n        this.start = ()=>{\n            this._ticker.start();\n        };\n        this._ticker = null;\n        this.ticker = options.sharedTicker ? (0, $7LZE9.Ticker).shared : new (0, $7LZE9.Ticker)();\n        if (options.autoStart) this.start();\n    }\n    /**\n   * Clean up the ticker, scoped to application.\n   * @private\n   */ static destroy() {\n        if (this._ticker) {\n            const oldTicker = this._ticker;\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n/** @ignore */ $59a629c0f9e6fd05$export$50c361ceb4e2f4f0.extension = (0, $arnWa.ExtensionType).Application;\n\n});\n\n\nparcelRegister(\"j2iTt\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $dGhKH = parcelRequire(\"dGhKH\");\n\nvar $gC2ie = parcelRequire(\"gC2ie\");\n\"use strict\";\n(0, $arnWa.extensions).add((0, $gC2ie.GraphicsPipe));\n(0, $arnWa.extensions).add((0, $dGhKH.GraphicsContextSystem));\n\n});\nparcelRegister(\"gC2ie\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsPipe\", () => $4191ff7429a79856$export$56171ef5563dc803);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $19C14 = parcelRequire(\"19C14\");\n\nvar $ehSI3 = parcelRequire(\"ehSI3\");\n\nvar $6WOBV = parcelRequire(\"6WOBV\");\n\nvar $cAXew = parcelRequire(\"cAXew\");\n\"use strict\";\nclass $4191ff7429a79856$export$2a885cf99f131046 {\n    constructor(){\n        this.batches = [];\n        this.batched = false;\n    }\n    destroy() {\n        this.batches.forEach((batch)=>{\n            (0, $ehSI3.BigPool).return(batch);\n        });\n        this.batches.length = 0;\n    }\n}\nclass $4191ff7429a79856$export$56171ef5563dc803 {\n    constructor(renderer, adaptor){\n        this.state = (0, $19C14.State).for2d();\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n        this.renderer.runners.contextChange.add(this);\n    }\n    contextChange() {\n        this._adaptor.contextChange(this.renderer);\n    }\n    validateRenderable(graphics) {\n        const context = graphics.context;\n        const wasBatched = !!graphics._gpuData;\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) return true;\n        return false;\n    }\n    addRenderable(graphics, instructionSet) {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n        if (graphics.didViewUpdate) this._rebuild(graphics);\n        if (gpuContext.isBatchable) this._addToBatcher(graphics, instructionSet);\n        else {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n    updateRenderable(graphics) {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n        const batches = gpuData.batches;\n        for(let i = 0; i < batches.length; i++){\n            const batch = batches[i];\n            batch._batcher.updateElement(batch);\n        }\n    }\n    execute(graphics) {\n        if (!graphics.isRenderable) return;\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n        if (!contextSystem.getGpuContext(context).batches.length) return;\n        const shader = context.customShader || this._adaptor.shader;\n        this.state.blendMode = graphics.groupBlendMode;\n        const localUniforms = shader.resources.localUniforms.uniforms;\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n        (0, $6WOBV.color32BitToUniform)(graphics.groupColorAlpha, localUniforms.uColor, 0);\n        this._adaptor.execute(this, graphics);\n    }\n    _rebuild(graphics) {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n        gpuData.destroy();\n        if (gpuContext.isBatchable) this._updateBatchesForRenderable(graphics, gpuData);\n    }\n    _addToBatcher(graphics, instructionSet) {\n        const batchPipe = this.renderer.renderPipes.batch;\n        const batches = this._getGpuDataForRenderable(graphics).batches;\n        for(let i = 0; i < batches.length; i++){\n            const batch = batches[i];\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n    _getGpuDataForRenderable(graphics) {\n        return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n    }\n    _initGpuDataForRenderable(graphics) {\n        const gpuData = new $4191ff7429a79856$export$2a885cf99f131046();\n        graphics._gpuData[this.renderer.uid] = gpuData;\n        return gpuData;\n    }\n    _updateBatchesForRenderable(graphics, gpuData) {\n        const context = graphics.context;\n        const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n        const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n        gpuData.batches = gpuContext.batches.map((batch)=>{\n            const batchClone = (0, $ehSI3.BigPool).get((0, $cAXew.BatchableGraphics));\n            batch.copyTo(batchClone);\n            batchClone.renderable = graphics;\n            batchClone.roundPixels = roundPixels;\n            return batchClone;\n        });\n    }\n    destroy() {\n        this.renderer = null;\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n    }\n}\n/** @ignore */ $4191ff7429a79856$export$56171ef5563dc803.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLPipes,\n        (0, $arnWa.ExtensionType).WebGPUPipes,\n        (0, $arnWa.ExtensionType).CanvasPipes\n    ],\n    name: \"graphics\"\n};\n\n});\n\n\nparcelRegister(\"aoZnp\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $2zCV3 = parcelRequire(\"2zCV3\");\n\"use strict\";\n(0, $arnWa.extensions).add((0, $2zCV3.MeshPipe));\n\n});\nparcelRegister(\"2zCV3\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshPipe\", () => $1ee4419f36fc2e55$export$ec121977b4273ffd);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $foUtO = parcelRequire(\"foUtO\");\n\nvar $h6ohx = parcelRequire(\"h6ohx\");\n\nvar $3Nxyo = parcelRequire(\"3Nxyo\");\n\nvar $4iD3R = parcelRequire(\"4iD3R\");\n\nvar $6WOBV = parcelRequire(\"6WOBV\");\n\nvar $jfZ8F = parcelRequire(\"jfZ8F\");\n\"use strict\";\nclass $1ee4419f36fc2e55$export$9a0f2e45e685fe64 {\n    destroy() {}\n}\nclass $1ee4419f36fc2e55$export$ec121977b4273ffd {\n    constructor(renderer, adaptor){\n        this.localUniforms = new (0, $3Nxyo.UniformGroup)({\n            uTransformMatrix: {\n                value: new (0, $foUtO.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uColor: {\n                value: new Float32Array([\n                    1,\n                    1,\n                    1,\n                    1\n                ]),\n                type: \"vec4<f32>\"\n            },\n            uRound: {\n                value: 0,\n                type: \"f32\"\n            }\n        });\n        this.localUniformsBindGroup = new (0, $h6ohx.BindGroup)({\n            0: this.localUniforms\n        });\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n        this._adaptor.init();\n    }\n    validateRenderable(mesh) {\n        const meshData = this._getMeshData(mesh);\n        const wasBatched = meshData.batched;\n        const isBatched = mesh.batched;\n        meshData.batched = isBatched;\n        if (wasBatched !== isBatched) return true;\n        else if (isBatched) {\n            const geometry = mesh._geometry;\n            if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n                return true;\n            }\n            const batchableMesh = this._getBatchableMesh(mesh);\n            if (batchableMesh.texture.uid !== mesh._texture.uid) batchableMesh._textureMatrixUpdateId = -1;\n            return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, mesh._texture);\n        }\n        return false;\n    }\n    addRenderable(mesh, instructionSet) {\n        const batcher = this.renderer.renderPipes.batch;\n        const { batched: batched } = this._getMeshData(mesh);\n        if (batched) {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n            gpuBatchableMesh.setTexture(mesh._texture);\n            gpuBatchableMesh.geometry = mesh._geometry;\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        } else {\n            batcher.break(instructionSet);\n            instructionSet.add(mesh);\n        }\n    }\n    updateRenderable(mesh) {\n        if (mesh.batched) {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n            gpuBatchableMesh.setTexture(mesh._texture);\n            gpuBatchableMesh.geometry = mesh._geometry;\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n    execute(mesh) {\n        if (!mesh.isRenderable) return;\n        mesh.state.blendMode = (0, $4iD3R.getAdjustedBlendModeBlend)(mesh.groupBlendMode, mesh.texture._source);\n        const localUniforms = this.localUniforms;\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n        (0, $6WOBV.color32BitToUniform)(mesh.groupColorAlpha, localUniforms.uniforms.uColor, 0);\n        this._adaptor.execute(this, mesh);\n    }\n    _getMeshData(mesh) {\n        var _a, _b;\n        (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new $1ee4419f36fc2e55$export$9a0f2e45e685fe64());\n        return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n    }\n    _initMeshData(mesh) {\n        mesh._gpuData[this.renderer.uid].meshData = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length\n        };\n        return mesh._gpuData[this.renderer.uid].meshData;\n    }\n    _getBatchableMesh(mesh) {\n        var _a, _b;\n        (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new $1ee4419f36fc2e55$export$9a0f2e45e685fe64());\n        return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n    }\n    _initBatchableMesh(mesh) {\n        const gpuMesh = new (0, $jfZ8F.BatchableMesh)();\n        gpuMesh.renderable = mesh;\n        gpuMesh.setTexture(mesh._texture);\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n        mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n        return gpuMesh;\n    }\n    destroy() {\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.renderer = null;\n    }\n}\n/** @ignore */ $1ee4419f36fc2e55$export$ec121977b4273ffd.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLPipes,\n        (0, $arnWa.ExtensionType).WebGPUPipes,\n        (0, $arnWa.ExtensionType).CanvasPipes\n    ],\n    name: \"mesh\"\n};\n\n});\nparcelRegister(\"jfZ8F\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableMesh\", () => $6a3b8dc49dafdf46$export$2fa0f0ec877329e3);\n\"use strict\";\nclass $6a3b8dc49dafdf46$export$2fa0f0ec877329e3 {\n    constructor(){\n        this.batcherName = \"default\";\n        this.packAsQuad = false;\n        this.indexOffset = 0;\n        this.attributeOffset = 0;\n        this.roundPixels = 0;\n        this._batcher = null;\n        this._batch = null;\n        this._textureMatrixUpdateId = -1;\n        this._uvUpdateId = -1;\n    }\n    get blendMode() {\n        return this.renderable.groupBlendMode;\n    }\n    get topology() {\n        return this._topology || this.geometry.topology;\n    }\n    set topology(value) {\n        this._topology = value;\n    }\n    reset() {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n    /**\n   * Sets the texture for the batchable mesh.\n   * As it does so, it resets the texture matrix update ID.\n   * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n   * @param value - The texture to set.\n   */ setTexture(value) {\n        if (this.texture === value) return;\n        this.texture = value;\n        this._textureMatrixUpdateId = -1;\n    }\n    get uvs() {\n        const geometry = this.geometry;\n        const uvBuffer = geometry.getBuffer(\"aUV\");\n        const uvs = uvBuffer.data;\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n        if (!textureMatrix.isSimple) {\n            transformedUvs = this._transformedUvs;\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n                if (!transformedUvs || transformedUvs.length < uvs.length) transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n                textureMatrix.multiplyUvs(uvs, transformedUvs);\n            }\n        }\n        return transformedUvs;\n    }\n    get positions() {\n        return this.geometry.positions;\n    }\n    get indices() {\n        return this.geometry.indices;\n    }\n    get color() {\n        return this.renderable.groupColorAlpha;\n    }\n    get groupTransform() {\n        return this.renderable.groupTransform;\n    }\n    get attributeSize() {\n        return this.geometry.positions.length / 2;\n    }\n    get indexSize() {\n        return this.geometry.indices.length;\n    }\n}\n\n});\n\n\n\nparcelRegister(\"kuK0D\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $btkbF = parcelRequire(\"btkbF\");\n\nvar $luHtJ = parcelRequire(\"luHtJ\");\n\"use strict\";\n(0, $arnWa.extensions).add((0, $btkbF.GlParticleContainerPipe));\n(0, $arnWa.extensions).add((0, $luHtJ.GpuParticleContainerPipe));\n\n});\nparcelRegister(\"btkbF\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlParticleContainerPipe\", () => $0e66adc9b0e7ae70$export$265dc7019ac9a69c);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $bIHrh = parcelRequire(\"bIHrh\");\n\nvar $2B7hE = parcelRequire(\"2B7hE\");\n\"use strict\";\nclass $0e66adc9b0e7ae70$export$265dc7019ac9a69c extends (0, $2B7hE.ParticleContainerPipe) {\n    constructor(renderer){\n        super(renderer, new (0, $bIHrh.GlParticleContainerAdaptor)());\n    }\n}\n/** @ignore */ $0e66adc9b0e7ae70$export$265dc7019ac9a69c.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLPipes\n    ],\n    name: \"particle\"\n};\n\n});\nparcelRegister(\"bIHrh\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlParticleContainerAdaptor\", () => $ab6a6df33775f7e8$export$46c725f3fa23723f);\n\"use strict\";\nclass $ab6a6df33775f7e8$export$46c725f3fa23723f {\n    execute(particleContainerPipe, container) {\n        const state = particleContainerPipe.state;\n        const renderer = particleContainerPipe.renderer;\n        const shader = container.shader || particleContainerPipe.defaultShader;\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPipe.localUniforms;\n        const gl = renderer.gl;\n        const buffer = particleContainerPipe.getBuffers(container);\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n\n});\n\nparcelRegister(\"2B7hE\", function(module, exports) {\n\n$parcel$export(module.exports, \"ParticleContainerPipe\", () => $457289e9395f6217$export$bd0cb1ddce5f75fc);\n\nvar $foUtO = parcelRequire(\"foUtO\");\n\nvar $3Nxyo = parcelRequire(\"3Nxyo\");\n\nvar $4iD3R = parcelRequire(\"4iD3R\");\n\nvar $19C14 = parcelRequire(\"19C14\");\n\nvar $6WOBV = parcelRequire(\"6WOBV\");\n\nvar $dWJhn = parcelRequire(\"dWJhn\");\n\nvar $hAGaQ = parcelRequire(\"hAGaQ\");\n\"use strict\";\nclass $457289e9395f6217$export$bd0cb1ddce5f75fc {\n    /**\n   * @param renderer - The renderer this sprite batch works for.\n   * @param adaptor\n   */ constructor(renderer, adaptor){\n        /** @internal */ this.state = (0, $19C14.State).for2d();\n        /** Local uniforms that are used for rendering particles. */ this.localUniforms = new (0, $3Nxyo.UniformGroup)({\n            uTranslationMatrix: {\n                value: new (0, $foUtO.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uColor: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uRound: {\n                value: 1,\n                type: \"f32\"\n            },\n            uResolution: {\n                value: [\n                    0,\n                    0\n                ],\n                type: \"vec2<f32>\"\n            }\n        });\n        this.renderer = renderer;\n        this.adaptor = adaptor;\n        this.defaultShader = new (0, $hAGaQ.ParticleShader)();\n        this.state = (0, $19C14.State).for2d();\n    }\n    validateRenderable(_renderable) {\n        return false;\n    }\n    addRenderable(renderable, instructionSet) {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n    getBuffers(renderable) {\n        return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n    }\n    _initBuffer(renderable) {\n        renderable._gpuData[this.renderer.uid] = new (0, $dWJhn.ParticleBuffer)({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties\n        });\n        return renderable._gpuData[this.renderer.uid];\n    }\n    updateRenderable(_renderable) {}\n    execute(container) {\n        const children = container.particleChildren;\n        if (children.length === 0) return;\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n        container.texture || (container.texture = children[0].texture);\n        const state = this.state;\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n        state.blendMode = (0, $4iD3R.getAdjustedBlendModeBlend)(container.blendMode, container.texture._source);\n        const uniforms = this.localUniforms.uniforms;\n        const transformationMatrix = uniforms.uTranslationMatrix;\n        container.worldTransform.copyTo(transformationMatrix);\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n        (0, $6WOBV.color32BitToUniform)(container.groupColorAlpha, uniforms.uColor, 0);\n        this.adaptor.execute(this, container);\n    }\n    /** Destroys the ParticleRenderer. */ destroy() {\n        if (this.defaultShader) {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n\n});\nparcelRegister(\"dWJhn\", function(module, exports) {\n\n$parcel$export(module.exports, \"ParticleBuffer\", () => $417f628afd2c0bd6$export$ef6bb3c375ab2229);\n\nvar $jcjyZ = parcelRequire(\"jcjyZ\");\n\nvar $2M1SI = parcelRequire(\"2M1SI\");\n\nvar $9eCTE = parcelRequire(\"9eCTE\");\n\nvar $7PVXE = parcelRequire(\"7PVXE\");\n\nvar $1lxxr = parcelRequire(\"1lxxr\");\n\nvar $iIX2O = parcelRequire(\"iIX2O\");\n\nvar $6Ne1X = parcelRequire(\"6Ne1X\");\n\"use strict\";\nclass $417f628afd2c0bd6$export$ef6bb3c375ab2229 {\n    constructor(options){\n        this._size = 0;\n        this._generateParticleUpdateCache = {};\n        const size = this._size = options.size ?? 1e3;\n        const properties = options.properties;\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n        for(const i in properties){\n            const property = properties[i];\n            const attributeInfo = (0, $7PVXE.getAttributeInfoFromFormat)(property.format);\n            if (property.dynamic) dynamicVertexSize += attributeInfo.stride;\n            else staticVertexSize += attributeInfo.stride;\n        }\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n        this.staticAttributeBuffer = new (0, $1lxxr.ViewableBuffer)(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new (0, $1lxxr.ViewableBuffer)(size * 4 * dynamicVertexSize);\n        this.indexBuffer = (0, $iIX2O.createIndicesForQuads)(size);\n        const geometry = new (0, $9eCTE.Geometry)();\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n        this._staticBuffer = new (0, $jcjyZ.Buffer)({\n            data: new Float32Array(1),\n            label: \"static-particle-buffer\",\n            shrinkToFit: false,\n            usage: (0, $2M1SI.BufferUsage).VERTEX | (0, $2M1SI.BufferUsage).COPY_DST\n        });\n        this._dynamicBuffer = new (0, $jcjyZ.Buffer)({\n            data: new Float32Array(1),\n            label: \"dynamic-particle-buffer\",\n            shrinkToFit: false,\n            usage: (0, $2M1SI.BufferUsage).VERTEX | (0, $2M1SI.BufferUsage).COPY_DST\n        });\n        for(const i in properties){\n            const property = properties[i];\n            const attributeInfo = (0, $7PVXE.getAttributeInfoFromFormat)(property.format);\n            if (property.dynamic) {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format\n                });\n                dynamicOffset += attributeInfo.size;\n            } else {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n        geometry.addIndex(this.indexBuffer);\n        const uploadFunction = this.getParticleUpdate(properties);\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n        this.geometry = geometry;\n    }\n    getParticleUpdate(properties) {\n        const key = $417f628afd2c0bd6$var$getParticleSyncKey(properties);\n        if (this._generateParticleUpdateCache[key]) return this._generateParticleUpdateCache[key];\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n        return this._generateParticleUpdateCache[key];\n    }\n    generateParticleUpdate(properties) {\n        return (0, $6Ne1X.generateParticleUpdateFunction)(properties);\n    }\n    update(particles, uploadStatic) {\n        if (particles.length > this._size) {\n            uploadStatic = true;\n            this._size = Math.max(particles.length, this._size * 1.5 | 0);\n            this.staticAttributeBuffer = new (0, $1lxxr.ViewableBuffer)(this._size * this._staticStride * 16);\n            this.dynamicAttributeBuffer = new (0, $1lxxr.ViewableBuffer)(this._size * this._dynamicStride * 16);\n            this.indexBuffer = (0, $iIX2O.createIndicesForQuads)(this._size);\n            this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n        this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n        if (uploadStatic) {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n            this._staticBuffer.setDataWithSize(staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n    destroy() {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\nfunction $417f628afd2c0bd6$var$getParticleSyncKey(properties) {\n    const keyGen = [];\n    for(const key in properties){\n        const property = properties[key];\n        keyGen.push(key, property.code, property.dynamic ? \"d\" : \"s\");\n    }\n    return keyGen.join(\"_\");\n}\n\n});\nparcelRegister(\"iIX2O\", function(module, exports) {\n\n$parcel$export(module.exports, \"createIndicesForQuads\", () => $b9c8656ec7314b7a$export$c56148e1bec42281);\n\"use strict\";\nfunction $b9c8656ec7314b7a$export$c56148e1bec42281(size, outBuffer = null) {\n    const totalIndices = size * 6;\n    if (totalIndices > 65535) outBuffer || (outBuffer = new Uint32Array(totalIndices));\n    else outBuffer || (outBuffer = new Uint16Array(totalIndices));\n    if (outBuffer.length !== totalIndices) throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    for(let i = 0, j = 0; i < totalIndices; i += 6, j += 4){\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n    return outBuffer;\n}\n\n});\n\nparcelRegister(\"6Ne1X\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateParticleUpdateFunction\", () => $50c2c163ab86466a$export$f240bbaff81b32e9);\n\nvar $7PVXE = parcelRequire(\"7PVXE\");\n\"use strict\";\nfunction $50c2c163ab86466a$export$f240bbaff81b32e9(properties) {\n    return {\n        dynamicUpdate: $50c2c163ab86466a$var$generateUpdateFunction(properties, true),\n        staticUpdate: $50c2c163ab86466a$var$generateUpdateFunction(properties, false)\n    };\n}\nfunction $50c2c163ab86466a$var$generateUpdateFunction(properties, dynamic) {\n    const funcFragments = [];\n    funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n    let offset = 0;\n    for(const i in properties){\n        const property = properties[i];\n        if (dynamic !== property.dynamic) continue;\n        funcFragments.push(`offset = index + ${offset}`);\n        funcFragments.push(property.code);\n        const attributeInfo = (0, $7PVXE.getAttributeInfoFromFormat)(property.format);\n        offset += attributeInfo.stride / 4;\n    }\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n    const functionSource = funcFragments.join(\"\\n\");\n    return new Function(\"ps\", \"f32v\", \"u32v\", functionSource);\n}\n\n});\n\n\nparcelRegister(\"hAGaQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"ParticleShader\", () => $8f32e171bbecdab4$export$aff9903e2c89709e);\n\nvar $48fkQ = parcelRequire(\"48fkQ\");\n\nvar $foUtO = parcelRequire(\"foUtO\");\n\nvar $liLpc = parcelRequire(\"liLpc\");\n\nvar $kU0Ff = parcelRequire(\"kU0Ff\");\n\nvar $e7K56 = parcelRequire(\"e7K56\");\n\nvar $aLn8X = parcelRequire(\"aLn8X\");\n\nvar $f3tpA = parcelRequire(\"f3tpA\");\n\nvar $h19ko = parcelRequire(\"h19ko\");\n\nvar $ikbMs = parcelRequire(\"ikbMs\");\n\nvar $5O5wk = parcelRequire(\"5O5wk\");\n\"use strict\";\nclass $8f32e171bbecdab4$export$aff9903e2c89709e extends (0, $e7K56.Shader) {\n    constructor(){\n        const glProgram = (0, $liLpc.GlProgram).from({\n            vertex: $ikbMs.default,\n            fragment: $h19ko.default\n        });\n        const gpuProgram = (0, $kU0Ff.GpuProgram).from({\n            fragment: {\n                source: (0, $5O5wk.default),\n                entryPoint: \"mainFragment\"\n            },\n            vertex: {\n                source: (0, $5O5wk.default),\n                entryPoint: \"mainVertex\"\n            }\n        });\n        super({\n            glProgram: glProgram,\n            gpuProgram: gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: (0, $aLn8X.Texture).WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new (0, $f3tpA.TextureStyle)({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: {\n                        value: new (0, $foUtO.Matrix)(),\n                        type: \"mat3x3<f32>\"\n                    },\n                    uColor: {\n                        value: new (0, $48fkQ.Color)(16777215),\n                        type: \"vec4<f32>\"\n                    },\n                    uRound: {\n                        value: 1,\n                        type: \"f32\"\n                    },\n                    uResolution: {\n                        value: [\n                            0,\n                            0\n                        ],\n                        type: \"vec2<f32>\"\n                    }\n                }\n            }\n        });\n    }\n}\n\n});\nparcelRegister(\"h19ko\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $c5d8af36a6a7aeed$export$2e2bcd8739ae039);\nvar $c5d8af36a6a7aeed$export$2e2bcd8739ae039 = \"varying vec2 vUV;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uTexture;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uTexture, vUV) * vColor;\\n    gl_FragColor = color;\\n}\";\n\n});\n\nparcelRegister(\"ikbMs\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $62aa5f4eaed43fe2$export$2e2bcd8739ae039);\nvar $62aa5f4eaed43fe2$export$2e2bcd8739ae039 = \"attribute vec2 aVertex;\\nattribute vec2 aUV;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPosition;\\nattribute float aRotation;\\n\\nuniform mat3 uTranslationMatrix;\\nuniform float uRound;\\nuniform vec2 uResolution;\\nuniform vec4 uColor;\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n\\nvec2 roundPixels(vec2 position, vec2 targetSize)\\n{       \\n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\nvoid main(void){\\n    float cosRotation = cos(aRotation);\\n    float sinRotation = sin(aRotation);\\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPosition;\\n\\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    if(uRound == 1.0)\\n    {\\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\\n    }\\n\\n    vUV = aUV;\\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\\n}\\n\";\n\n});\n\nparcelRegister(\"5O5wk\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $32417de8f631e47b$export$2e2bcd8739ae039);\nvar $32417de8f631e47b$export$2e2bcd8739ae039 = \"\\nstruct ParticleUniforms {\\n  uProjectionMatrix:mat3x3<f32>,\\n  uColor:vec4<f32>,\\n  uResolution:vec2<f32>,\\n  uRoundPixels:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\\n\\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\\n@group(1) @binding(1) var uSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) color : vec4<f32>,\\n  };\\n@vertex\\nfn mainVertex(\\n  @location(0) aVertex: vec2<f32>,\\n  @location(1) aPosition: vec2<f32>,\\n  @location(2) aUV: vec2<f32>,\\n  @location(3) aColor: vec4<f32>,\\n  @location(4) aRotation: f32,\\n) -> VSOutput {\\n  \\n   let v = vec2(\\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\\n   ) + aPosition;\\n\\n   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\\n\\n  return VSOutput(\\n   position,\\n   aUV,\\n   vColor,\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) color: vec4<f32>,\\n  @builtin(position) position: vec4<f32>,\\n) -> @location(0) vec4<f32> {\\n\\n    var sample = textureSample(uTexture, uSampler, uv) * color;\\n   \\n    return sample;\\n}\";\n\n});\n\n\n\n\nparcelRegister(\"luHtJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuParticleContainerPipe\", () => $4efa5b05cb38feda$export$1097a2b67474552c);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $6upGq = parcelRequire(\"6upGq\");\n\nvar $2B7hE = parcelRequire(\"2B7hE\");\n\"use strict\";\nclass $4efa5b05cb38feda$export$1097a2b67474552c extends (0, $2B7hE.ParticleContainerPipe) {\n    constructor(renderer){\n        super(renderer, new (0, $6upGq.GpuParticleContainerAdaptor)());\n    }\n}\n/** @ignore */ $4efa5b05cb38feda$export$1097a2b67474552c.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGPUPipes\n    ],\n    name: \"particle\"\n};\n\n});\nparcelRegister(\"6upGq\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuParticleContainerAdaptor\", () => $3e142a964d301a66$export$b05a5c43c842f66d);\n\"use strict\";\nclass $3e142a964d301a66$export$b05a5c43c842f66d {\n    execute(particleContainerPipe, container) {\n        const renderer = particleContainerPipe.renderer;\n        const shader = container.shader || particleContainerPipe.defaultShader;\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n        const state = particleContainerPipe.state;\n        const buffer = particleContainerPipe.getBuffers(container);\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPipe.defaultShader,\n            state: state,\n            size: container.particleChildren.length * 6\n        });\n    }\n}\n\n});\n\n\n\nparcelRegister(\"aJIrY\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $jBf3q = parcelRequire(\"jBf3q\");\n\nvar $6lXlh = parcelRequire(\"6lXlh\");\n\"use strict\";\n(0, $arnWa.extensions).add((0, $6lXlh.CanvasTextSystem));\n(0, $arnWa.extensions).add((0, $jBf3q.CanvasTextPipe));\n\n});\nparcelRegister(\"jBf3q\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasTextPipe\", () => $782ad65665e31985$export$ed0d779e44b53050);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $bANDQ = parcelRequire(\"bANDQ\");\n\nvar $gnDql = parcelRequire(\"gnDql\");\n\"use strict\";\nclass $782ad65665e31985$export$ed0d779e44b53050 {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    validateRenderable(text) {\n        return text._didTextUpdate;\n    }\n    addRenderable(text, instructionSet) {\n        const batchableText = this._getGpuText(text);\n        if (text._didTextUpdate) {\n            this._updateGpuText(text);\n            text._didTextUpdate = false;\n        }\n        this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n    }\n    updateRenderable(text) {\n        const batchableText = this._getGpuText(text);\n        batchableText._batcher.updateElement(batchableText);\n    }\n    _updateGpuText(text) {\n        const batchableText = this._getGpuText(text);\n        if (batchableText.texture) this._renderer.canvasText.returnTexture(batchableText.texture);\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        batchableText.texture = batchableText.texture = this._renderer.canvasText.getTexture(text);\n        (0, $bANDQ.updateTextBounds)(batchableText, text);\n    }\n    _getGpuText(text) {\n        return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n    }\n    initGpuText(text) {\n        const batchableText = new (0, $gnDql.BatchableText)(this._renderer);\n        batchableText.renderable = text;\n        batchableText.transform = text.groupTransform;\n        batchableText.bounds = {\n            minX: 0,\n            maxX: 1,\n            minY: 0,\n            maxY: 0\n        };\n        batchableText.roundPixels = this._renderer._roundPixels | text._roundPixels;\n        text._gpuData[this._renderer.uid] = batchableText;\n        return batchableText;\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n/** @ignore */ $782ad65665e31985$export$ed0d779e44b53050.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLPipes,\n        (0, $arnWa.ExtensionType).WebGPUPipes,\n        (0, $arnWa.ExtensionType).CanvasPipes\n    ],\n    name: \"text\"\n};\n\n});\nparcelRegister(\"bANDQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"updateTextBounds\", () => $0e70cc53a28e9d22$export$cd6ce24a38c376aa);\n\nvar $lQ82U = parcelRequire(\"lQ82U\");\n\"use strict\";\nfunction $0e70cc53a28e9d22$export$cd6ce24a38c376aa(batchableSprite, text) {\n    const { texture: texture, bounds: bounds } = batchableSprite;\n    (0, $lQ82U.updateQuadBounds)(bounds, text._anchor, texture);\n    const padding = text._style._getFinalPadding();\n    bounds.minX -= padding;\n    bounds.minY -= padding;\n    bounds.maxX -= padding;\n    bounds.maxY -= padding;\n}\n\n});\n\nparcelRegister(\"gnDql\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableText\", () => $de9bc8604c3d657e$export$f986f9176e9ba9b4);\n\nvar $2owzg = parcelRequire(\"2owzg\");\n\"use strict\";\nclass $de9bc8604c3d657e$export$f986f9176e9ba9b4 extends (0, $2owzg.BatchableSprite) {\n    constructor(renderer){\n        super();\n        this._renderer = renderer;\n        renderer.runners.resolutionChange.add(this);\n    }\n    resolutionChange() {\n        const text = this.renderable;\n        if (text._autoResolution) text.onViewUpdate();\n    }\n    destroy() {\n        this._renderer.canvasText.returnTexture(this.texture);\n        this._renderer = null;\n    }\n}\n\n});\n\n\nparcelRegister(\"6lXlh\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasTextSystem\", () => $185a6de3ef267a4e$export$56e4907c2e518abc);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $1OAPg = parcelRequire(\"1OAPg\");\n\nvar $f3tpA = parcelRequire(\"f3tpA\");\n\nvar $3E4eL = parcelRequire(\"3E4eL\");\n\nvar $7zo47 = parcelRequire(\"7zo47\");\n\nvar $92MY1 = parcelRequire(\"92MY1\");\n\nvar $9s39u = parcelRequire(\"9s39u\");\n\"use strict\";\nclass $185a6de3ef267a4e$export$56e4907c2e518abc {\n    constructor(_renderer){\n        this._renderer = _renderer;\n    }\n    getTexture(options, _resolution, _style, _textKey) {\n        if (typeof options === \"string\") {\n            (0, $3E4eL.deprecation)(\"8.0.0\", \"CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments\");\n            options = {\n                text: options,\n                style: _style,\n                resolution: _resolution\n            };\n        }\n        if (!(options.style instanceof (0, $7zo47.TextStyle))) options.style = new (0, $7zo47.TextStyle)(options.style);\n        if (!(options.textureStyle instanceof (0, $f3tpA.TextureStyle))) options.textureStyle = new (0, $f3tpA.TextureStyle)(options.textureStyle);\n        if (typeof options.text !== \"string\") options.text = options.text.toString();\n        const { text: text, style: style, textureStyle: textureStyle } = options;\n        const resolution = options.resolution ?? this._renderer.resolution;\n        const { frame: frame, canvasAndContext: canvasAndContext } = (0, $9s39u.CanvasTextGenerator).getCanvasAndContext({\n            text: text,\n            style: style,\n            resolution: resolution\n        });\n        const texture = (0, $92MY1.getPo2TextureFromSource)(canvasAndContext.canvas, frame.width, frame.height, resolution);\n        if (textureStyle) texture.source.style = textureStyle;\n        if (style.trim) {\n            frame.pad(style.padding);\n            texture.frame.copyFrom(frame);\n            texture.updateUvs();\n        }\n        if (style.filters) {\n            const filteredTexture = this._applyFilters(texture, style.filters);\n            this.returnTexture(texture);\n            (0, $9s39u.CanvasTextGenerator).returnCanvasAndContext(canvasAndContext);\n            return filteredTexture;\n        }\n        this._renderer.texture.initSource(texture._source);\n        (0, $9s39u.CanvasTextGenerator).returnCanvasAndContext(canvasAndContext);\n        return texture;\n    }\n    /**\n   * Returns a texture that was created wit the above `getTexture` function.\n   * Handy if you are done with a texture and want to return it to the pool.\n   * @param texture - The texture to be returned.\n   */ returnTexture(texture) {\n        const source = texture.source;\n        source.resource = null;\n        source.uploadMethodId = \"unknown\";\n        source.alphaMode = \"no-premultiply-alpha\";\n        (0, $1OAPg.TexturePool).returnTexture(texture, true);\n    }\n    /**\n   * Renders text to its canvas, and updates its texture.\n   * @deprecated since 8.10.0\n   */ renderTextToCanvas() {\n        (0, $3E4eL.deprecation)(\"8.10.0\", \"CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead\");\n    }\n    /**\n   * Applies the specified filters to the given texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n   * texture is set to 'premultiplied-alpha'.\n   * @param {Texture} texture - The texture to which the filters will be applied.\n   * @param {Filter[]} filters - The filters to apply to the texture.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   */ _applyFilters(texture, filters) {\n        const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n        const resultTexture = this._renderer.filter.generateFilteredTexture({\n            texture: texture,\n            filters: filters\n        });\n        this._renderer.renderTarget.bind(currentRenderTarget, false);\n        return resultTexture;\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n/** @ignore */ $185a6de3ef267a4e$export$56e4907c2e518abc.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLSystem,\n        (0, $arnWa.ExtensionType).WebGPUSystem,\n        (0, $arnWa.ExtensionType).CanvasSystem\n    ],\n    name: \"canvasText\"\n};\n\n});\nparcelRegister(\"92MY1\", function(module, exports) {\n\n$parcel$export(module.exports, \"getPo2TextureFromSource\", () => $c7538d62d0b01c84$export$80c61c6b7fb407a3);\n\nvar $1OAPg = parcelRequire(\"1OAPg\");\n\nvar $8SALt = parcelRequire(\"8SALt\");\n\"use strict\";\nconst $c7538d62d0b01c84$var$tempBounds = new (0, $8SALt.Bounds)();\nfunction $c7538d62d0b01c84$export$80c61c6b7fb407a3(image, width, height, resolution) {\n    const bounds = $c7538d62d0b01c84$var$tempBounds;\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = image.width / resolution | 0;\n    bounds.maxY = image.height / resolution | 0;\n    const texture = (0, $1OAPg.TexturePool).getOptimalTexture(bounds.width, bounds.height, resolution, false);\n    texture.source.uploadMethodId = \"image\";\n    texture.source.resource = image;\n    texture.source.alphaMode = \"premultiply-alpha-on-upload\";\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n    texture.source.emit(\"update\", texture.source);\n    texture.updateUvs();\n    return texture;\n}\n\n});\n\n\n\nparcelRegister(\"cucmg\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $hsvCm = parcelRequire(\"hsvCm\");\n\"use strict\";\n(0, $arnWa.extensions).add((0, $hsvCm.BitmapTextPipe));\n\n});\nparcelRegister(\"hsvCm\", function(module, exports) {\n\n$parcel$export(module.exports, \"BitmapTextPipe\", () => $92aa6cafece1cf42$export$83d8b05a29a5f8ed);\n\nvar $ade8a = parcelRequire(\"ade8a\");\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $9oyb9 = parcelRequire(\"9oyb9\");\n\nvar $fxqK4 = parcelRequire(\"fxqK4\");\n\nvar $gDCWG = parcelRequire(\"gDCWG\");\n\nvar $8UQWE = parcelRequire(\"8UQWE\");\n\nvar $chxMn = parcelRequire(\"chxMn\");\n\"use strict\";\nclass $92aa6cafece1cf42$export$b542b9239140e808 extends (0, $9oyb9.Graphics) {\n    destroy() {\n        if (this.context.customShader) this.context.customShader.destroy();\n        super.destroy();\n    }\n}\nclass $92aa6cafece1cf42$export$83d8b05a29a5f8ed {\n    constructor(renderer){\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, \"_gpuBitmapText\");\n    }\n    validateRenderable(bitmapText) {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n        if (bitmapText._didTextUpdate) {\n            bitmapText._didTextUpdate = false;\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n    }\n    addRenderable(bitmapText, instructionSet) {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n        $92aa6cafece1cf42$var$syncWithProxy(bitmapText, graphicsRenderable);\n        if (bitmapText._didTextUpdate) {\n            bitmapText._didTextUpdate = false;\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n        if (graphicsRenderable.context.customShader) this._updateDistanceField(bitmapText);\n    }\n    updateRenderable(bitmapText) {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n        $92aa6cafece1cf42$var$syncWithProxy(bitmapText, graphicsRenderable);\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n        if (graphicsRenderable.context.customShader) this._updateDistanceField(bitmapText);\n    }\n    _updateContext(bitmapText, proxyGraphics) {\n        const { context: context } = proxyGraphics;\n        const bitmapFont = (0, $8UQWE.BitmapFontManager).getFont(bitmapText.text, bitmapText._style);\n        context.clear();\n        if (bitmapFont.distanceField.type !== \"none\") {\n            if (!context.customShader) context.customShader = new (0, $gDCWG.SdfShader)(this._renderer.limits.maxBatchableTextures);\n        }\n        const chars = (0, $fxqK4.CanvasTextMetrics).graphemeSegmenter(bitmapText.text);\n        const style = bitmapText._style;\n        let currentY = bitmapFont.baseLineOffset;\n        const bitmapTextLayout = (0, $chxMn.getBitmapTextLayout)(chars, style, bitmapFont, true);\n        let index = 0;\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n        if (style._stroke) {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n        context.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;\n        for(let i = 0; i < bitmapTextLayout.lines.length; i++){\n            const line = bitmapTextLayout.lines[i];\n            for(let j = 0; j < line.charPositions.length; j++){\n                const char = chars[index++];\n                const charData = bitmapFont.chars[char];\n                if (charData?.texture) context.texture(charData.texture, tint ? tint : \"black\", Math.round(line.charPositions[j] + charData.xOffset), Math.round(currentY + charData.yOffset));\n            }\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n    _getGpuBitmapText(bitmapText) {\n        return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n    }\n    initGpuText(bitmapText) {\n        const proxyRenderable = new $92aa6cafece1cf42$export$b542b9239140e808();\n        bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n        this._updateContext(bitmapText, proxyRenderable);\n        return proxyRenderable;\n    }\n    _updateDistanceField(bitmapText) {\n        const context = this._getGpuBitmapText(bitmapText).context;\n        const fontFamily = bitmapText._style.fontFamily;\n        const dynamicFont = (0, $ade8a.Cache).get(`${fontFamily}-bitmap`);\n        const { a: a, b: b, c: c, d: d } = bitmapText.groupTransform;\n        const dx = Math.sqrt(a * a + b * b);\n        const dy = Math.sqrt(c * c + d * d);\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n/** @ignore */ $92aa6cafece1cf42$export$83d8b05a29a5f8ed.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLPipes,\n        (0, $arnWa.ExtensionType).WebGPUPipes,\n        (0, $arnWa.ExtensionType).CanvasPipes\n    ],\n    name: \"bitmapText\"\n};\nfunction $92aa6cafece1cf42$var$syncWithProxy(container, proxy) {\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n\n});\nparcelRegister(\"gDCWG\", function(module, exports) {\n\n$parcel$export(module.exports, \"SdfShader\", () => $998fe545b76bda5f$export$f19b070f8409d54d);\n\nvar $foUtO = parcelRequire(\"foUtO\");\n\nvar $ej4f8 = parcelRequire(\"ej4f8\");\n\nvar $5YxuX = parcelRequire(\"5YxuX\");\n\nvar $17smN = parcelRequire(\"17smN\");\n\nvar $g7AUH = parcelRequire(\"g7AUH\");\n\nvar $bOtGK = parcelRequire(\"bOtGK\");\n\nvar $e7K56 = parcelRequire(\"e7K56\");\n\nvar $3Nxyo = parcelRequire(\"3Nxyo\");\n\nvar $8gyqY = parcelRequire(\"8gyqY\");\n\nvar $7Lg6q = parcelRequire(\"7Lg6q\");\n\"use strict\";\nlet $998fe545b76bda5f$var$gpuProgram;\nlet $998fe545b76bda5f$var$glProgram;\nclass $998fe545b76bda5f$export$f19b070f8409d54d extends (0, $e7K56.Shader) {\n    constructor(maxTextures){\n        const uniforms = new (0, $3Nxyo.UniformGroup)({\n            uColor: {\n                value: new Float32Array([\n                    1,\n                    1,\n                    1,\n                    1\n                ]),\n                type: \"vec4<f32>\"\n            },\n            uTransformMatrix: {\n                value: new (0, $foUtO.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uDistance: {\n                value: 4,\n                type: \"f32\"\n            },\n            uRound: {\n                value: 0,\n                type: \"f32\"\n            }\n        });\n        $998fe545b76bda5f$var$gpuProgram ?? ($998fe545b76bda5f$var$gpuProgram = (0, $ej4f8.compileHighShaderGpuProgram)({\n            name: \"sdf-shader\",\n            bits: [\n                (0, $5YxuX.colorBit),\n                (0, $17smN.generateTextureBatchBit)(maxTextures),\n                (0, $8gyqY.localUniformMSDFBit),\n                (0, $7Lg6q.mSDFBit),\n                (0, $g7AUH.roundPixelsBit)\n            ]\n        }));\n        $998fe545b76bda5f$var$glProgram ?? ($998fe545b76bda5f$var$glProgram = (0, $ej4f8.compileHighShaderGlProgram)({\n            name: \"sdf-shader\",\n            bits: [\n                (0, $5YxuX.colorBitGl),\n                (0, $17smN.generateTextureBatchBitGl)(maxTextures),\n                (0, $8gyqY.localUniformMSDFBitGl),\n                (0, $7Lg6q.mSDFBitGl),\n                (0, $g7AUH.roundPixelsBitGl)\n            ]\n        }));\n        super({\n            glProgram: $998fe545b76bda5f$var$glProgram,\n            gpuProgram: $998fe545b76bda5f$var$gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: (0, $bOtGK.getBatchSamplersUniformGroup)(maxTextures)\n            }\n        });\n    }\n}\n\n});\nparcelRegister(\"8gyqY\", function(module, exports) {\n\n$parcel$export(module.exports, \"localUniformMSDFBit\", () => $1cb27b676a486d96$export$95191d1d81ffe694);\n$parcel$export(module.exports, \"localUniformMSDFBitGl\", () => $1cb27b676a486d96$export$7542046ad25e8068);\n\"use strict\";\nconst $1cb27b676a486d96$export$95191d1d81ffe694 = {\n    name: \"local-uniform-msdf-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */ `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */ `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */ `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */ `\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n    }\n};\nconst $1cb27b676a486d96$export$7542046ad25e8068 = {\n    name: \"local-uniform-msdf-bit\",\n    vertex: {\n        header: /* glsl */ `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */ `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */ `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */ `\n            uniform float uDistance;\n         `,\n        main: /* glsl */ `\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n    }\n};\n\n});\n\nparcelRegister(\"7Lg6q\", function(module, exports) {\n\n$parcel$export(module.exports, \"mSDFBit\", () => $9607c446db198657$export$382a0eb192cd0a47);\n$parcel$export(module.exports, \"mSDFBitGl\", () => $9607c446db198657$export$52c5bf2a8ebe1f2a);\n\"use strict\";\nconst $9607c446db198657$export$382a0eb192cd0a47 = {\n    name: \"msdf-bit\",\n    fragment: {\n        header: /* wgsl */ `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `\n    }\n};\nconst $9607c446db198657$export$52c5bf2a8ebe1f2a = {\n    name: \"msdf-bit\",\n    fragment: {\n        header: /* glsl */ `\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `\n    }\n};\n\n});\n\n\n\n\nparcelRegister(\"f1viB\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $blhcp = parcelRequire(\"blhcp\");\n\nvar $asZLE = parcelRequire(\"asZLE\");\n\"use strict\";\n(0, $arnWa.extensions).add((0, $asZLE.HTMLTextSystem));\n(0, $arnWa.extensions).add((0, $blhcp.HTMLTextPipe));\n\n});\nparcelRegister(\"blhcp\", function(module, exports) {\n\n$parcel$export(module.exports, \"HTMLTextPipe\", () => $863662db7e570ec0$export$ffcef6958193be1c);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $aLn8X = parcelRequire(\"aLn8X\");\n\nvar $bANDQ = parcelRequire(\"bANDQ\");\n\nvar $4wjQA = parcelRequire(\"4wjQA\");\n\"use strict\";\nclass $863662db7e570ec0$export$ffcef6958193be1c {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    validateRenderable(htmlText) {\n        return htmlText._didTextUpdate;\n    }\n    addRenderable(htmlText, instructionSet) {\n        const batchableHTMLText = this._getGpuText(htmlText);\n        if (htmlText._didTextUpdate) {\n            this._updateGpuText(htmlText).catch((e)=>{\n                console.error(e);\n            });\n            htmlText._didTextUpdate = false;\n            (0, $bANDQ.updateTextBounds)(batchableHTMLText, htmlText);\n        }\n        this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n    }\n    updateRenderable(htmlText) {\n        const batchableHTMLText = this._getGpuText(htmlText);\n        batchableHTMLText._batcher.updateElement(batchableHTMLText);\n    }\n    async _updateGpuText(htmlText) {\n        htmlText._didTextUpdate = false;\n        const batchableHTMLText = this._getGpuText(htmlText);\n        if (batchableHTMLText.generatingTexture) return;\n        if (batchableHTMLText.texturePromise) {\n            this._renderer.htmlText.returnTexturePromise(batchableHTMLText.texturePromise);\n            batchableHTMLText.texturePromise = null;\n        }\n        batchableHTMLText.generatingTexture = true;\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        const texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n        batchableHTMLText.texturePromise = texturePromise;\n        batchableHTMLText.texture = await texturePromise;\n        const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n        if (renderGroup) renderGroup.structureDidChange = true;\n        batchableHTMLText.generatingTexture = false;\n        (0, $bANDQ.updateTextBounds)(batchableHTMLText, htmlText);\n    }\n    _getGpuText(htmlText) {\n        return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n    }\n    initGpuText(htmlText) {\n        const batchableHTMLText = new (0, $4wjQA.BatchableHTMLText)(this._renderer);\n        batchableHTMLText.renderable = htmlText;\n        batchableHTMLText.transform = htmlText.groupTransform;\n        batchableHTMLText.texture = (0, $aLn8X.Texture).EMPTY;\n        batchableHTMLText.bounds = {\n            minX: 0,\n            maxX: 1,\n            minY: 0,\n            maxY: 0\n        };\n        batchableHTMLText.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n        return batchableHTMLText;\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n/** @ignore */ $863662db7e570ec0$export$ffcef6958193be1c.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLPipes,\n        (0, $arnWa.ExtensionType).WebGPUPipes,\n        (0, $arnWa.ExtensionType).CanvasPipes\n    ],\n    name: \"htmlText\"\n};\n\n});\nparcelRegister(\"4wjQA\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableHTMLText\", () => $f25b4baeabb5c94e$export$26955126a6f3eb07);\n\nvar $2owzg = parcelRequire(\"2owzg\");\n\"use strict\";\nclass $f25b4baeabb5c94e$export$26955126a6f3eb07 extends (0, $2owzg.BatchableSprite) {\n    /**\n   * Creates an instance of BatchableHTMLText.\n   * @param renderer - The renderer instance to be used.\n   */ constructor(renderer){\n        super();\n        this.generatingTexture = false;\n        this._renderer = renderer;\n        renderer.runners.resolutionChange.add(this);\n    }\n    /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */ resolutionChange() {\n        const text = this.renderable;\n        if (text._autoResolution) text.onViewUpdate();\n    }\n    /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */ destroy() {\n        this._renderer.htmlText.returnTexturePromise(this.texturePromise);\n        this.texturePromise = null;\n        this._renderer = null;\n    }\n}\n\n});\n\n\nparcelRegister(\"asZLE\", function(module, exports) {\n\n$parcel$export(module.exports, \"HTMLTextSystem\", () => $f038542ce2b3591d$export$f1b82676a746d8e9);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $iZnM3 = parcelRequire(\"iZnM3\");\n\nvar $1OAPg = parcelRequire(\"1OAPg\");\n\nvar $B03Gj = parcelRequire(\"B03Gj\");\n\nvar $2rOmo = parcelRequire(\"2rOmo\");\n\nvar $cODmL = parcelRequire(\"cODmL\");\n\nvar $ehSI3 = parcelRequire(\"ehSI3\");\n\nvar $92MY1 = parcelRequire(\"92MY1\");\n\nvar $jsjcA = parcelRequire(\"jsjcA\");\n\nvar $fiXlD = parcelRequire(\"fiXlD\");\n\nvar $9rBIH = parcelRequire(\"9rBIH\");\n\nvar $28FcK = parcelRequire(\"28FcK\");\n\nvar $bfoov = parcelRequire(\"bfoov\");\n\nvar $jnJs9 = parcelRequire(\"jnJs9\");\n\nvar $dcBTC = parcelRequire(\"dcBTC\");\n\nvar $hCLHS = parcelRequire(\"hCLHS\");\n\"use strict\";\nclass $f038542ce2b3591d$export$f1b82676a746d8e9 {\n    constructor(renderer){\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === (0, $B03Gj.RendererType).WEBGPU;\n    }\n    /**\n   * @param options\n   * @deprecated Use getTexturePromise instead\n   */ getTexture(options) {\n        return this.getTexturePromise(options);\n    }\n    getTexturePromise(options) {\n        return this._buildTexturePromise(options);\n    }\n    async _buildTexturePromise(options) {\n        const { text: text, style: style, resolution: resolution, textureStyle: textureStyle } = options;\n        const htmlTextData = (0, $ehSI3.BigPool).get((0, $jsjcA.HTMLTextRenderData));\n        const fontFamilies = (0, $9rBIH.extractFontFamilies)(text, style);\n        const fontCSS = await (0, $28FcK.getFontCss)(fontFamilies, style, (0, $fiXlD.HTMLTextStyle).defaultTextStyle);\n        const measured = (0, $hCLHS.measureHtmlText)(text, style, fontCSS, htmlTextData);\n        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n        const image = htmlTextData.image;\n        const uvSafeOffset = 2;\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n        const svgURL = (0, $bfoov.getSVGUrl)(text, style, resolution, fontCSS, htmlTextData);\n        await (0, $dcBTC.loadSVGImage)(image, svgURL, (0, $2rOmo.isSafari)() && fontFamilies.length > 0);\n        const resource = image;\n        let canvasAndContext;\n        if (this._createCanvas) canvasAndContext = (0, $jnJs9.getTemporaryCanvasFromImage)(image, resolution);\n        const texture = (0, $92MY1.getPo2TextureFromSource)(canvasAndContext ? canvasAndContext.canvas : resource, image.width - uvSafeOffset, image.height - uvSafeOffset, resolution);\n        if (textureStyle) texture.source.style = textureStyle;\n        if (this._createCanvas) {\n            this._renderer.texture.initSource(texture.source);\n            (0, $iZnM3.CanvasPool).returnCanvasAndContext(canvasAndContext);\n        }\n        (0, $ehSI3.BigPool).return(htmlTextData);\n        return texture;\n    }\n    returnTexturePromise(texturePromise) {\n        texturePromise.then((texture)=>{\n            this._cleanUp(texture);\n        }).catch(()=>{\n            (0, $cODmL.warn)(\"HTMLTextSystem: Failed to clean texture\");\n        });\n    }\n    _cleanUp(texture) {\n        (0, $1OAPg.TexturePool).returnTexture(texture, true);\n        texture.source.resource = null;\n        texture.source.uploadMethodId = \"unknown\";\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n/** @ignore */ $f038542ce2b3591d$export$f1b82676a746d8e9.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLSystem,\n        (0, $arnWa.ExtensionType).WebGPUSystem,\n        (0, $arnWa.ExtensionType).CanvasSystem\n    ],\n    name: \"htmlText\"\n};\n\n});\nparcelRegister(\"2rOmo\", function(module, exports) {\n\n$parcel$export(module.exports, \"isSafari\", () => $68aeed0d3a4d122f$export$95df08bae54cb4df);\n\nvar $6vaX0 = parcelRequire(\"6vaX0\");\n\"use strict\";\nfunction $68aeed0d3a4d122f$export$95df08bae54cb4df() {\n    const { userAgent: userAgent } = (0, $6vaX0.DOMAdapter).get().getNavigator();\n    return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\n});\n\nparcelRegister(\"jsjcA\", function(module, exports) {\n\n$parcel$export(module.exports, \"HTMLTextRenderData\", () => $5ada3cbfc39ffa2a$export$47ab50939402e24e);\n\"use strict\";\nconst $5ada3cbfc39ffa2a$var$nssvg = \"http://www.w3.org/2000/svg\";\nconst $5ada3cbfc39ffa2a$var$nsxhtml = \"http://www.w3.org/1999/xhtml\";\nclass $5ada3cbfc39ffa2a$export$47ab50939402e24e {\n    constructor(){\n        this.svgRoot = document.createElementNS($5ada3cbfc39ffa2a$var$nssvg, \"svg\");\n        this.foreignObject = document.createElementNS($5ada3cbfc39ffa2a$var$nssvg, \"foreignObject\");\n        this.domElement = document.createElementNS($5ada3cbfc39ffa2a$var$nsxhtml, \"div\");\n        this.styleElement = document.createElementNS($5ada3cbfc39ffa2a$var$nsxhtml, \"style\");\n        this.image = new Image();\n        const { foreignObject: foreignObject, svgRoot: svgRoot, styleElement: styleElement, domElement: domElement } = this;\n        foreignObject.setAttribute(\"width\", \"10000\");\n        foreignObject.setAttribute(\"height\", \"10000\");\n        foreignObject.style.overflow = \"hidden\";\n        svgRoot.appendChild(foreignObject);\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n\n});\n\nparcelRegister(\"fiXlD\", function(module, exports) {\n\n$parcel$export(module.exports, \"HTMLTextStyle\", () => $cf919ade67202e7d$export$a2664b42ece43c6c);\n\nvar $cODmL = parcelRequire(\"cODmL\");\n\nvar $7zo47 = parcelRequire(\"7zo47\");\n\nvar $aI8Ic = parcelRequire(\"aI8Ic\");\n\"use strict\";\nclass $cf919ade67202e7d$export$a2664b42ece43c6c extends (0, $7zo47.TextStyle) {\n    constructor(options = {}){\n        super(options);\n        this._cssOverrides = [];\n        this.cssOverrides = options.cssOverrides ?? [];\n        this.tagStyles = options.tagStyles ?? {};\n    }\n    /**\n   * List of CSS style overrides to apply to the HTML text.\n   * These styles are added after the built-in styles and can override any default styling.\n   * @advanced\n   */ set cssOverrides(value) {\n        this._cssOverrides = value instanceof Array ? value : [\n            value\n        ];\n        this.update();\n    }\n    /** @advanced */ get cssOverrides() {\n        return this._cssOverrides;\n    }\n    /**\n   * Updates the text style and triggers a refresh of the CSS style cache.\n   * This method is called automatically when style properties are changed.\n   * @example\n   * ```ts\n   * // Update after multiple changes\n   * const text = new HTMLText({\n   *     text: 'Hello World',\n   *     style\n   * });\n   *\n   * style.fontSize = 32;\n   * style.fill = '#00ff00';\n   * style.fontFamily = 'Arial';\n   * style.update(); // Apply all changes at once\n   * ```\n   * @advanced\n   * @see {@link HTMLTextStyle#cssStyle} For accessing the generated CSS\n   * @see {@link HTMLTextStyle#cssOverrides} For managing CSS overrides\n   */ update() {\n        this._cssStyle = null;\n        super.update();\n    }\n    /**\n   * Creates a new HTMLTextStyle object with the same values as this one.\n   * This creates a deep copy of all style properties, including dropShadow and tag styles.\n   * @example\n   * ```ts\n   * // Create original style\n   * const originalStyle = new HTMLTextStyle({\n   *     fontSize: 24,\n   *     fill: '#ff0000',\n   *     tagStyles: {\n   *         header: { fontSize: 32, fill: '#00ff00' }\n   *     }\n   * });\n   *\n   * // Clone the style\n   * const clonedStyle = originalStyle.clone();\n   *\n   * // Modify cloned style independently\n   * clonedStyle.fontSize = 36;\n   * clonedStyle.fill = '#0000ff';\n   *\n   * // Original style remains unchanged\n   * console.log(originalStyle.fontSize); // Still 24\n   * console.log(originalStyle.fill); // Still '#ff0000'\n   * ```\n   *\n   * Properties that are cloned:\n   * - Basic text properties (fontSize, fontFamily, etc.)\n   * - Fill and stroke styles\n   * - Drop shadow configuration\n   * - CSS overrides\n   * - Tag styles (deep copied)\n   * - Word wrap settings\n   * - Alignment and spacing\n   * @returns {HTMLTextStyle} A new HTMLTextStyle instance with the same properties\n   * @see {@link HTMLTextStyle} For available style properties\n   * @see {@link HTMLTextStyle#cssOverrides} For CSS override handling\n   * @see {@link HTMLTextStyle#tagStyles} For tag style configuration\n   * @standard\n   */ clone() {\n        return new $cf919ade67202e7d$export$a2664b42ece43c6c({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow ? {\n                ...this.dropShadow\n            } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n            tagStyles: {\n                ...this.tagStyles\n            }\n        });\n    }\n    /**\n   * The CSS style string that will be applied to the HTML text.\n   * @advanced\n   */ get cssStyle() {\n        if (!this._cssStyle) this._cssStyle = (0, $aI8Ic.textStyleToCSS)(this);\n        return this._cssStyle;\n    }\n    /**\n   * Add a style override, this can be any CSS property\n   * it will override any built-in style. This is the\n   * property and the value as a string (e.g., `color: red`).\n   * This will override any other internal style.\n   * @param {string} value - CSS style(s) to add.\n   * @example\n   * style.addOverride('background-color: red');\n   * @advanced\n   */ addOverride(...value) {\n        const toAdd = value.filter((v)=>!this.cssOverrides.includes(v));\n        if (toAdd.length > 0) {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n    /**\n   * Remove any overrides that match the value.\n   * @param {string} value - CSS style to remove.\n   * @example\n   * style.removeOverride('background-color: red');\n   * @advanced\n   */ removeOverride(...value) {\n        const toRemove = value.filter((v)=>this.cssOverrides.includes(v));\n        if (toRemove.length > 0) {\n            this.cssOverrides = this.cssOverrides.filter((v)=>!toRemove.includes(v));\n            this.update();\n        }\n    }\n    /**\n   * Sets the fill style for the text. HTML text only supports color fills (string or number values).\n   * Texture fills are not supported and will trigger a warning in debug mode.\n   * @example\n   * ```ts\n   * // Using hex colors\n   * const text = new HTMLText({\n   *     text: 'Colored Text',\n   *     style: {\n   *         fill: 0xff0000 // Red color\n   *     }\n   * });\n   *\n   * // Using CSS color strings\n   * text.style.fill = '#00ff00';     // Hex string (Green)\n   * text.style.fill = 'blue';        // Named color\n   * text.style.fill = 'rgb(255,0,0)' // RGB\n   * text.style.fill = '#f0f';        // Short hex\n   *\n   * // Invalid usage (will trigger warning in debug)\n   * text.style.fill = {\n   *     type: 'pattern',\n   *     texture: Texture.from('pattern.png')\n   * }; // Not supported, falls back to default\n   * ```\n   * @param value - The fill color to use. Must be a string or number.\n   * @throws {Warning} In debug mode when attempting to use unsupported fill types\n   * @see {@link TextStyle#fill} For full fill options in canvas text\n   * @standard\n   */ set fill(value) {\n        if (typeof value !== \"string\" && typeof value !== \"number\") (0, $cODmL.warn)(\"[HTMLTextStyle] only color fill is not supported by HTMLText\");\n        super.fill = value;\n    }\n    /**\n   * Sets the stroke style for the text. HTML text only supports color strokes (string or number values).\n   * Texture strokes are not supported and will trigger a warning in debug mode.\n   * @example\n   * ```ts\n   * // Using hex colors\n   * const text = new HTMLText({\n   *     text: 'Outlined Text',\n   *     style: {\n   *         stroke: 0xff0000 // Red outline\n   *     }\n   * });\n   *\n   * // Using CSS color strings\n   * text.style.stroke = '#00ff00';     // Hex string (Green)\n   * text.style.stroke = 'blue';        // Named color\n   * text.style.stroke = 'rgb(255,0,0)' // RGB\n   * text.style.stroke = '#f0f';        // Short hex\n   *\n   * // Using stroke width\n   * text.style = {\n   *     stroke: {\n   *         color: '#ff0000',\n   *         width: 2\n   *     }\n   * };\n   *\n   * // Remove stroke\n   * text.style.stroke = null;\n   *\n   * // Invalid usage (will trigger warning in debug)\n   * text.style.stroke = {\n   *     type: 'pattern',\n   *     texture: Texture.from('pattern.png')\n   * }; // Not supported, falls back to default\n   * ```\n   * @param value - The stroke style to use. Must be a string, number, or stroke configuration object\n   * @throws {Warning} In debug mode when attempting to use unsupported stroke types\n   * @see {@link TextStyle#stroke} For full stroke options in canvas text\n   * @standard\n   */ set stroke(value) {\n        if (value && typeof value !== \"string\" && typeof value !== \"number\") (0, $cODmL.warn)(\"[HTMLTextStyle] only color stroke is not supported by HTMLText\");\n        super.stroke = value;\n    }\n}\n\n});\nparcelRegister(\"aI8Ic\", function(module, exports) {\n\n$parcel$export(module.exports, \"textStyleToCSS\", () => $af5a68e1fdd228ed$export$8daecfbc002513c1);\n\nvar $48fkQ = parcelRequire(\"48fkQ\");\n\"use strict\";\nfunction $af5a68e1fdd228ed$export$8daecfbc002513c1(style) {\n    const stroke = style._stroke;\n    const fill = style._fill;\n    const cssStyleString = [\n        `color: ${(0, $48fkQ.Color).shared.setValue(fill.color).toHex()}`,\n        `font-size: ${style.fontSize}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${style.whiteSpace === \"pre\" && style.wordWrap ? \"pre-wrap\" : style.whiteSpace}`,\n        ...style.lineHeight ? [\n            `line-height: ${style.lineHeight}px`\n        ] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? \"break-all\" : \"break-word\"}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [\n            $af5a68e1fdd228ed$var$strokeToCSS(stroke)\n        ] : [],\n        ...style.dropShadow ? [\n            $af5a68e1fdd228ed$var$dropShadowToCSS(style.dropShadow)\n        ] : [],\n        ...style.cssOverrides\n    ].join(\";\");\n    const cssStyles = [\n        `div { ${cssStyleString} }`\n    ];\n    $af5a68e1fdd228ed$var$tagStyleToCSS(style.tagStyles, cssStyles);\n    return cssStyles.join(\" \");\n}\nfunction $af5a68e1fdd228ed$var$dropShadowToCSS(dropShadowStyle) {\n    const color = (0, $48fkQ.Color).shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const position = `${x}px ${y}px`;\n    if (dropShadowStyle.blur > 0) return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    return `text-shadow: ${position} ${color}`;\n}\nfunction $af5a68e1fdd228ed$var$strokeToCSS(stroke) {\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${(0, $48fkQ.Color).shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${(0, $48fkQ.Color).shared.setValue(stroke.color).toHex()}`,\n        \"paint-order: stroke\"\n    ].join(\";\");\n}\nconst $af5a68e1fdd228ed$var$templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`\n};\nconst $af5a68e1fdd228ed$var$transform = {\n    fill: (value)=>`color: ${(0, $48fkQ.Color).shared.setValue(value).toHex()}`,\n    breakWords: (value)=>`word-wrap: ${value ? \"break-all\" : \"break-word\"}`,\n    stroke: $af5a68e1fdd228ed$var$strokeToCSS,\n    dropShadow: $af5a68e1fdd228ed$var$dropShadowToCSS\n};\nfunction $af5a68e1fdd228ed$var$tagStyleToCSS(tagStyles, out) {\n    for(const i in tagStyles){\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n        for(const j in tagStyle){\n            if ($af5a68e1fdd228ed$var$transform[j]) cssTagStyle.push($af5a68e1fdd228ed$var$transform[j](tagStyle[j]));\n            else if ($af5a68e1fdd228ed$var$templates[j]) cssTagStyle.push($af5a68e1fdd228ed$var$templates[j].replace(\"{{VALUE}}\", tagStyle[j]));\n        }\n        out.push(`${i} { ${cssTagStyle.join(\";\")} }`);\n    }\n}\n\n});\n\n\nparcelRegister(\"9rBIH\", function(module, exports) {\n\n$parcel$export(module.exports, \"extractFontFamilies\", () => $5909f0521f2451f4$export$464e4dcbf779d16c);\n\"use strict\";\nfunction $5909f0521f2451f4$export$464e4dcbf779d16c(text, style) {\n    const fontFamily = style.fontFamily;\n    const fontFamilies = [];\n    const dedupe = {};\n    const regex = /font-family:([^;\"\\s]+)/g;\n    const matches = text.match(regex);\n    function addFontFamily(fontFamily2) {\n        if (!dedupe[fontFamily2]) {\n            fontFamilies.push(fontFamily2);\n            dedupe[fontFamily2] = true;\n        }\n    }\n    if (Array.isArray(fontFamily)) for(let i = 0; i < fontFamily.length; i++)addFontFamily(fontFamily[i]);\n    else addFontFamily(fontFamily);\n    if (matches) matches.forEach((match)=>{\n        const fontFamily2 = match.split(\":\")[1].trim();\n        addFontFamily(fontFamily2);\n    });\n    for(const i in style.tagStyles){\n        const fontFamily2 = style.tagStyles[i].fontFamily;\n        addFontFamily(fontFamily2);\n    }\n    return fontFamilies;\n}\n\n});\n\nparcelRegister(\"28FcK\", function(module, exports) {\n\n$parcel$export(module.exports, \"getFontCss\", () => $b6e208b0ddbc61f0$export$634b39f5e6e8534d);\n\nvar $ade8a = parcelRequire(\"ade8a\");\n\nvar $dh51I = parcelRequire(\"dh51I\");\n\"use strict\";\nconst $b6e208b0ddbc61f0$export$9b6075a0351ad0f8 = /* @__PURE__ */ new Map();\nasync function $b6e208b0ddbc61f0$export$634b39f5e6e8534d(fontFamilies, style, defaultOptions) {\n    const fontPromises = fontFamilies.filter((fontFamily)=>(0, $ade8a.Cache).has(`${fontFamily}-and-url`)).map((fontFamily, i)=>{\n        if (!$b6e208b0ddbc61f0$export$9b6075a0351ad0f8.has(fontFamily)) {\n            const { url: url } = (0, $ade8a.Cache).get(`${fontFamily}-and-url`);\n            if (i === 0) $b6e208b0ddbc61f0$export$9b6075a0351ad0f8.set(fontFamily, (0, $dh51I.loadFontCSS)({\n                fontWeight: style.fontWeight,\n                fontStyle: style.fontStyle,\n                fontFamily: fontFamily\n            }, url));\n            else $b6e208b0ddbc61f0$export$9b6075a0351ad0f8.set(fontFamily, (0, $dh51I.loadFontCSS)({\n                fontWeight: defaultOptions.fontWeight,\n                fontStyle: defaultOptions.fontStyle,\n                fontFamily: fontFamily\n            }, url));\n        }\n        return $b6e208b0ddbc61f0$export$9b6075a0351ad0f8.get(fontFamily);\n    });\n    return (await Promise.all(fontPromises)).join(\"\\n\");\n}\n\n});\nparcelRegister(\"dh51I\", function(module, exports) {\n\n$parcel$export(module.exports, \"loadFontCSS\", () => $0a47f00274fea094$export$d5a8e182a5491db2);\n\nvar $6x5vK = parcelRequire(\"6x5vK\");\n\"use strict\";\nasync function $0a47f00274fea094$export$d5a8e182a5491db2(style, url) {\n    const dataSrc = await (0, $6x5vK.loadFontAsBase64)(url);\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n\n});\nparcelRegister(\"6x5vK\", function(module, exports) {\n\n$parcel$export(module.exports, \"loadFontAsBase64\", () => $e1290b9d55306c7e$export$21404a5ba2126552);\n\nvar $6vaX0 = parcelRequire(\"6vaX0\");\n\"use strict\";\nasync function $e1290b9d55306c7e$export$21404a5ba2126552(url) {\n    const response = await (0, $6vaX0.DOMAdapter).get().fetch(url);\n    const blob = await response.blob();\n    const reader = new FileReader();\n    const dataSrc = await new Promise((resolve, reject)=>{\n        reader.onloadend = ()=>resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n    return dataSrc;\n}\n\n});\n\n\n\nparcelRegister(\"bfoov\", function(module, exports) {\n\n$parcel$export(module.exports, \"getSVGUrl\", () => $dda08f046e8bf63f$export$98b744dca5b9429f);\n\"use strict\";\nfunction $dda08f046e8bf63f$export$98b744dca5b9429f(text, style, resolution, fontCSS, htmlTextData) {\n    const { domElement: domElement, styleElement: styleElement, svgRoot: svgRoot } = htmlTextData;\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute(\"style\", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n    const { width: width, height: height } = htmlTextData.image;\n    svgRoot.setAttribute(\"width\", width.toString());\n    svgRoot.setAttribute(\"height\", height.toString());\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n\n});\n\nparcelRegister(\"jnJs9\", function(module, exports) {\n\n$parcel$export(module.exports, \"getTemporaryCanvasFromImage\", () => $e9ec9b7306ce67f3$export$d871fed544c30b4e);\n\nvar $iZnM3 = parcelRequire(\"iZnM3\");\n\"use strict\";\nfunction $e9ec9b7306ce67f3$export$d871fed544c30b4e(image, resolution) {\n    const canvasAndContext = (0, $iZnM3.CanvasPool).getOptimalCanvasAndContext(image.width, image.height, resolution);\n    const { context: context } = canvasAndContext;\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n    return canvasAndContext;\n}\n\n});\n\nparcelRegister(\"dcBTC\", function(module, exports) {\n\n$parcel$export(module.exports, \"loadSVGImage\", () => $a663ffea206a7599$export$31cf685397f1a12a);\n\"use strict\";\nfunction $a663ffea206a7599$export$31cf685397f1a12a(image, url, delay) {\n    return new Promise(async (resolve)=>{\n        if (delay) await new Promise((resolve2)=>setTimeout(resolve2, 100));\n        image.onload = ()=>{\n            resolve();\n        };\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = \"anonymous\";\n    });\n}\n\n});\n\nparcelRegister(\"hCLHS\", function(module, exports) {\n\n$parcel$export(module.exports, \"measureHtmlText\", () => $64c9efc69c5c9e7f$export$9df7f2a259800030);\n\nvar $jsjcA = parcelRequire(\"jsjcA\");\n\"use strict\";\nlet $64c9efc69c5c9e7f$var$tempHTMLTextRenderData;\nfunction $64c9efc69c5c9e7f$export$9df7f2a259800030(text, style, fontStyleCSS, htmlTextRenderData) {\n    htmlTextRenderData || (htmlTextRenderData = $64c9efc69c5c9e7f$var$tempHTMLTextRenderData || ($64c9efc69c5c9e7f$var$tempHTMLTextRenderData = new (0, $jsjcA.HTMLTextRenderData)()));\n    const { domElement: domElement, styleElement: styleElement, svgRoot: svgRoot } = htmlTextRenderData;\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n    domElement.setAttribute(\"style\", \"transform-origin: top left; display: inline-block\");\n    if (fontStyleCSS) styleElement.textContent = fontStyleCSS;\n    document.body.appendChild(svgRoot);\n    const contentBounds = domElement.getBoundingClientRect();\n    svgRoot.remove();\n    const doublePadding = style.padding * 2;\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height - doublePadding\n    };\n}\n\n});\n\n\n\nparcelRegister(\"l7qDi\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $aQv0r = parcelRequire(\"aQv0r\");\n\"use strict\";\n(0, $arnWa.extensions).add((0, $aQv0r.TilingSpritePipe));\n\n});\nparcelRegister(\"aQv0r\", function(module, exports) {\n\n$parcel$export(module.exports, \"TilingSpritePipe\", () => $41435221e1c64257$export$b56051ebf906ec5d);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $4iD3R = parcelRequire(\"4iD3R\");\n\nvar $19C14 = parcelRequire(\"19C14\");\n\nvar $B03Gj = parcelRequire(\"B03Gj\");\n\nvar $6WOBV = parcelRequire(\"6WOBV\");\n\nvar $jfZ8F = parcelRequire(\"jfZ8F\");\n\nvar $fSWkS = parcelRequire(\"fSWkS\");\n\nvar $7Obr6 = parcelRequire(\"7Obr6\");\n\nvar $gvNpS = parcelRequire(\"gvNpS\");\n\nvar $b9Nfj = parcelRequire(\"b9Nfj\");\n\nvar $igtv6 = parcelRequire(\"igtv6\");\n\"use strict\";\nconst $41435221e1c64257$var$sharedQuad = new (0, $gvNpS.QuadGeometry)();\nclass $41435221e1c64257$export$885407fa78df5856 {\n    constructor(){\n        this.canBatch = true;\n        this.geometry = new (0, $fSWkS.MeshGeometry)({\n            indices: $41435221e1c64257$var$sharedQuad.indices.slice(),\n            positions: $41435221e1c64257$var$sharedQuad.positions.slice(),\n            uvs: $41435221e1c64257$var$sharedQuad.uvs.slice()\n        });\n    }\n    destroy() {\n        this.geometry.destroy();\n        this.shader?.destroy();\n    }\n}\nclass $41435221e1c64257$export$b56051ebf906ec5d {\n    constructor(renderer){\n        this._state = (0, $19C14.State).default2d;\n        this._renderer = renderer;\n    }\n    validateRenderable(renderable) {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n        const couldBatch = tilingSpriteData.canBatch;\n        this._updateCanBatch(renderable);\n        const canBatch = tilingSpriteData.canBatch;\n        if (canBatch && canBatch === couldBatch) {\n            const { batchableMesh: batchableMesh } = tilingSpriteData;\n            return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n        }\n        return couldBatch !== canBatch;\n    }\n    addRenderable(tilingSprite, instructionSet) {\n        const batcher = this._renderer.renderPipes.batch;\n        this._updateCanBatch(tilingSprite);\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n        const { geometry: geometry, canBatch: canBatch } = tilingSpriteData;\n        if (canBatch) {\n            tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new (0, $jfZ8F.BatchableMesh)());\n            const batchableMesh = tilingSpriteData.batchableMesh;\n            if (tilingSprite.didViewUpdate) {\n                this._updateBatchableMesh(tilingSprite);\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.setTexture(tilingSprite._texture);\n            }\n            batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n            batcher.addToBatch(batchableMesh, instructionSet);\n        } else {\n            batcher.break(instructionSet);\n            tilingSpriteData.shader || (tilingSpriteData.shader = new (0, $7Obr6.TilingSpriteShader)());\n            this.updateRenderable(tilingSprite);\n            instructionSet.add(tilingSprite);\n        }\n    }\n    execute(tilingSprite) {\n        const { shader: shader } = this._getTilingSpriteData(tilingSprite);\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n        const localUniforms = shader.resources.localUniforms.uniforms;\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n        (0, $6WOBV.color32BitToUniform)(tilingSprite.groupColorAlpha, localUniforms.uColor, 0);\n        this._state.blendMode = (0, $4iD3R.getAdjustedBlendModeBlend)(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n        this._renderer.encoder.draw({\n            geometry: $41435221e1c64257$var$sharedQuad,\n            shader: shader,\n            state: this._state\n        });\n    }\n    updateRenderable(tilingSprite) {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n        const { canBatch: canBatch } = tilingSpriteData;\n        if (canBatch) {\n            const { batchableMesh: batchableMesh } = tilingSpriteData;\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n            batchableMesh._batcher.updateElement(batchableMesh);\n        } else if (tilingSprite.didViewUpdate) {\n            const { shader: shader } = tilingSpriteData;\n            shader.updateUniforms(tilingSprite.width, tilingSprite.height, tilingSprite._tileTransform.matrix, tilingSprite.anchor.x, tilingSprite.anchor.y, tilingSprite.texture);\n        }\n    }\n    _getTilingSpriteData(renderable) {\n        return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n    }\n    _initTilingSpriteData(tilingSprite) {\n        const gpuData = new $41435221e1c64257$export$885407fa78df5856();\n        gpuData.renderable = tilingSprite;\n        tilingSprite._gpuData[this._renderer.uid] = gpuData;\n        return gpuData;\n    }\n    _updateBatchableMesh(tilingSprite) {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const { geometry: geometry } = renderableData;\n        const style = tilingSprite.texture.source.style;\n        if (style.addressMode !== \"repeat\") {\n            style.addressMode = \"repeat\";\n            style.update();\n        }\n        (0, $igtv6.setUvs)(tilingSprite, geometry.uvs);\n        (0, $b9Nfj.setPositions)(tilingSprite, geometry.positions);\n    }\n    destroy() {\n        this._renderer = null;\n    }\n    _updateCanBatch(tilingSprite) {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n        let _nonPowOf2wrapping = true;\n        if (this._renderer.type === (0, $B03Gj.RendererType).WEBGL) _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n        return renderableData.canBatch;\n    }\n}\n/** @ignore */ $41435221e1c64257$export$b56051ebf906ec5d.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLPipes,\n        (0, $arnWa.ExtensionType).WebGPUPipes,\n        (0, $arnWa.ExtensionType).CanvasPipes\n    ],\n    name: \"tilingSprite\"\n};\n\n});\nparcelRegister(\"fSWkS\", function(module, exports) {\n\n$parcel$export(module.exports, \"MeshGeometry\", () => $7e99b50a9c43e1c3$export$8d075a36a73d54bc);\n\nvar $jcjyZ = parcelRequire(\"jcjyZ\");\n\nvar $2M1SI = parcelRequire(\"2M1SI\");\n\nvar $9eCTE = parcelRequire(\"9eCTE\");\n\nvar $3E4eL = parcelRequire(\"3E4eL\");\n\"use strict\";\nconst $7e99b50a9c43e1c3$var$_MeshGeometry = class _MeshGeometry extends (0, $9eCTE.Geometry) {\n    constructor(...args){\n        let options = args[0] ?? {};\n        if (options instanceof Float32Array) {\n            (0, $3E4eL.deprecation)((0, $3E4eL.v8_0_0), \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2]\n            };\n        }\n        options = {\n            ..._MeshGeometry.defaultOptions,\n            ...options\n        };\n        const positions = options.positions || new Float32Array([\n            0,\n            0,\n            1,\n            0,\n            1,\n            1,\n            0,\n            1\n        ]);\n        let uvs = options.uvs;\n        if (!uvs) {\n            if (options.positions) uvs = new Float32Array(positions.length);\n            else uvs = new Float32Array([\n                0,\n                0,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1\n            ]);\n        }\n        const indices = options.indices || new Uint32Array([\n            0,\n            1,\n            2,\n            0,\n            2,\n            3\n        ]);\n        const shrinkToFit = options.shrinkBuffersToFit;\n        const positionBuffer = new (0, $jcjyZ.Buffer)({\n            data: positions,\n            label: \"attribute-mesh-positions\",\n            shrinkToFit: shrinkToFit,\n            usage: (0, $2M1SI.BufferUsage).VERTEX | (0, $2M1SI.BufferUsage).COPY_DST\n        });\n        const uvBuffer = new (0, $jcjyZ.Buffer)({\n            data: uvs,\n            label: \"attribute-mesh-uvs\",\n            shrinkToFit: shrinkToFit,\n            usage: (0, $2M1SI.BufferUsage).VERTEX | (0, $2M1SI.BufferUsage).COPY_DST\n        });\n        const indexBuffer = new (0, $jcjyZ.Buffer)({\n            data: indices,\n            label: \"index-mesh-buffer\",\n            shrinkToFit: shrinkToFit,\n            usage: (0, $2M1SI.BufferUsage).INDEX | (0, $2M1SI.BufferUsage).COPY_DST\n        });\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: \"float32x2\",\n                    stride: 8,\n                    offset: 0\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: \"float32x2\",\n                    stride: 8,\n                    offset: 0\n                }\n            },\n            indexBuffer: indexBuffer,\n            topology: options.topology\n        });\n        this.batchMode = \"auto\";\n    }\n    /** The positions of the mesh. */ get positions() {\n        return this.attributes.aPosition.buffer.data;\n    }\n    /**\n   * Set the positions of the mesh.\n   * When setting the positions, its important that the uvs array is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The positions of the mesh.\n   */ set positions(value) {\n        this.attributes.aPosition.buffer.data = value;\n    }\n    /** The UVs of the mesh. */ get uvs() {\n        return this.attributes.aUV.buffer.data;\n    }\n    /**\n   * Set the UVs of the mesh.\n   * Its important that the uvs array you set is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The UVs of the mesh.\n   */ set uvs(value) {\n        this.attributes.aUV.buffer.data = value;\n    }\n    /** The indices of the mesh. */ get indices() {\n        return this.indexBuffer.data;\n    }\n    set indices(value) {\n        this.indexBuffer.data = value;\n    }\n};\n$7e99b50a9c43e1c3$var$_MeshGeometry.defaultOptions = {\n    topology: \"triangle-list\",\n    shrinkBuffersToFit: false\n};\nlet $7e99b50a9c43e1c3$export$8d075a36a73d54bc = $7e99b50a9c43e1c3$var$_MeshGeometry;\n\n});\n\nparcelRegister(\"7Obr6\", function(module, exports) {\n\n$parcel$export(module.exports, \"TilingSpriteShader\", () => $49f7d8e45dc94ce1$export$d1a26cc57b383809);\n\nvar $foUtO = parcelRequire(\"foUtO\");\n\nvar $ej4f8 = parcelRequire(\"ej4f8\");\n\nvar $eQjNz = parcelRequire(\"eQjNz\");\n\nvar $g7AUH = parcelRequire(\"g7AUH\");\n\nvar $e7K56 = parcelRequire(\"e7K56\");\n\nvar $3Nxyo = parcelRequire(\"3Nxyo\");\n\nvar $aLn8X = parcelRequire(\"aLn8X\");\n\nvar $aMkwq = parcelRequire(\"aMkwq\");\n\"use strict\";\nlet $49f7d8e45dc94ce1$var$gpuProgram;\nlet $49f7d8e45dc94ce1$var$glProgram;\nclass $49f7d8e45dc94ce1$export$d1a26cc57b383809 extends (0, $e7K56.Shader) {\n    constructor(){\n        $49f7d8e45dc94ce1$var$gpuProgram ?? ($49f7d8e45dc94ce1$var$gpuProgram = (0, $ej4f8.compileHighShaderGpuProgram)({\n            name: \"tiling-sprite-shader\",\n            bits: [\n                (0, $eQjNz.localUniformBit),\n                (0, $aMkwq.tilingBit),\n                (0, $g7AUH.roundPixelsBit)\n            ]\n        }));\n        $49f7d8e45dc94ce1$var$glProgram ?? ($49f7d8e45dc94ce1$var$glProgram = (0, $ej4f8.compileHighShaderGlProgram)({\n            name: \"tiling-sprite-shader\",\n            bits: [\n                (0, $eQjNz.localUniformBitGl),\n                (0, $aMkwq.tilingBitGl),\n                (0, $g7AUH.roundPixelsBitGl)\n            ]\n        }));\n        const tilingUniforms = new (0, $3Nxyo.UniformGroup)({\n            uMapCoord: {\n                value: new (0, $foUtO.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uClampFrame: {\n                value: new Float32Array([\n                    0,\n                    0,\n                    1,\n                    1\n                ]),\n                type: \"vec4<f32>\"\n            },\n            uClampOffset: {\n                value: new Float32Array([\n                    0,\n                    0\n                ]),\n                type: \"vec2<f32>\"\n            },\n            uTextureTransform: {\n                value: new (0, $foUtO.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uSizeAnchor: {\n                value: new Float32Array([\n                    100,\n                    100,\n                    0.5,\n                    0.5\n                ]),\n                type: \"vec4<f32>\"\n            }\n        });\n        super({\n            glProgram: $49f7d8e45dc94ce1$var$glProgram,\n            gpuProgram: $49f7d8e45dc94ce1$var$gpuProgram,\n            resources: {\n                localUniforms: new (0, $3Nxyo.UniformGroup)({\n                    uTransformMatrix: {\n                        value: new (0, $foUtO.Matrix)(),\n                        type: \"mat3x3<f32>\"\n                    },\n                    uColor: {\n                        value: new Float32Array([\n                            1,\n                            1,\n                            1,\n                            1\n                        ]),\n                        type: \"vec4<f32>\"\n                    },\n                    uRound: {\n                        value: 0,\n                        type: \"f32\"\n                    }\n                }),\n                tilingUniforms: tilingUniforms,\n                uTexture: (0, $aLn8X.Texture).EMPTY.source,\n                uSampler: (0, $aLn8X.Texture).EMPTY.source.style\n            }\n        });\n    }\n    updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n        const tilingUniforms = this.resources.tilingUniforms;\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n        uTextureTransform.set(matrix.a * textureWidth / width, matrix.b * textureWidth / height, matrix.c * textureHeight / width, matrix.d * textureHeight / height, matrix.tx / width, matrix.ty / height);\n        uTextureTransform.invert();\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n        if (texture) {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n\n});\nparcelRegister(\"aMkwq\", function(module, exports) {\n\n$parcel$export(module.exports, \"tilingBit\", () => $2eab715da6b63a33$export$7551c6773b6af70d);\n$parcel$export(module.exports, \"tilingBitGl\", () => $2eab715da6b63a33$export$a104558c66046525);\n\"use strict\";\nconst $2eab715da6b63a33$export$7551c6773b6af70d = {\n    name: \"tiling-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */ `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */ `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */ `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n};\nconst $2eab715da6b63a33$export$a104558c66046525 = {\n    name: \"tiling-bit\",\n    vertex: {\n        header: /* glsl */ `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `,\n        main: /* glsl */ `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */ `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */ `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    }\n};\n\n});\n\n\nparcelRegister(\"gvNpS\", function(module, exports) {\n\n$parcel$export(module.exports, \"QuadGeometry\", () => $72dcbea81ac68973$export$d27e254c8c1b5a0e);\n\nvar $fSWkS = parcelRequire(\"fSWkS\");\n\"use strict\";\nclass $72dcbea81ac68973$export$d27e254c8c1b5a0e extends (0, $fSWkS.MeshGeometry) {\n    constructor(){\n        super({\n            positions: new Float32Array([\n                0,\n                0,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1\n            ]),\n            uvs: new Float32Array([\n                0,\n                0,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1\n            ]),\n            indices: new Uint32Array([\n                0,\n                1,\n                2,\n                0,\n                2,\n                3\n            ])\n        });\n    }\n}\n\n});\n\nparcelRegister(\"b9Nfj\", function(module, exports) {\n\n$parcel$export(module.exports, \"setPositions\", () => $d417f5ea2259a21c$export$7d390d1e3efa819a);\n\"use strict\";\nfunction $d417f5ea2259a21c$export$7d390d1e3efa819a(tilingSprite, positions) {\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\n});\n\nparcelRegister(\"igtv6\", function(module, exports) {\n\n$parcel$export(module.exports, \"setUvs\", () => $ffde90ef0263e011$export$f99a1f47283a6d20);\n\nvar $foUtO = parcelRequire(\"foUtO\");\n\nvar $acxAJ = parcelRequire(\"acxAJ\");\n\"use strict\";\nfunction $ffde90ef0263e011$export$f99a1f47283a6d20(tilingSprite, uvs) {\n    const texture = tilingSprite.texture;\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n    let anchorX = 0;\n    let anchorY = 0;\n    if (tilingSprite.applyAnchorToTexture) {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n    const textureMatrix = (0, $foUtO.Matrix).shared;\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n    textureMatrix.invert();\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n    (0, $acxAJ.applyMatrix)(uvs, 2, 0, textureMatrix);\n}\n\n});\nparcelRegister(\"acxAJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"applyMatrix\", () => $62bb28c9ea21deba$export$8e14504c3429ee65);\n\"use strict\";\nfunction $62bb28c9ea21deba$export$8e14504c3429ee65(array, stride, offset, matrix) {\n    let index = 0;\n    const size = array.length / (stride || 2);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    offset *= stride;\n    while(index < size){\n        const x = array[offset];\n        const y = array[offset + 1];\n        array[offset] = a * x + c * y + tx;\n        array[offset + 1] = b * x + d * y + ty;\n        offset += stride;\n        index++;\n    }\n}\n\n});\n\n\n\n\nparcelRegister(\"2ZRVb\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $268qR = parcelRequire(\"268qR\");\n\"use strict\";\n(0, $arnWa.extensions).add((0, $268qR.NineSliceSpritePipe));\n\n});\nparcelRegister(\"268qR\", function(module, exports) {\n\n$parcel$export(module.exports, \"NineSliceSpritePipe\", () => $27e420f55975ab25$export$69030e8b070eaa80);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $jfZ8F = parcelRequire(\"jfZ8F\");\n\nvar $iOzIU = parcelRequire(\"iOzIU\");\n\"use strict\";\nclass $27e420f55975ab25$export$33a15b7a67fcc678 extends (0, $jfZ8F.BatchableMesh) {\n    constructor(){\n        super();\n        this.geometry = new (0, $iOzIU.NineSliceGeometry)();\n    }\n    destroy() {\n        this.geometry.destroy();\n    }\n}\nclass $27e420f55975ab25$export$69030e8b070eaa80 {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    addRenderable(sprite, instructionSet) {\n        const gpuSprite = this._getGpuSprite(sprite);\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n    updateRenderable(sprite) {\n        const gpuSprite = this._getGpuSprite(sprite);\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n    validateRenderable(sprite) {\n        const gpuSprite = this._getGpuSprite(sprite);\n        return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, sprite._texture);\n    }\n    _updateBatchableSprite(sprite, batchableSprite) {\n        batchableSprite.geometry.update(sprite);\n        batchableSprite.setTexture(sprite._texture);\n    }\n    _getGpuSprite(sprite) {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n    _initGPUSprite(sprite) {\n        const gpuData = sprite._gpuData[this._renderer.uid] = new $27e420f55975ab25$export$33a15b7a67fcc678();\n        const batchableMesh = gpuData;\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n        if (!sprite.didViewUpdate) this._updateBatchableSprite(sprite, batchableMesh);\n        return gpuData;\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n/** @ignore */ $27e420f55975ab25$export$69030e8b070eaa80.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLPipes,\n        (0, $arnWa.ExtensionType).WebGPUPipes,\n        (0, $arnWa.ExtensionType).CanvasPipes\n    ],\n    name: \"nineSliceSprite\"\n};\n\n});\nparcelRegister(\"iOzIU\", function(module, exports) {\n\n$parcel$export(module.exports, \"NineSliceGeometry\", () => $d14ebf971a0b187d$export$a1f405faf7381142);\n\nvar $jLSB6 = parcelRequire(\"jLSB6\");\n\"use strict\";\nconst $d14ebf971a0b187d$var$_NineSliceGeometry = class _NineSliceGeometry extends (0, $jLSB6.PlaneGeometry) {\n    constructor(options = {}){\n        options = {\n            ..._NineSliceGeometry.defaultOptions,\n            ...options\n        };\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4\n        });\n        this.update(options);\n    }\n    /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */ update(options) {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n        this._anchorX = options.anchor?.x;\n        this._anchorY = options.anchor?.y;\n        this.updateUvs();\n        this.updatePositions();\n    }\n    /** Updates the positions of the vertices. */ updatePositions() {\n        const p = this.positions;\n        const { width: width, height: height, _leftWidth: _leftWidth, _rightWidth: _rightWidth, _topHeight: _topHeight, _bottomHeight: _bottomHeight, _anchorX: _anchorX, _anchorY: _anchorY } = this;\n        const w = _leftWidth + _rightWidth;\n        const scaleW = width > w ? 1 : width / w;\n        const h = _topHeight + _bottomHeight;\n        const scaleH = height > h ? 1 : height / h;\n        const scale = Math.min(scaleW, scaleH);\n        const anchorOffsetX = _anchorX * width;\n        const anchorOffsetY = _anchorY * height;\n        p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n        p[2] = p[10] = p[18] = p[26] = _leftWidth * scale - anchorOffsetX;\n        p[4] = p[12] = p[20] = p[28] = width - _rightWidth * scale - anchorOffsetX;\n        p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n        p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n        p[9] = p[11] = p[13] = p[15] = _topHeight * scale - anchorOffsetY;\n        p[17] = p[19] = p[21] = p[23] = height - _bottomHeight * scale - anchorOffsetY;\n        p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n        this.getBuffer(\"aPosition\").update();\n    }\n    /** Updates the UVs of the vertices. */ updateUvs() {\n        const uvs = this.uvs;\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n        const _uvw = 1 / this._originalWidth;\n        const _uvh = 1 / this._originalHeight;\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n        this.getBuffer(\"aUV\").update();\n    }\n};\n/** The default options for the NineSliceGeometry. */ $d14ebf971a0b187d$var$_NineSliceGeometry.defaultOptions = {\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */ width: 100,\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */ height: 100,\n    /** The width of the left column. */ leftWidth: 10,\n    /** The height of the top row. */ topHeight: 10,\n    /** The width of the right column. */ rightWidth: 10,\n    /** The height of the bottom row. */ bottomHeight: 10,\n    /** The original width of the texture */ originalWidth: 100,\n    /** The original height of the texture */ originalHeight: 100\n};\nlet $d14ebf971a0b187d$export$a1f405faf7381142 = $d14ebf971a0b187d$var$_NineSliceGeometry;\n\n});\nparcelRegister(\"jLSB6\", function(module, exports) {\n\n$parcel$export(module.exports, \"PlaneGeometry\", () => $9620cf5ed25e7440$export$967d831af31f69ce);\n\nvar $3E4eL = parcelRequire(\"3E4eL\");\n\nvar $fSWkS = parcelRequire(\"fSWkS\");\n\"use strict\";\nconst $9620cf5ed25e7440$var$_PlaneGeometry = class _PlaneGeometry extends (0, $fSWkS.MeshGeometry) {\n    constructor(...args){\n        super({});\n        let options = args[0] ?? {};\n        if (typeof options === \"number\") {\n            (0, $3E4eL.deprecation)((0, $3E4eL.v8_0_0), \"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead\");\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3]\n            };\n        }\n        this.build(options);\n    }\n    /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */ build(options) {\n        options = {\n            ..._PlaneGeometry.defaultOptions,\n            ...options\n        };\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n        const sizeX = this.width / verticesX;\n        const sizeY = this.height / verticesY;\n        for(let i = 0; i < total; i++){\n            const x = i % this.verticesX;\n            const y = i / this.verticesX | 0;\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n        const totalSub = verticesX * verticesY;\n        for(let i = 0; i < totalSub; i++){\n            const xpos = i % verticesX;\n            const ypos = i / verticesX | 0;\n            const value = ypos * this.verticesX + xpos;\n            const value2 = ypos * this.verticesX + xpos + 1;\n            const value3 = (ypos + 1) * this.verticesX + xpos;\n            const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n            indices.push(value, value2, value3, value2, value4, value3);\n        }\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n};\n$9620cf5ed25e7440$var$_PlaneGeometry.defaultOptions = {\n    width: 100,\n    height: 100,\n    verticesX: 10,\n    verticesY: 10\n};\nlet $9620cf5ed25e7440$export$967d831af31f69ce = $9620cf5ed25e7440$var$_PlaneGeometry;\n\n});\n\n\n\n\nparcelRegister(\"hn0b8\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $4OSBl = parcelRequire(\"4OSBl\");\n\nvar $01Fst = parcelRequire(\"01Fst\");\n\"use strict\";\n(0, $arnWa.extensions).add((0, $01Fst.FilterSystem));\n(0, $arnWa.extensions).add((0, $4OSBl.FilterPipe));\n\n});\nparcelRegister(\"4OSBl\", function(module, exports) {\n\n$parcel$export(module.exports, \"FilterPipe\", () => $0e1609bc1a16db8d$export$26a654548ff780c7);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\"use strict\";\nclass $0e1609bc1a16db8d$export$26a654548ff780c7 {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    push(filterEffect, container, instructionSet) {\n        const renderPipes = this._renderer.renderPipes;\n        renderPipes.batch.break(instructionSet);\n        instructionSet.add({\n            renderPipeId: \"filter\",\n            canBundle: false,\n            action: \"pushFilter\",\n            container: container,\n            filterEffect: filterEffect\n        });\n    }\n    pop(_filterEffect, _container, instructionSet) {\n        this._renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add({\n            renderPipeId: \"filter\",\n            action: \"popFilter\",\n            canBundle: false\n        });\n    }\n    execute(instruction) {\n        if (instruction.action === \"pushFilter\") this._renderer.filter.push(instruction);\n        else if (instruction.action === \"popFilter\") this._renderer.filter.pop();\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n$0e1609bc1a16db8d$export$26a654548ff780c7.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLPipes,\n        (0, $arnWa.ExtensionType).WebGPUPipes,\n        (0, $arnWa.ExtensionType).CanvasPipes\n    ],\n    name: \"filter\"\n};\n\n});\n\nparcelRegister(\"01Fst\", function(module, exports) {\n\n$parcel$export(module.exports, \"FilterSystem\", () => $d726d91e30b6f8a3$export$e94225c0dfac29cf);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $foUtO = parcelRequire(\"foUtO\");\n\nvar $h6ohx = parcelRequire(\"h6ohx\");\n\nvar $9eCTE = parcelRequire(\"9eCTE\");\n\nvar $3Nxyo = parcelRequire(\"3Nxyo\");\n\nvar $aLn8X = parcelRequire(\"aLn8X\");\n\nvar $1OAPg = parcelRequire(\"1OAPg\");\n\nvar $B03Gj = parcelRequire(\"B03Gj\");\n\nvar $8SALt = parcelRequire(\"8SALt\");\n\nvar $jJTWC = parcelRequire(\"jJTWC\");\n\nvar $cODmL = parcelRequire(\"cODmL\");\n\"use strict\";\nconst $d726d91e30b6f8a3$var$quadGeometry = new (0, $9eCTE.Geometry)({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([\n                0,\n                0,\n                1,\n                0,\n                1,\n                1,\n                0,\n                1\n            ]),\n            format: \"float32x2\",\n            stride: 8,\n            offset: 0\n        }\n    },\n    indexBuffer: new Uint32Array([\n        0,\n        1,\n        2,\n        0,\n        2,\n        3\n    ])\n});\nclass $d726d91e30b6f8a3$var$FilterData {\n    constructor(){\n        /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */ this.skip = false;\n        /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */ this.inputTexture = null;\n        /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */ this.backTexture = null;\n        /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */ this.filters = null;\n        /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */ this.bounds = new (0, $8SALt.Bounds)();\n        /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */ this.container = null;\n        /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */ this.blendRequired = false;\n        /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */ this.outputRenderSurface = null;\n        /**\n     * The offset of the output render surface.\n     * @type {PointData}\n     */ this.outputOffset = {\n            x: 0,\n            y: 0\n        };\n        /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */ this.globalFrame = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n    }\n}\nclass $d726d91e30b6f8a3$export$e94225c0dfac29cf {\n    constructor(renderer){\n        this._filterStackIndex = 0;\n        this._filterStack = [];\n        this._filterGlobalUniforms = new (0, $3Nxyo.UniformGroup)({\n            uInputSize: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uInputPixel: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uInputClamp: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uOutputFrame: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uGlobalFrame: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            },\n            uOutputTexture: {\n                value: new Float32Array(4),\n                type: \"vec4<f32>\"\n            }\n        });\n        this._globalFilterBindGroup = new (0, $h6ohx.BindGroup)({});\n        this.renderer = renderer;\n    }\n    /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */ get activeBackTexture() {\n        return this._activeFilterData?.backTexture;\n    }\n    /**\n   * Pushes a filter instruction onto the filter stack.\n   * @param instruction - The instruction containing the filter effect and container.\n   * @internal\n   */ push(instruction) {\n        const renderer = this.renderer;\n        const filters = instruction.filterEffect.filters;\n        const filterData = this._pushFilterData();\n        filterData.skip = false;\n        filterData.filters = filters;\n        filterData.container = instruction.container;\n        filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n        if (filters.length === 0) {\n            filterData.skip = true;\n            return;\n        }\n        const bounds = filterData.bounds;\n        if (instruction.renderables) (0, $jJTWC.getGlobalRenderableBounds)(instruction.renderables, bounds);\n        else if (instruction.filterEffect.filterArea) {\n            bounds.clear();\n            bounds.addRect(instruction.filterEffect.filterArea);\n            bounds.applyMatrix(instruction.container.worldTransform);\n        } else instruction.container.getFastGlobalBounds(true, bounds);\n        if (instruction.container) {\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n            if (filterFrameTransform) bounds.applyMatrix(filterFrameTransform);\n        }\n        this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n        if (filterData.skip) return;\n        const previousFilterData = this._getPreviousFilterData();\n        let globalResolution = rootResolution;\n        let offsetX = 0;\n        let offsetY = 0;\n        if (previousFilterData) {\n            offsetX = previousFilterData.bounds.minX;\n            offsetY = previousFilterData.bounds.minY;\n            globalResolution = previousFilterData.inputTexture.source._resolution;\n        }\n        filterData.outputOffset.x = bounds.minX - offsetX;\n        filterData.outputOffset.y = bounds.minY - offsetY;\n        const globalFrame = filterData.globalFrame;\n        globalFrame.x = offsetX * globalResolution;\n        globalFrame.y = offsetY * globalResolution;\n        globalFrame.width = colorTextureSource.width * globalResolution;\n        globalFrame.height = colorTextureSource.height * globalResolution;\n        filterData.backTexture = (0, $aLn8X.Texture).EMPTY;\n        if (filterData.blendRequired) {\n            renderer.renderTarget.finishRenderPass();\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n            filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n        }\n        filterData.inputTexture = (0, $1OAPg.TexturePool).getOptimalTexture(bounds.width, bounds.height, filterData.resolution, filterData.antialias);\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        renderer.globalUniforms.push({\n            offset: bounds\n        });\n    }\n    /**\n   * Applies filters to a texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture.\n   * @param {object} params - The parameters for applying filters.\n   * @param {Texture} params.texture - The texture to apply filters to.\n   * @param {Filter[]} params.filters - The filters to apply.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   * @example\n   *\n   * ```ts\n   * // Create a texture and a list of filters\n   * const texture = new Texture(...);\n   * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n   *\n   * // Apply the filters to the texture\n   * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n   *\n   * // Use the resulting texture\n   * sprite.texture = resultTexture;\n   * ```\n   *\n   * Key Points:\n   * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n   * 2. If all filters are disabled or skipped, the original texture is returned.\n   */ generateFilteredTexture({ texture: texture, filters: filters }) {\n        const filterData = this._pushFilterData();\n        this._activeFilterData = filterData;\n        filterData.skip = false;\n        filterData.filters = filters;\n        const colorTextureSource = texture.source;\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n        if (filters.length === 0) {\n            filterData.skip = true;\n            return texture;\n        }\n        const bounds = filterData.bounds;\n        bounds.addRect(texture.frame);\n        this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n        if (filterData.skip) return texture;\n        const globalResolution = rootResolution;\n        const offsetX = 0;\n        const offsetY = 0;\n        filterData.outputOffset.x = -bounds.minX;\n        filterData.outputOffset.y = -bounds.minY;\n        const globalFrame = filterData.globalFrame;\n        globalFrame.x = offsetX * globalResolution;\n        globalFrame.y = offsetY * globalResolution;\n        globalFrame.width = colorTextureSource.width * globalResolution;\n        globalFrame.height = colorTextureSource.height * globalResolution;\n        filterData.outputRenderSurface = (0, $1OAPg.TexturePool).getOptimalTexture(bounds.width, bounds.height, filterData.resolution, filterData.antialias);\n        filterData.backTexture = (0, $aLn8X.Texture).EMPTY;\n        filterData.inputTexture = texture;\n        const renderer = this.renderer;\n        renderer.renderTarget.finishRenderPass();\n        this._applyFiltersToTexture(filterData, true);\n        const outputTexture = filterData.outputRenderSurface;\n        outputTexture.source.alphaMode = \"premultiplied-alpha\";\n        return outputTexture;\n    }\n    /** @internal */ pop() {\n        const renderer = this.renderer;\n        const filterData = this._popFilterData();\n        if (filterData.skip) return;\n        renderer.globalUniforms.pop();\n        renderer.renderTarget.finishRenderPass();\n        this._activeFilterData = filterData;\n        this._applyFiltersToTexture(filterData, false);\n        if (filterData.blendRequired) (0, $1OAPg.TexturePool).returnTexture(filterData.backTexture);\n        (0, $1OAPg.TexturePool).returnTexture(filterData.inputTexture);\n    }\n    /**\n   * Copies the last render surface to a texture.\n   * @param lastRenderSurface - The last render surface to copy from.\n   * @param bounds - The bounds of the area to copy.\n   * @param previousBounds - The previous bounds to use for offsetting the copy.\n   */ getBackTexture(lastRenderSurface, bounds, previousBounds) {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n        const backTexture = (0, $1OAPg.TexturePool).getOptimalTexture(bounds.width, bounds.height, backgroundResolution, false);\n        let x = bounds.minX;\n        let y = bounds.minY;\n        if (previousBounds) {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n        this.renderer.renderTarget.copyToTexture(lastRenderSurface, backTexture, {\n            x: x,\n            y: y\n        }, {\n            width: width,\n            height: height\n        }, {\n            x: 0,\n            y: 0\n        });\n        return backTexture;\n    }\n    /**\n   * Applies a filter to a texture.\n   * @param filter - The filter to apply.\n   * @param input - The input texture.\n   * @param output - The output render surface.\n   * @param clear - Whether to clear the output surface before applying the filter.\n   */ applyFilter(filter, input, output, clear) {\n        const renderer = this.renderer;\n        const filterData = this._activeFilterData;\n        const outputRenderSurface = filterData.outputRenderSurface;\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n        if (outputRenderSurface === output) {\n            outputFrame[0] = filterData.outputOffset.x;\n            outputFrame[1] = filterData.outputOffset.y;\n        } else {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1 / inputPixel[0];\n        inputPixel[3] = 1 / inputPixel[1];\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n        inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n        globalFrame[0] = filterData.globalFrame.x;\n        globalFrame[1] = filterData.globalFrame.y;\n        globalFrame[2] = filterData.globalFrame.width;\n        globalFrame[3] = filterData.globalFrame.height;\n        if (output instanceof (0, $aLn8X.Texture)) output.source.resource = null;\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n        renderer.renderTarget.bind(output, !!clear);\n        if (output instanceof (0, $aLn8X.Texture)) {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        } else {\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n        if (renderer.renderPipes.uniformBatch) {\n            const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        } else this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n        filter.groups[0] = this._globalFilterBindGroup;\n        renderer.encoder.draw({\n            geometry: $d726d91e30b6f8a3$var$quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: \"triangle-list\"\n        });\n        if (renderer.type === (0, $B03Gj.RendererType).WEBGL) renderer.renderTarget.finishRenderPass();\n    }\n    /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */ calculateSpriteMatrix(outputMatrix, sprite) {\n        const data = this._activeFilterData;\n        const mappedMatrix = outputMatrix.set(data.inputTexture._source.width, 0, 0, data.inputTexture._source.height, data.bounds.minX, data.bounds.minY);\n        const worldTransform = sprite.worldTransform.copyTo((0, $foUtO.Matrix).shared);\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n        if (renderGroup && renderGroup.cacheToLocalTransform) worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(1 / sprite.texture.frame.width, 1 / sprite.texture.frame.height);\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n        return mappedMatrix;\n    }\n    destroy() {}\n    _applyFiltersToTexture(filterData, clear) {\n        const inputTexture = filterData.inputTexture;\n        const bounds = filterData.bounds;\n        const filters = filterData.filters;\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n        if (filters.length === 1) filters[0].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n        else {\n            let flip = filterData.inputTexture;\n            const tempTexture = (0, $1OAPg.TexturePool).getOptimalTexture(bounds.width, bounds.height, flip.source._resolution, false);\n            let flop = tempTexture;\n            let i = 0;\n            for(i = 0; i < filters.length - 1; ++i){\n                const filter = filters[i];\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n                flip = flop;\n                flop = t;\n            }\n            filters[i].apply(this, flip, filterData.outputRenderSurface, clear);\n            (0, $1OAPg.TexturePool).returnTexture(tempTexture);\n        }\n    }\n    _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {\n        const renderer = this.renderer;\n        const bounds = filterData.bounds;\n        const filters = filterData.filters;\n        let resolution = Infinity;\n        let padding = 0;\n        let antialias = true;\n        let blendRequired = false;\n        let enabled = false;\n        let clipToViewport = true;\n        for(let i = 0; i < filters.length; i++){\n            const filter = filters[i];\n            resolution = Math.min(resolution, filter.resolution === \"inherit\" ? rootResolution : filter.resolution);\n            padding += filter.padding;\n            if (filter.antialias === \"off\") antialias = false;\n            else if (filter.antialias === \"inherit\") antialias && (antialias = rootAntialias);\n            if (!filter.clipToViewport) clipToViewport = false;\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n            if (!isCompatible) {\n                enabled = false;\n                break;\n            }\n            if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n                (0, $cODmL.warn)(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n                enabled = false;\n                break;\n            }\n            enabled = filter.enabled || enabled;\n            blendRequired || (blendRequired = filter.blendRequired);\n        }\n        if (!enabled) {\n            filterData.skip = true;\n            return;\n        }\n        if (clipToViewport) bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);\n        if (!bounds.isPositive) {\n            filterData.skip = true;\n            return;\n        }\n        filterData.antialias = antialias;\n        filterData.resolution = resolution;\n        filterData.blendRequired = blendRequired;\n    }\n    _popFilterData() {\n        this._filterStackIndex--;\n        return this._filterStack[this._filterStackIndex];\n    }\n    _getPreviousFilterData() {\n        let previousFilterData;\n        let index = this._filterStackIndex - 1;\n        while(index > 1){\n            index--;\n            previousFilterData = this._filterStack[index];\n            if (!previousFilterData.skip) break;\n        }\n        return previousFilterData;\n    }\n    _pushFilterData() {\n        let filterData = this._filterStack[this._filterStackIndex];\n        if (!filterData) filterData = this._filterStack[this._filterStackIndex] = new $d726d91e30b6f8a3$var$FilterData();\n        this._filterStackIndex++;\n        return filterData;\n    }\n}\n/** @ignore */ $d726d91e30b6f8a3$export$e94225c0dfac29cf.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLSystem,\n        (0, $arnWa.ExtensionType).WebGPUSystem\n    ],\n    name: \"filter\"\n};\n\n});\nparcelRegister(\"jJTWC\", function(module, exports) {\n\n$parcel$export(module.exports, \"getGlobalRenderableBounds\", () => $93739931341014c8$export$11abb8ef28048394);\n\"use strict\";\nfunction $93739931341014c8$export$11abb8ef28048394(renderables, bounds) {\n    bounds.clear();\n    const tempMatrix = bounds.matrix;\n    for(let i = 0; i < renderables.length; i++){\n        const renderable = renderables[i];\n        if (renderable.globalDisplayStatus < 7) continue;\n        bounds.matrix = renderable.worldTransform;\n        bounds.addBounds(renderable.bounds);\n    }\n    bounds.matrix = tempMatrix;\n    return bounds;\n}\n\n});\n\n\n\n\n//# sourceMappingURL=browserAll.5a68cb80.js.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { ResizePlugin } from './ResizePlugin.mjs';\nimport { TickerPlugin } from './TickerPlugin.mjs';\n\n\"use strict\";\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      \"resizeTo\",\n      {\n        set(dom) {\n          globalThis.removeEventListener(\"resize\", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener(\"resize\", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener(\"resize\", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = ExtensionType.Application;\n\nexport { ResizePlugin };\n//# sourceMappingURL=ResizePlugin.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link ResizePlugin}.\n * These options control how your application handles window and element resizing.\n * @example\n * ```ts\n * // Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Auto-resize to container element\n * await app.init({ resizeTo: document.querySelector('#game') });\n * ```\n * @category app\n * @standard\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @example\n     * ```ts\n     * const app = new Application();\n     * await app.init({\n     *     resizeTo: window, // Resize to the entire window\n     *     // or\n     *     resizeTo: document.querySelector('#game-container'), // Resize to a specific element\n     *     // or\n     *     resizeTo: null, // Disable auto-resize\n     * });\n     * ```\n     * @default null\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality. This plugin handles automatic\n * and manual resizing of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `resizeTo`: Set an element to automatically resize to\n * - `resize`: Manually trigger a resize\n * - `queueResize`: Queue a resize for the next animation frame\n * - `cancelResize`: Cancel a queued resize\n * @example\n * ```ts\n * import { Application, ResizePlugin } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Example 2: Auto-resize to specific element\n * const container = document.querySelector('#game-container');\n * await app.init({ resizeTo: container });\n *\n * // Example 3: Change resize target at runtime\n * app.resizeTo = window;                    // Enable auto-resize to window\n * app.resizeTo = null;                      // Disable auto-resize\n * ```\n * @category app\n * @standard\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    /** @internal */\n    public static resizeTo: Window | HTMLElement;\n    /** @internal */\n    public static resize: () => void;\n    /** @internal */\n    public static renderer: ResizeableRenderer;\n    /** @internal */\n    public static queueResize: () => void;\n    /** @internal */\n    public static render: () => void;\n    /** @internal */\n    private static _resizeId: number;\n    /** @internal */\n    private static _resizeTo: Window | HTMLElement;\n    /** @internal */\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { UPDATE_PRIORITY } from '../ticker/const.mjs';\nimport { Ticker } from '../ticker/Ticker.mjs';\n\n\"use strict\";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      \"ticker\",\n      {\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = ExtensionType.Application;\n\nexport { TickerPlugin };\n//# sourceMappingURL=TickerPlugin.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link TickerPlugin}.\n * These options control the animation loop and update cycle of your PixiJS application.\n * @example\n * ```ts\n * import { Application } from 'pixi.js';\n *\n * // Basic setup with default options\n * const app = new Application();\n * await app.init({\n *     autoStart: true,     // Start animation loop automatically\n *     sharedTicker: false  // Use dedicated ticker instance\n * });\n *\n * // Advanced setup with shared ticker\n * const app2 = new Application();\n * await app2.init({\n *     autoStart: false,    // Don't start automatically\n *     sharedTicker: true   // Use global shared ticker\n * });\n *\n * // Start animation when ready\n * app2.start();\n * ```\n * @remarks\n * The ticker is the heart of your application's animation system. It:\n * - Manages the render loop\n * - Provides accurate timing information\n * - Handles frame-based updates\n * - Supports priority-based execution order\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For update priority constants\n * @category app\n * @standard\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Controls whether the animation loop starts automatically after initialization.\n     * > [!IMPORTANT]\n     * > Setting this to `false` does NOT stop the shared ticker even if `sharedTicker` is `true`.\n     * > You must stop the shared ticker manually if needed.\n     * @example\n     * ```ts\n     * // Auto-start (default behavior)\n     * await app.init({ autoStart: true });\n     *\n     * // Manual start\n     * await app.init({ autoStart: false });\n     * app.start(); // Start when ready\n     * ```\n     * @default true\n     */\n    autoStart?: boolean;\n\n    /**\n     * Controls whether to use the shared global ticker or create a new instance.\n     *\n     * The shared ticker is useful when you have multiple instances that should sync their updates.\n     * However, it has some limitations regarding update order control.\n     *\n     * Update Order:\n     * 1. System ticker (always runs first)\n     * 2. Shared ticker (if enabled)\n     * 3. App ticker (if using own ticker)\n     * @example\n     * ```ts\n     * // Use shared ticker (global instance)\n     * await app.init({ sharedTicker: true });\n     *\n     * // Use dedicated ticker (default)\n     * await app.init({ sharedTicker: false });\n     *\n     * // Access ticker properties\n     * console.log(app.ticker.FPS);    // Current FPS\n     * console.log(app.ticker.deltaMS); // MS since last update\n     * ```\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link Ticker} functionality. This plugin manages the\n * animation loop and update cycle of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `ticker`: Access to the application's ticker\n * - `start`: Start the animation loop\n * - `stop`: Stop the animation loop\n * @example\n * ```ts\n * import { Application, TickerPlugin, extensions } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Basic ticker usage (default autoStart)\n * await app.init({ autoStart: true });      // Starts ticker automatically\n *\n * // Example 2: Manual ticker control\n * await app.init({ autoStart: false });     // Don't start automatically\n * app.start();                              // Start manually\n * app.stop();                               // Stop manually\n *\n * // Example 3: Add custom update logic\n * app.ticker.add((ticker) => {\n *     // Run every frame, delta is the time since last update\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n * });\n *\n * // Example 4: Control update priority\n * import { UPDATE_PRIORITY } from 'pixi.js';\n *\n * app.ticker.add(\n *     (ticker) => {\n *         // Run before normal priority updates\n *     },\n *     null,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // Example 5: One-time update\n * app.ticker.addOnce(() => {\n *     console.log('Runs next frame only');\n * });\n * ```\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For priority constants\n * @category app\n * @standard\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    /** @internal */\n    public static start: () => void;\n    /** @internal */\n    public static stop: () => void;\n    /** @internal */\n    private static _ticker: Ticker;\n    /** @internal */\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        this._ticker = null;\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem.mjs';\nimport { GraphicsPipe } from './shared/GraphicsPipe.mjs';\n\n\"use strict\";\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../gpu/colorToUniform.mjs';\nimport { BatchableGraphics } from './BatchableGraphics.mjs';\n\n\"use strict\";\nclass GraphicsGpuData {\n  constructor() {\n    this.batches = [];\n    this.batched = false;\n  }\n  destroy() {\n    this.batches.forEach((batch) => {\n      BigPool.return(batch);\n    });\n    this.batches.length = 0;\n  }\n}\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this.renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._adaptor.contextChange(this.renderer);\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!graphics._gpuData;\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics.didViewUpdate) {\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const batches = gpuData.batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batch._batcher.updateElement(batch);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    color32BitToUniform(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    gpuData.destroy();\n    if (gpuContext.isBatchable) {\n      this._updateBatchesForRenderable(graphics, gpuData);\n    }\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getGpuDataForRenderable(graphics).batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getGpuDataForRenderable(graphics) {\n    return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n  }\n  _initGpuDataForRenderable(graphics) {\n    const gpuData = new GraphicsGpuData();\n    graphics._gpuData[this.renderer.uid] = gpuData;\n    return gpuData;\n  }\n  _updateBatchesForRenderable(graphics, gpuData) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    gpuData.batches = gpuContext.batches.map((batch) => {\n      const batchClone = BigPool.get(BatchableGraphics);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"graphics\"\n};\n\nexport { GraphicsGpuData, GraphicsPipe };\n//# sourceMappingURL=GraphicsPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { type Renderer } from '../../../rendering/renderers/types';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext } from './GraphicsContextSystem';\n\n/** @internal */\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    contextChange(renderer: Renderer): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\n\n/** @internal */\nexport class GraphicsGpuData\n{\n    public batches: BatchableGraphics[] = [];\n    public batched = false;\n    public destroy()\n    {\n        this.batches.forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this.batches.length = 0;\n    }\n}\n\n/** @internal */\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: Renderer;\n    public state: State = State.for2d();\n\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: Renderer, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n\n        this.renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._adaptor.contextChange(this.renderer);\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n        const context = graphics.context;\n\n        const wasBatched = !!graphics._gpuData;\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const batches = gpuData.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batch._batcher.updateElement(batch);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // free up the batches..\n        gpuData.destroy();\n\n        if (gpuContext.isBatchable)\n        {\n            this._updateBatchesForRenderable(graphics, gpuData);\n        }\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getGpuDataForRenderable(graphics).batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n    }\n\n    private _initGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        const gpuData = new GraphicsGpuData();\n\n        graphics._gpuData[this.renderer.uid] = gpuData;\n\n        return gpuData;\n    }\n\n    private _updateBatchesForRenderable(graphics: Graphics, gpuData: GraphicsGpuData)\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        gpuData.batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { MeshPipe } from './shared/MeshPipe.mjs';\n\n\"use strict\";\nextensions.add(MeshPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from './BatchableMesh.mjs';\n\n\"use strict\";\nclass MeshGpuData {\n  destroy() {\n  }\n}\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this.localUniformsBindGroup = new BindGroup({\n      0: this.localUniforms\n    });\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      if (batchableMesh.texture.uid !== mesh._texture.uid) {\n        batchableMesh._textureMatrixUpdateId = -1;\n      }\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        mesh._texture\n      );\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const { batched } = this._getMeshData(mesh);\n    if (batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add(mesh);\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  execute(mesh) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    color32BitToUniform(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    var _a, _b;\n    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());\n    return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    mesh._gpuData[this.renderer.uid].meshData = {\n      batched: mesh.batched,\n      indexSize: mesh._geometry.indices?.length,\n      vertexSize: mesh._geometry.positions?.length\n    };\n    return mesh._gpuData[this.renderer.uid].meshData;\n  }\n  _getBatchableMesh(mesh) {\n    var _a, _b;\n    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());\n    return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = new BatchableMesh();\n    gpuMesh.renderable = mesh;\n    gpuMesh.setTexture(mesh._texture);\n    gpuMesh.transform = mesh.groupTransform;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n    return gpuMesh;\n  }\n  destroy() {\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"mesh\"\n};\n\nexport { MeshGpuData, MeshPipe };\n//# sourceMappingURL=MeshPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\n/**\n * GPUData for Mesh\n * @internal\n */\nexport class MeshGpuData implements GPUData\n{\n    public meshData?: MeshData;\n    public batchableMesh?: BatchableMesh;\n\n    public destroy()\n    {\n        // BOOM!\n    }\n}\n\n/**\n * The data for the mesh\n * @internal\n */\ninterface MeshData\n{\n    /** if the mesh is batched or not */\n    batched: boolean;\n    /** the size of the index buffer */\n    indexSize: number;\n    /** the size of the vertex buffer */\n    vertexSize: number;\n}\n\n/** @internal */\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\n/**\n * The MeshPipe is responsible for handling the rendering of Mesh objects.\n * It manages the batching of meshes, updates their GPU data, and executes the rendering instructions.\n * It also handles the local uniforms for each mesh, such as transformation matrices and colors.\n * @category scene\n * @internal\n */\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            if (batchableMesh.texture.uid !== mesh._texture.uid)\n            {\n                batchableMesh._textureMatrixUpdateId = -1;\n            }\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                mesh._texture\n            );\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid].meshData = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        return mesh._gpuData[this.renderer.uid].meshData;\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = new BatchableMesh();\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.setTexture(mesh._texture);\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","\"use strict\";\nclass BatchableMesh {\n  constructor() {\n    this.batcherName = \"default\";\n    this.packAsQuad = false;\n    this.indexOffset = 0;\n    this.attributeOffset = 0;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n    this._textureMatrixUpdateId = -1;\n    this._uvUpdateId = -1;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get topology() {\n    return this._topology || this.geometry.topology;\n  }\n  set topology(value) {\n    this._topology = value;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.geometry = null;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  /**\n   * Sets the texture for the batchable mesh.\n   * As it does so, it resets the texture matrix update ID.\n   * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n   * @param value - The texture to set.\n   */\n  setTexture(value) {\n    if (this.texture === value)\n      return;\n    this.texture = value;\n    this._textureMatrixUpdateId = -1;\n  }\n  get uvs() {\n    const geometry = this.geometry;\n    const uvBuffer = geometry.getBuffer(\"aUV\");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    return transformedUvs;\n  }\n  get positions() {\n    return this.geometry.positions;\n  }\n  get indices() {\n    return this.geometry.indices;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  get groupTransform() {\n    return this.renderable.groupTransform;\n  }\n  get attributeSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\nexport { BatchableMesh };\n//# sourceMappingURL=BatchableMesh.mjs.map\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n\n    public _topology: Topology;\n\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n    public _textureMatrixUpdateId: number = -1;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    get topology() { return this._topology || this.geometry.topology; }\n    set topology(value: Topology) { this._topology = value; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    /**\n     * Sets the texture for the batchable mesh.\n     * As it does so, it resets the texture matrix update ID.\n     * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n     * @param value - The texture to set.\n     */\n    public setTexture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this.texture = value;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe.mjs';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe.mjs';\n\n\"use strict\";\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe';\n\n// NOTE: this is the first occurrence of needing both gl and gpu pipes in the same file\n// This could cause some issues with tree shaking in the future.\n// Right now these two files do not import anything specific for a renderer, so is not an issue for now.\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor.mjs';\nimport { ParticleContainerPipe } from './ParticleContainerPipe.mjs';\n\n\"use strict\";\nclass GlParticleContainerPipe extends ParticleContainerPipe {\n  constructor(renderer) {\n    super(renderer, new GlParticleContainerAdaptor());\n  }\n}\n/** @ignore */\nGlParticleContainerPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes\n  ],\n  name: \"particle\"\n};\n\nexport { GlParticleContainerPipe };\n//# sourceMappingURL=GlParticleContainerPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\n\n/**\n * WebGL renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GlParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer, new GlParticleContainerAdaptor());\n    }\n}\n","\"use strict\";\nclass GlParticleContainerAdaptor {\n  execute(particleContainerPipe, container) {\n    const state = particleContainerPipe.state;\n    const renderer = particleContainerPipe.renderer;\n    const shader = container.shader || particleContainerPipe.defaultShader;\n    shader.resources.uTexture = container.texture._source;\n    shader.resources.uniforms = particleContainerPipe.localUniforms;\n    const gl = renderer.gl;\n    const buffer = particleContainerPipe.getBuffers(container);\n    renderer.shader.bind(shader);\n    renderer.state.set(state);\n    renderer.geometry.bind(buffer.geometry, shader.glProgram);\n    const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n    const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n    gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n  }\n}\n\nexport { GlParticleContainerAdaptor };\n//# sourceMappingURL=GlParticleContainerAdaptor.mjs.map\n","import type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const state = particleContainerPipe.state;\n        const renderer = particleContainerPipe.renderer as WebGLRenderer;\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPipe.localUniforms;\n\n        const gl = renderer.gl;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        // now lets upload and render the buffers..\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { ParticleBuffer } from './ParticleBuffer.mjs';\nimport { ParticleShader } from './shader/ParticleShader.mjs';\n\n\"use strict\";\nclass ParticleContainerPipe {\n  /**\n   * @param renderer - The renderer this sprite batch works for.\n   * @param adaptor\n   */\n  constructor(renderer, adaptor) {\n    /** @internal */\n    this.state = State.for2d();\n    /** Local uniforms that are used for rendering particles. */\n    this.localUniforms = new UniformGroup({\n      uTranslationMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uRound: { value: 1, type: \"f32\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    });\n    this.renderer = renderer;\n    this.adaptor = adaptor;\n    this.defaultShader = new ParticleShader();\n    this.state = State.for2d();\n  }\n  validateRenderable(_renderable) {\n    return false;\n  }\n  addRenderable(renderable, instructionSet) {\n    this.renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(renderable);\n  }\n  getBuffers(renderable) {\n    return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n  }\n  _initBuffer(renderable) {\n    renderable._gpuData[this.renderer.uid] = new ParticleBuffer({\n      size: renderable.particleChildren.length,\n      properties: renderable._properties\n    });\n    return renderable._gpuData[this.renderer.uid];\n  }\n  updateRenderable(_renderable) {\n  }\n  execute(container) {\n    const children = container.particleChildren;\n    if (children.length === 0) {\n      return;\n    }\n    const renderer = this.renderer;\n    const buffer = this.getBuffers(container);\n    container.texture || (container.texture = children[0].texture);\n    const state = this.state;\n    buffer.update(children, container._childrenDirty);\n    container._childrenDirty = false;\n    state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n    const uniforms = this.localUniforms.uniforms;\n    const transformationMatrix = uniforms.uTranslationMatrix;\n    container.worldTransform.copyTo(transformationMatrix);\n    transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n    uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n    uniforms.uRound = renderer._roundPixels | container._roundPixels;\n    color32BitToUniform(\n      container.groupColorAlpha,\n      uniforms.uColor,\n      0\n    );\n    this.adaptor.execute(this, container);\n  }\n  /** Destroys the ParticleRenderer. */\n  destroy() {\n    if (this.defaultShader) {\n      this.defaultShader.destroy();\n      this.defaultShader = null;\n    }\n  }\n}\n\nexport { ParticleContainerPipe };\n//# sourceMappingURL=ParticleContainerPipe.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport { ParticleShader } from './shader/ParticleShader';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { ParticleContainer } from './ParticleContainer';\n\n/** @internal */\nexport interface ParticleContainerAdaptor\n{\n    execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @category scene\n * @internal\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer>\n{\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public defaultShader: Shader;\n\n    /** @internal */\n    public adaptor: ParticleContainerAdaptor;\n    /** @internal */\n    public readonly state = State.for2d();\n    /** @internal */\n    public readonly renderer: Renderer;\n\n    /** Local uniforms that are used for rendering particles. */\n    public readonly localUniforms = new UniformGroup({\n        uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uRound: { value: 1, type: 'f32' },\n        uResolution: { value: [0, 0], type: 'vec2<f32>' },\n    });\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     * @param adaptor\n     */\n    constructor(renderer: Renderer, adaptor: ParticleContainerAdaptor)\n    {\n        this.renderer = renderer;\n\n        this.adaptor = adaptor;\n\n        this.defaultShader = new ParticleShader();\n\n        this.state = State.for2d();\n    }\n\n    public validateRenderable(_renderable: ParticleContainer): boolean\n    {\n        // always fine :D\n        return false;\n    }\n\n    public addRenderable(renderable: ParticleContainer, instructionSet: InstructionSet)\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n\n    public getBuffers(renderable: ParticleContainer): ParticleBuffer\n    {\n        return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n    }\n\n    private _initBuffer(renderable: ParticleContainer): ParticleBuffer\n    {\n        renderable._gpuData[this.renderer.uid] = new ParticleBuffer({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties,\n        });\n\n        return renderable._gpuData[this.renderer.uid];\n    }\n\n    public updateRenderable(_renderable: ParticleContainer)\n    {\n        // nothing to be done here!\n\n    }\n\n    public execute(container: ParticleContainer): void\n    {\n        const children = container.particleChildren;\n\n        if (children.length === 0)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n\n        container.texture ||= children[0].texture;\n\n        const state = this.state;\n\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n\n        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n\n        const uniforms = this.localUniforms.uniforms;\n\n        const transformationMatrix = uniforms.uTranslationMatrix;\n\n        container.worldTransform.copyTo(transformationMatrix);\n\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n\n        color32BitToUniform(\n            container.groupColorAlpha,\n            uniforms.uColor,\n            0\n        );\n\n        this.adaptor.execute(this, container);\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        if (this.defaultShader)\n        {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads.mjs';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction.mjs';\n\n\"use strict\";\nclass ParticleBuffer {\n  constructor(options) {\n    this._size = 0;\n    this._generateParticleUpdateCache = {};\n    const size = this._size = options.size ?? 1e3;\n    const properties = options.properties;\n    let staticVertexSize = 0;\n    let dynamicVertexSize = 0;\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        dynamicVertexSize += attributeInfo.stride;\n      } else {\n        staticVertexSize += attributeInfo.stride;\n      }\n    }\n    this._dynamicStride = dynamicVertexSize / 4;\n    this._staticStride = staticVertexSize / 4;\n    this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n    this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n    this.indexBuffer = createIndicesForQuads(size);\n    const geometry = new Geometry();\n    let dynamicOffset = 0;\n    let staticOffset = 0;\n    this._staticBuffer = new Buffer({\n      data: new Float32Array(1),\n      label: \"static-particle-buffer\",\n      shrinkToFit: false,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    this._dynamicBuffer = new Buffer({\n      data: new Float32Array(1),\n      label: \"dynamic-particle-buffer\",\n      shrinkToFit: false,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._dynamicBuffer,\n          stride: this._dynamicStride * 4,\n          offset: dynamicOffset * 4,\n          format: property.format\n        });\n        dynamicOffset += attributeInfo.size;\n      } else {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._staticBuffer,\n          stride: this._staticStride * 4,\n          offset: staticOffset * 4,\n          format: property.format\n        });\n        staticOffset += attributeInfo.size;\n      }\n    }\n    geometry.addIndex(this.indexBuffer);\n    const uploadFunction = this.getParticleUpdate(properties);\n    this._dynamicUpload = uploadFunction.dynamicUpdate;\n    this._staticUpload = uploadFunction.staticUpdate;\n    this.geometry = geometry;\n  }\n  getParticleUpdate(properties) {\n    const key = getParticleSyncKey(properties);\n    if (this._generateParticleUpdateCache[key]) {\n      return this._generateParticleUpdateCache[key];\n    }\n    this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n    return this._generateParticleUpdateCache[key];\n  }\n  generateParticleUpdate(properties) {\n    return generateParticleUpdateFunction(properties);\n  }\n  update(particles, uploadStatic) {\n    if (particles.length > this._size) {\n      uploadStatic = true;\n      this._size = Math.max(particles.length, this._size * 1.5 | 0);\n      this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n      this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n      this.indexBuffer = createIndicesForQuads(this._size);\n      this.geometry.indexBuffer.setDataWithSize(\n        this.indexBuffer,\n        this.indexBuffer.byteLength,\n        true\n      );\n    }\n    const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n    this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n    this._dynamicBuffer.setDataWithSize(\n      this.dynamicAttributeBuffer.float32View,\n      particles.length * this._dynamicStride * 4,\n      true\n    );\n    if (uploadStatic) {\n      const staticAttributeBuffer = this.staticAttributeBuffer;\n      this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n      this._staticBuffer.setDataWithSize(\n        staticAttributeBuffer.float32View,\n        particles.length * this._staticStride * 4,\n        true\n      );\n    }\n  }\n  destroy() {\n    this._staticBuffer.destroy();\n    this._dynamicBuffer.destroy();\n    this.geometry.destroy();\n  }\n}\nfunction getParticleSyncKey(properties) {\n  const keyGen = [];\n  for (const key in properties) {\n    const property = properties[key];\n    keyGen.push(key, property.code, property.dynamic ? \"d\" : \"s\");\n  }\n  return keyGen.join(\"_\");\n}\n\nexport { ParticleBuffer };\n//# sourceMappingURL=ParticleBuffer.mjs.map\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @internal\n */\nexport interface ParticleBufferOptions\n{\n    /** The size of the particle buffer, defaults to 1000. */\n    size: number;\n    /** A record of attributes that the particle container uses. */\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n","\"use strict\";\nfunction createIndicesForQuads(size, outBuffer = null) {\n  const totalIndices = size * 6;\n  if (totalIndices > 65535) {\n    outBuffer || (outBuffer = new Uint32Array(totalIndices));\n  } else {\n    outBuffer || (outBuffer = new Uint16Array(totalIndices));\n  }\n  if (outBuffer.length !== totalIndices) {\n    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n  }\n  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {\n    outBuffer[i + 0] = j + 0;\n    outBuffer[i + 1] = j + 1;\n    outBuffer[i + 2] = j + 2;\n    outBuffer[i + 3] = j + 0;\n    outBuffer[i + 4] = j + 2;\n    outBuffer[i + 5] = j + 3;\n  }\n  return outBuffer;\n}\n\nexport { createIndicesForQuads };\n//# sourceMappingURL=createIndicesForQuads.mjs.map\n","/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n * @internal\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer ||= new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer ||= new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n","import { getAttributeInfoFromFormat } from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction generateParticleUpdateFunction(properties) {\n  return {\n    dynamicUpdate: generateUpdateFunction(properties, true),\n    staticUpdate: generateUpdateFunction(properties, false)\n  };\n}\nfunction generateUpdateFunction(properties, dynamic) {\n  const funcFragments = [];\n  funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n  let offset = 0;\n  for (const i in properties) {\n    const property = properties[i];\n    if (dynamic !== property.dynamic)\n      continue;\n    funcFragments.push(`offset = index + ${offset}`);\n    funcFragments.push(property.code);\n    const attributeInfo = getAttributeInfoFromFormat(property.format);\n    offset += attributeInfo.stride / 4;\n  }\n  funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n  funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n  const functionSource = funcFragments.join(\"\\n\");\n  return new Function(\"ps\", \"f32v\", \"u32v\", functionSource);\n}\n\nexport { generateParticleUpdateFunction };\n//# sourceMappingURL=generateParticleUpdateFunction.mjs.map\n","import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\n/** @internal */\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\n/**\n * @param properties\n * @internal\n */\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport fragment from './particles.frag.mjs';\nimport vertex from './particles.vert.mjs';\nimport wgsl from './particles.wgsl.mjs';\n\n\"use strict\";\nclass ParticleShader extends Shader {\n  constructor() {\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment\n    });\n    const gpuProgram = GpuProgram.from({\n      fragment: {\n        source: wgsl,\n        entryPoint: \"mainFragment\"\n      },\n      vertex: {\n        source: wgsl,\n        entryPoint: \"mainVertex\"\n      }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        // this will be replaced with the texture from the particle container\n        uTexture: Texture.WHITE.source,\n        // this will be replaced with the texture style from the particle container\n        uSampler: new TextureStyle({}),\n        // this will be replaced with the local uniforms from the particle container\n        uniforms: {\n          uTranslationMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Color(16777215), type: \"vec4<f32>\" },\n          uRound: { value: 1, type: \"f32\" },\n          uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n        }\n      }\n    });\n  }\n}\n\nexport { ParticleShader };\n//# sourceMappingURL=ParticleShader.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\nimport wgsl from './particles.wgsl';\n\n/** @internal */\nexport class ParticleShader extends Shader\n{\n    constructor()\n    {\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment\n        });\n\n        const gpuProgram = GpuProgram.from({\n            fragment: {\n                source: wgsl,\n                entryPoint: 'mainFragment'\n            },\n            vertex: {\n                source: wgsl,\n                entryPoint: 'mainVertex'\n            }\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: Texture.WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new TextureStyle({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Color(0xFFFFFF), type: 'vec4<f32>' },\n                    uRound: { value: 1, type: 'f32' },\n                    uResolution: { value: [0, 0], type: 'vec2<f32>' },\n                }\n            }\n        });\n    }\n}\n","var fragment = \"varying vec2 vUV;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uTexture;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uTexture, vUV) * vColor;\\n    gl_FragColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=particles.frag.mjs.map\n","var vertex = \"attribute vec2 aVertex;\\nattribute vec2 aUV;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPosition;\\nattribute float aRotation;\\n\\nuniform mat3 uTranslationMatrix;\\nuniform float uRound;\\nuniform vec2 uResolution;\\nuniform vec4 uColor;\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n\\nvec2 roundPixels(vec2 position, vec2 targetSize)\\n{       \\n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\nvoid main(void){\\n    float cosRotation = cos(aRotation);\\n    float sinRotation = sin(aRotation);\\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPosition;\\n\\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    if(uRound == 1.0)\\n    {\\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\\n    }\\n\\n    vUV = aUV;\\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=particles.vert.mjs.map\n","var wgsl = \"\\nstruct ParticleUniforms {\\n  uProjectionMatrix:mat3x3<f32>,\\n  uColor:vec4<f32>,\\n  uResolution:vec2<f32>,\\n  uRoundPixels:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\\n\\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\\n@group(1) @binding(1) var uSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) color : vec4<f32>,\\n  };\\n@vertex\\nfn mainVertex(\\n  @location(0) aVertex: vec2<f32>,\\n  @location(1) aPosition: vec2<f32>,\\n  @location(2) aUV: vec2<f32>,\\n  @location(3) aColor: vec4<f32>,\\n  @location(4) aRotation: f32,\\n) -> VSOutput {\\n  \\n   let v = vec2(\\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\\n   ) + aPosition;\\n\\n   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\\n\\n  return VSOutput(\\n   position,\\n   aUV,\\n   vColor,\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) color: vec4<f32>,\\n  @builtin(position) position: vec4<f32>,\\n) -> @location(0) vec4<f32> {\\n\\n    var sample = textureSample(uTexture, uSampler, uv) * color;\\n   \\n    return sample;\\n}\";\n\nexport { wgsl as default };\n//# sourceMappingURL=particles.wgsl.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor.mjs';\nimport { ParticleContainerPipe } from './ParticleContainerPipe.mjs';\n\n\"use strict\";\nclass GpuParticleContainerPipe extends ParticleContainerPipe {\n  constructor(renderer) {\n    super(renderer, new GpuParticleContainerAdaptor());\n  }\n}\n/** @ignore */\nGpuParticleContainerPipe.extension = {\n  type: [\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"particle\"\n};\n\nexport { GpuParticleContainerPipe };\n//# sourceMappingURL=GpuParticleContainerPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\n\n/**\n * WebGPU renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GpuParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer, new GpuParticleContainerAdaptor());\n    }\n}\n","\"use strict\";\nclass GpuParticleContainerAdaptor {\n  execute(particleContainerPipe, container) {\n    const renderer = particleContainerPipe.renderer;\n    const shader = container.shader || particleContainerPipe.defaultShader;\n    shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n    shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n    const state = particleContainerPipe.state;\n    const buffer = particleContainerPipe.getBuffers(container);\n    renderer.encoder.draw({\n      geometry: buffer.geometry,\n      shader: container.shader || particleContainerPipe.defaultShader,\n      state,\n      size: container.particleChildren.length * 6\n    });\n  }\n}\n\nexport { GpuParticleContainerAdaptor };\n//# sourceMappingURL=GpuParticleContainerAdaptor.mjs.map\n","import type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const renderer = particleContainerPipe.renderer as WebGPURenderer;\n\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n\n        const state = particleContainerPipe.state;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPipe.defaultShader,\n            state,\n            size: container.particleChildren.length * 6,\n        });\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe.mjs';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem.mjs';\n\n\"use strict\";\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { updateTextBounds } from '../utils/updateTextBounds.mjs';\nimport { BatchableText } from './BatchableText.mjs';\n\n\"use strict\";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  validateRenderable(text) {\n    return text._didTextUpdate;\n  }\n  addRenderable(text, instructionSet) {\n    const batchableText = this._getGpuText(text);\n    if (text._didTextUpdate) {\n      this._updateGpuText(text);\n      text._didTextUpdate = false;\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n  }\n  updateRenderable(text) {\n    const batchableText = this._getGpuText(text);\n    batchableText._batcher.updateElement(batchableText);\n  }\n  _updateGpuText(text) {\n    const batchableText = this._getGpuText(text);\n    if (batchableText.texture) {\n      this._renderer.canvasText.returnTexture(batchableText.texture);\n    }\n    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n    batchableText.texture = batchableText.texture = this._renderer.canvasText.getTexture(text);\n    updateTextBounds(batchableText, text);\n  }\n  _getGpuText(text) {\n    return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const batchableText = new BatchableText(this._renderer);\n    batchableText.renderable = text;\n    batchableText.transform = text.groupTransform;\n    batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableText.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    text._gpuData[this._renderer.uid] = batchableText;\n    return batchableText;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"text\"\n};\n\nexport { CanvasTextPipe };\n//# sourceMappingURL=CanvasTextPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateTextBounds } from '../utils/updateTextBounds';\nimport { BatchableText } from './BatchableText';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\n/** @internal */\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        return text._didTextUpdate;\n    }\n\n    public addRenderable(text: Text, instructionSet: InstructionSet)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (text._didTextUpdate)\n        {\n            this._updateGpuText(text);\n            text._didTextUpdate = false;\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        batchableText._batcher.updateElement(batchableText);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (batchableText.texture)\n        {\n            this._renderer.canvasText.returnTexture(batchableText.texture);\n        }\n\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n\n        batchableText.texture = batchableText.texture = this._renderer.canvasText.getTexture(text);\n\n        updateTextBounds(batchableText, text);\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const batchableText = new BatchableText(this._renderer);\n\n        batchableText.renderable = text;\n        batchableText.transform = text.groupTransform;\n        batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableText.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        text._gpuData[this._renderer.uid] = batchableText;\n\n        return batchableText;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n","import { updateQuadBounds } from '../../../utils/data/updateQuadBounds.mjs';\n\n\"use strict\";\nfunction updateTextBounds(batchableSprite, text) {\n  const { texture, bounds } = batchableSprite;\n  updateQuadBounds(bounds, text._anchor, texture);\n  const padding = text._style._getFinalPadding();\n  bounds.minX -= padding;\n  bounds.minY -= padding;\n  bounds.maxX -= padding;\n  bounds.maxY -= padding;\n}\n\nexport { updateTextBounds };\n//# sourceMappingURL=updateTextBounds.mjs.map\n","import { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { type BatchableSprite } from '../../sprite/BatchableSprite';\nimport { type AbstractText } from '../AbstractText';\nimport { type TextStyle, type TextStyleOptions } from '../TextStyle';\n\n/**\n * Updates the bounds of the given batchable sprite based on the provided text object.\n *\n * This function adjusts the bounds of the batchable sprite to match the dimensions\n * and anchor point of the text's texture. Additionally, it compensates for any padding\n * specified in the text's style to ensure the text is rendered correctly on screen.\n * @param {BatchableSprite} batchableSprite - The sprite whose bounds need to be updated.\n * @param {AbstractText} text - The text object containing the texture and style information.\n * @internal\n */\nexport function updateTextBounds(batchableSprite: BatchableSprite, text: AbstractText<TextStyle, TextStyleOptions>)\n{\n    const { texture, bounds } = batchableSprite;\n\n    updateQuadBounds(bounds, text._anchor, texture);\n\n    const padding = text._style._getFinalPadding();\n\n    // When HTML text textures are created, they include the padding around the text content\n    // to prevent text clipping and provide a buffer zone. This padding is built into\n    // the texture itself. However, we don't want this padding to affect the text's\n    // actual position on screen.\n    // To compensate, we shift the render position back by the padding amount,\n    // ensuring the text appears exactly where intended while maintaining the\n    // buffer zone around it.\n\n    bounds.minX -= padding;\n    bounds.minY -= padding;\n    bounds.maxX -= padding;\n    bounds.maxY -= padding;\n}\n","import { BatchableSprite } from '../../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass BatchableText extends BatchableSprite {\n  constructor(renderer) {\n    super();\n    this._renderer = renderer;\n    renderer.runners.resolutionChange.add(this);\n  }\n  resolutionChange() {\n    const text = this.renderable;\n    if (text._autoResolution) {\n      text.onViewUpdate();\n    }\n  }\n  destroy() {\n    this._renderer.canvasText.returnTexture(this.texture);\n    this._renderer = null;\n  }\n}\n\nexport { BatchableText };\n//# sourceMappingURL=BatchableText.mjs.map\n","import { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\n/** @internal */\nexport class BatchableText extends BatchableSprite\n{\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        super();\n\n        // Next step is to make canvasTextSystem a GLOBAL object.\n        // so this is ok for now..\n        this._renderer = renderer;\n\n        renderer.runners.resolutionChange.add(this);\n    }\n\n    public resolutionChange()\n    {\n        const text = this.renderable as Text;\n\n        if (text._autoResolution)\n        {\n            text.onViewUpdate();\n        }\n    }\n\n    public destroy()\n    {\n        this._renderer.canvasText.returnTexture(this.texture);\n\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport { deprecation } from '../../../utils/logging/deprecation.mjs';\nimport { TextStyle } from '../TextStyle.mjs';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource.mjs';\nimport { CanvasTextGenerator } from './CanvasTextGenerator.mjs';\n\n\"use strict\";\nclass CanvasTextSystem {\n  constructor(_renderer) {\n    this._renderer = _renderer;\n  }\n  getTexture(options, _resolution, _style, _textKey) {\n    if (typeof options === \"string\") {\n      deprecation(\"8.0.0\", \"CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments\");\n      options = {\n        text: options,\n        style: _style,\n        resolution: _resolution\n      };\n    }\n    if (!(options.style instanceof TextStyle)) {\n      options.style = new TextStyle(options.style);\n    }\n    if (!(options.textureStyle instanceof TextureStyle)) {\n      options.textureStyle = new TextureStyle(options.textureStyle);\n    }\n    if (typeof options.text !== \"string\") {\n      options.text = options.text.toString();\n    }\n    const { text, style, textureStyle } = options;\n    const resolution = options.resolution ?? this._renderer.resolution;\n    const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n      text,\n      style,\n      resolution\n    });\n    const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n    if (textureStyle)\n      texture.source.style = textureStyle;\n    if (style.trim) {\n      frame.pad(style.padding);\n      texture.frame.copyFrom(frame);\n      texture.updateUvs();\n    }\n    if (style.filters) {\n      const filteredTexture = this._applyFilters(texture, style.filters);\n      this.returnTexture(texture);\n      CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n      return filteredTexture;\n    }\n    this._renderer.texture.initSource(texture._source);\n    CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n    return texture;\n  }\n  /**\n   * Returns a texture that was created wit the above `getTexture` function.\n   * Handy if you are done with a texture and want to return it to the pool.\n   * @param texture - The texture to be returned.\n   */\n  returnTexture(texture) {\n    const source = texture.source;\n    source.resource = null;\n    source.uploadMethodId = \"unknown\";\n    source.alphaMode = \"no-premultiply-alpha\";\n    TexturePool.returnTexture(texture, true);\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   * @deprecated since 8.10.0\n   */\n  renderTextToCanvas() {\n    deprecation(\n      \"8.10.0\",\n      \"CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead\"\n    );\n  }\n  /**\n   * Applies the specified filters to the given texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n   * texture is set to 'premultiplied-alpha'.\n   * @param {Texture} texture - The texture to which the filters will be applied.\n   * @param {Filter[]} filters - The filters to apply to the texture.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   */\n  _applyFilters(texture, filters) {\n    const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n    const resultTexture = this._renderer.filter.generateFilteredTexture({\n      texture,\n      filters\n    });\n    this._renderer.renderTarget.bind(currentRenderTarget, false);\n    return resultTexture;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"canvasText\"\n};\n\nexport { CanvasTextSystem };\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { type Filter } from '../../../filters/Filter';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { type CanvasTextOptions } from '../Text';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextGenerator } from './CanvasTextGenerator';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @category rendering\n * @advanced\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    public getTexture(options: CanvasTextOptions): Texture;\n    public getTexture(\n        options: CanvasTextOptions | string,\n        _resolution?: number,\n        _style?: TextStyle,\n        _textKey?: string\n    ): Texture\n    {\n        if (typeof options === 'string')\n        {\n            // #if _DEBUG\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n            // #endif\n\n            options = {\n                text: options,\n                style: _style,\n                resolution: _resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        if (!(options.textureStyle instanceof TextureStyle))\n        {\n            options.textureStyle = new TextureStyle(options.textureStyle);\n        }\n\n        if (typeof options.text !== 'string')\n        {\n            options.text = options.text.toString();\n        }\n\n        const { text, style, textureStyle } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n            text: text as string,\n            style: style as TextStyle,\n            resolution,\n        });\n\n        const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n\n        if (textureStyle) texture.source.style = textureStyle as TextureStyle;\n\n        if (style.trim)\n        {\n            // reapply the padding to the frame\n            frame.pad(style.padding);\n            texture.frame.copyFrom(frame);\n            texture.updateUvs();\n        }\n\n        if (style.filters)\n        {\n            // apply the filters to the texture if required..\n            // this returns a new texture with the filters applied\n            const filteredTexture = this._applyFilters(texture, style.filters);\n\n            // return the original texture to the pool so we can reuse the next frame\n            this.returnTexture(texture);\n\n            CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n            // return the new texture with the filters applied\n            return filteredTexture;\n        }\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    /**\n     * Returns a texture that was created wit the above `getTexture` function.\n     * Handy if you are done with a texture and want to return it to the pool.\n     * @param texture - The texture to be returned.\n     */\n    public returnTexture(texture: Texture)\n    {\n        const source = texture.source;\n\n        source.resource = null;\n        source.uploadMethodId = 'unknown';\n        source.alphaMode = 'no-premultiply-alpha';\n\n        TexturePool.returnTexture(texture, true);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @deprecated since 8.10.0\n     */\n    public renderTextToCanvas(): void\n    {\n        // #if _DEBUG\n        deprecation(\n            '8.10.0',\n            'CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead'\n        );\n        // #endif\n    }\n\n    /**\n     * Applies the specified filters to the given texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n     * texture is set to 'premultiplied-alpha'.\n     * @param {Texture} texture - The texture to which the filters will be applied.\n     * @param {Filter[]} filters - The filters to apply to the texture.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     */\n    private _applyFilters(texture: Texture, filters: Filter[]): Texture\n    {\n        // Save the current render target so it can be restored later\n        const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n\n        // Apply the filters to the texture and get the resulting texture\n        const resultTexture = this._renderer.filter.generateFilteredTexture({\n            texture,\n            filters,\n        });\n\n        // Set the alpha mode of the resulting texture to 'premultiplied-alpha'\n\n        // Restore the previous render target\n        this._renderer.renderTarget.bind(currentRenderTarget, false);\n\n        // Return the resulting texture with the filters applied\n        return resultTexture;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = TexturePool.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = \"image\";\n  texture.source.resource = image;\n  texture.source.alphaMode = \"premultiply-alpha-on-upload\";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit(\"update\", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\nexport { getPo2TextureFromSource };\n//# sourceMappingURL=getPo2TextureFromSource.mjs.map\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n * @internal\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { BitmapTextPipe } from './BitmapTextPipe.mjs';\n\n\"use strict\";\nextensions.add(BitmapTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe);\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Graphics } from '../graphics/shared/Graphics.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { SdfShader } from '../text/sdfShader/SdfShader.mjs';\nimport { BitmapFontManager } from './BitmapFontManager.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\n\n\"use strict\";\nclass BitmapTextGraphics extends Graphics {\n  destroy() {\n    if (this.context.customShader) {\n      this.context.customShader.destroy();\n    }\n    super.destroy();\n  }\n}\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_gpuBitmapText\");\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== \"none\") {\n      if (!context.customShader) {\n        context.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);\n      }\n    }\n    const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n    let index = 0;\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    let tx = bitmapTextLayout.width;\n    let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n    if (style._stroke) {\n      tx += style._stroke.width / scale;\n      ty += style._stroke.width / scale;\n    }\n    context.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);\n    const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = chars[index++];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          context.texture(\n            charData.texture,\n            tint ? tint : \"black\",\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset)\n          );\n        }\n      }\n      currentY += bitmapFont.lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = new BitmapTextGraphics();\n    bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    return proxyRenderable;\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"bitmapText\"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\nexport { BitmapTextGraphics, BitmapTextPipe };\n//# sourceMappingURL=BitmapTextPipe.mjs.map\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { BitmapText } from './BitmapText';\n\n/** @internal */\nexport class BitmapTextGraphics extends Graphics\n{\n    public destroy()\n    {\n        if (this.context.customShader)\n        {\n            this.context.customShader.destroy();\n        }\n\n        super.destroy();\n    }\n}\n\n/** @internal */\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuBitmapText');\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                // TODO: Check if this is a WebGL renderer before asserting type\n                context.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);\n            }\n        }\n\n        const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = new BitmapTextGraphics();\n\n        bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        return proxyRenderable;\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit.mjs';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass SdfShader extends Shader {\n  constructor(maxTextures) {\n    const uniforms = new UniformGroup({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uDistance: { value: 4, type: \"f32\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(maxTextures),\n        localUniformMSDFBit,\n        mSDFBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(maxTextures),\n        localUniformMSDFBitGl,\n        mSDFBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n  }\n}\n\nexport { SdfShader };\n//# sourceMappingURL=SdfShader.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/** @internal */\nexport class SdfShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","\"use strict\";\nconst localUniformMSDFBit = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n    )\n  }\n};\n\nexport { localUniformMSDFBit, localUniformMSDFBitGl };\n//# sourceMappingURL=localUniformMSDFBit.mjs.map\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\n/** @internal */\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */`\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\n/** @internal */\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */`\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n","\"use strict\";\nconst mSDFBit = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `\n    )\n  }\n};\n\nexport { mSDFBit, mSDFBitGl };\n//# sourceMappingURL=mSDFBit.mjs.map\n","/** @internal */\nexport const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `,\n    }\n\n};\n\n/** @internal */\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `,\n    }\n\n};\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { HTMLTextPipe } from './HTMLTextPipe.mjs';\nimport { HTMLTextSystem } from './HTMLTextSystem.mjs';\n\n\"use strict\";\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateTextBounds } from '../text/utils/updateTextBounds.mjs';\nimport { BatchableHTMLText } from './BatchableHTMLText.mjs';\n\n\"use strict\";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  validateRenderable(htmlText) {\n    return htmlText._didTextUpdate;\n  }\n  addRenderable(htmlText, instructionSet) {\n    const batchableHTMLText = this._getGpuText(htmlText);\n    if (htmlText._didTextUpdate) {\n      this._updateGpuText(htmlText).catch((e) => {\n        console.error(e);\n      });\n      htmlText._didTextUpdate = false;\n      updateTextBounds(batchableHTMLText, htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n  }\n  updateRenderable(htmlText) {\n    const batchableHTMLText = this._getGpuText(htmlText);\n    batchableHTMLText._batcher.updateElement(batchableHTMLText);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const batchableHTMLText = this._getGpuText(htmlText);\n    if (batchableHTMLText.generatingTexture)\n      return;\n    if (batchableHTMLText.texturePromise) {\n      this._renderer.htmlText.returnTexturePromise(batchableHTMLText.texturePromise);\n      batchableHTMLText.texturePromise = null;\n    }\n    batchableHTMLText.generatingTexture = true;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    const texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n    batchableHTMLText.texturePromise = texturePromise;\n    batchableHTMLText.texture = await texturePromise;\n    const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    batchableHTMLText.generatingTexture = false;\n    updateTextBounds(batchableHTMLText, htmlText);\n  }\n  _getGpuText(htmlText) {\n    return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const batchableHTMLText = new BatchableHTMLText(this._renderer);\n    batchableHTMLText.renderable = htmlText;\n    batchableHTMLText.transform = htmlText.groupTransform;\n    batchableHTMLText.texture = Texture.EMPTY;\n    batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableHTMLText.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n    return batchableHTMLText;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"htmlText\"\n};\n\nexport { HTMLTextPipe };\n//# sourceMappingURL=HTMLTextPipe.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateTextBounds } from '../text/utils/updateTextBounds';\nimport { BatchableHTMLText } from './BatchableHTMLText';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The HTMLTextPipe class is responsible for rendering HTML text.\n * @internal\n */\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        return htmlText._didTextUpdate;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n\n            htmlText._didTextUpdate = false;\n\n            updateTextBounds(batchableHTMLText, htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        batchableHTMLText._batcher.updateElement(batchableHTMLText);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (batchableHTMLText.generatingTexture) return;\n\n        if (batchableHTMLText.texturePromise)\n        {\n            this._renderer.htmlText.returnTexturePromise(batchableHTMLText.texturePromise);\n            batchableHTMLText.texturePromise = null;\n        }\n\n        batchableHTMLText.generatingTexture = true;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n        const texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n\n        batchableHTMLText.texturePromise = texturePromise;\n\n        batchableHTMLText.texture = await texturePromise;\n\n        // need a rerender...\n        const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            // need a rebuild of the render group\n            renderGroup.structureDidChange = true;\n        }\n\n        batchableHTMLText.generatingTexture = false;\n\n        updateTextBounds(batchableHTMLText, htmlText);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const batchableHTMLText = new BatchableHTMLText(this._renderer);\n\n        batchableHTMLText.renderable = htmlText;\n        batchableHTMLText.transform = htmlText.groupTransform;\n        batchableHTMLText.texture = Texture.EMPTY;\n        batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableHTMLText.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n\n        return batchableHTMLText;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n\n","import { BatchableSprite } from '../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass BatchableHTMLText extends BatchableSprite {\n  /**\n   * Creates an instance of BatchableHTMLText.\n   * @param renderer - The renderer instance to be used.\n   */\n  constructor(renderer) {\n    super();\n    this.generatingTexture = false;\n    this._renderer = renderer;\n    renderer.runners.resolutionChange.add(this);\n  }\n  /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */\n  resolutionChange() {\n    const text = this.renderable;\n    if (text._autoResolution) {\n      text.onViewUpdate();\n    }\n  }\n  /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n  destroy() {\n    this._renderer.htmlText.returnTexturePromise(this.texturePromise);\n    this.texturePromise = null;\n    this._renderer = null;\n  }\n}\n\nexport { BatchableHTMLText };\n//# sourceMappingURL=BatchableHTMLText.mjs.map\n","import { type Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The BatchableHTMLText class extends the BatchableSprite class and is used to handle HTML text rendering.\n * It includes a promise for the texture as generating the HTML texture takes some time.\n * @internal\n */\nexport class BatchableHTMLText extends BatchableSprite\n{\n    private readonly _renderer: Renderer;\n    public texturePromise: Promise<Texture>;\n    public generatingTexture = false;\n\n    /**\n     * Creates an instance of BatchableHTMLText.\n     * @param renderer - The renderer instance to be used.\n     */\n    constructor(renderer: Renderer)\n    {\n        super();\n\n        // Next step is to make canvasTextSystem a GLOBAL object.\n        // so this is ok for now..\n        this._renderer = renderer;\n\n        renderer.runners.resolutionChange.add(this);\n    }\n\n    /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */\n    public resolutionChange()\n    {\n        const text = this.renderable as HTMLText;\n\n        if (text._autoResolution)\n        {\n            text.onViewUpdate();\n        }\n    }\n\n    /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n    public destroy()\n    {\n        this._renderer.htmlText.returnTexturePromise(this.texturePromise);\n\n        this.texturePromise = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { isSafari } from '../../utils/browser/isSafari.mjs';\nimport { warn } from '../../utils/logging/warn.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource.mjs';\nimport { HTMLTextRenderData } from './HTMLTextRenderData.mjs';\nimport { HTMLTextStyle } from './HTMLTextStyle.mjs';\nimport { extractFontFamilies } from './utils/extractFontFamilies.mjs';\nimport { getFontCss } from './utils/getFontCss.mjs';\nimport { getSVGUrl } from './utils/getSVGUrl.mjs';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage.mjs';\nimport { loadSVGImage } from './utils/loadSVGImage.mjs';\nimport { measureHtmlText } from './utils/measureHtmlText.mjs';\n\n\"use strict\";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === RendererType.WEBGPU;\n  }\n  /**\n   * @param options\n   * @deprecated Use getTexturePromise instead\n   */\n  getTexture(options) {\n    return this.getTexturePromise(options);\n  }\n  getTexturePromise(options) {\n    return this._buildTexturePromise(options);\n  }\n  async _buildTexturePromise(options) {\n    const { text, style, resolution, textureStyle } = options;\n    const htmlTextData = BigPool.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(\n      fontFamilies,\n      style,\n      HTMLTextStyle.defaultTextStyle\n    );\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    const uvSafeOffset = 2;\n    image.width = (width | 0) + uvSafeOffset;\n    image.height = (height | 0) + uvSafeOffset;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    const resource = image;\n    let canvasAndContext;\n    if (this._createCanvas) {\n      canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = getPo2TextureFromSource(\n      canvasAndContext ? canvasAndContext.canvas : resource,\n      image.width - uvSafeOffset,\n      image.height - uvSafeOffset,\n      resolution\n    );\n    if (textureStyle)\n      texture.source.style = textureStyle;\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n    }\n    BigPool.return(htmlTextData);\n    return texture;\n  }\n  returnTexturePromise(texturePromise) {\n    texturePromise.then((texture) => {\n      this._cleanUp(texture);\n    }).catch(() => {\n      warn(\"HTMLTextSystem: Failed to clean texture\");\n    });\n  }\n  _cleanUp(texture) {\n    TexturePool.returnTexture(texture, true);\n    texture.source.resource = null;\n    texture.source.uploadMethodId = \"unknown\";\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"htmlText\"\n};\n\nexport { HTMLTextSystem };\n//# sourceMappingURL=HTMLTextSystem.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { type CanvasAndContext, CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HTMLTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @category rendering\n * @advanced\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    /**\n     * @param options\n     * @deprecated Use getTexturePromise instead\n     */\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this.getTexturePromise(options);\n    }\n\n    public getTexturePromise(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(options);\n    }\n\n    private async _buildTexturePromise(options: HTMLTextOptions)\n    {\n        const { text, style, resolution, textureStyle } = options as {\n            text: string,\n            style: HTMLTextStyle,\n            resolution: number,\n            textureStyle?: TextureStyle,\n        };\n\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        // this off set will ensure we don't get any UV bleeding!\n        const uvSafeOffset = 2;\n\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        const resource: HTMLImageElement | HTMLCanvasElement = image;\n        let canvasAndContext: CanvasAndContext;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource,\n            image.width - uvSafeOffset,\n            image.height - uvSafeOffset,\n            resolution\n        );\n\n        if (textureStyle) texture.source.style = textureStyle;\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    public returnTexturePromise(texturePromise: Promise<Texture>)\n    {\n        texturePromise.then((texture) =>\n        {\n            this._cleanUp(texture);\n        }).catch(() =>\n        {\n            // #if _DEBUG\n            warn('HTMLTextSystem: Failed to clean texture');\n            // #endif\n        });\n    }\n\n    private _cleanUp(texture: Texture)\n    {\n        TexturePool.returnTexture(texture, true);\n        texture.source.resource = null;\n        texture.source.uploadMethodId = 'unknown';\n    }\n\n    public destroy()\n    {\n        // BOOM!\n        (this._renderer as null) = null;\n    }\n}\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nfunction isSafari() {\n  const { userAgent } = DOMAdapter.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\nexport { isSafari };\n//# sourceMappingURL=isSafari.mjs.map\n","import { DOMAdapter } from '../../environment/adapter';\n\n/**\n * Checks if the current browser is Safari.\n * @returns {boolean} True if the browser is Safari, false otherwise.\n * @internal\n */\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","\"use strict\";\nconst nssvg = \"http://www.w3.org/2000/svg\";\nconst nsxhtml = \"http://www.w3.org/1999/xhtml\";\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, \"svg\");\n    this.foreignObject = document.createElementNS(nssvg, \"foreignObject\");\n    this.domElement = document.createElementNS(nsxhtml, \"div\");\n    this.styleElement = document.createElementNS(nsxhtml, \"style\");\n    this.image = new Image();\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute(\"width\", \"10000\");\n    foreignObject.setAttribute(\"height\", \"10000\");\n    foreignObject.style.overflow = \"hidden\";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n  }\n}\n\nexport { HTMLTextRenderData };\n//# sourceMappingURL=HTMLTextRenderData.mjs.map\n","import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\n/** @internal */\nconst nssvg = 'http://www.w3.org/2000/svg';\n/** @internal */\nconst nsxhtml = 'http://www.w3.org/1999/xhtml';\n\n/** @internal */\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { TextStyle } from '../text/TextStyle.mjs';\nimport { textStyleToCSS } from './utils/textStyleToCSS.mjs';\n\n\"use strict\";\nclass HTMLTextStyle extends TextStyle {\n  constructor(options = {}) {\n    super(options);\n    this._cssOverrides = [];\n    this.cssOverrides = options.cssOverrides ?? [];\n    this.tagStyles = options.tagStyles ?? {};\n  }\n  /**\n   * List of CSS style overrides to apply to the HTML text.\n   * These styles are added after the built-in styles and can override any default styling.\n   * @advanced\n   */\n  set cssOverrides(value) {\n    this._cssOverrides = value instanceof Array ? value : [value];\n    this.update();\n  }\n  /** @advanced */\n  get cssOverrides() {\n    return this._cssOverrides;\n  }\n  /**\n   * Updates the text style and triggers a refresh of the CSS style cache.\n   * This method is called automatically when style properties are changed.\n   * @example\n   * ```ts\n   * // Update after multiple changes\n   * const text = new HTMLText({\n   *     text: 'Hello World',\n   *     style\n   * });\n   *\n   * style.fontSize = 32;\n   * style.fill = '#00ff00';\n   * style.fontFamily = 'Arial';\n   * style.update(); // Apply all changes at once\n   * ```\n   * @advanced\n   * @see {@link HTMLTextStyle#cssStyle} For accessing the generated CSS\n   * @see {@link HTMLTextStyle#cssOverrides} For managing CSS overrides\n   */\n  update() {\n    this._cssStyle = null;\n    super.update();\n  }\n  /**\n   * Creates a new HTMLTextStyle object with the same values as this one.\n   * This creates a deep copy of all style properties, including dropShadow and tag styles.\n   * @example\n   * ```ts\n   * // Create original style\n   * const originalStyle = new HTMLTextStyle({\n   *     fontSize: 24,\n   *     fill: '#ff0000',\n   *     tagStyles: {\n   *         header: { fontSize: 32, fill: '#00ff00' }\n   *     }\n   * });\n   *\n   * // Clone the style\n   * const clonedStyle = originalStyle.clone();\n   *\n   * // Modify cloned style independently\n   * clonedStyle.fontSize = 36;\n   * clonedStyle.fill = '#0000ff';\n   *\n   * // Original style remains unchanged\n   * console.log(originalStyle.fontSize); // Still 24\n   * console.log(originalStyle.fill); // Still '#ff0000'\n   * ```\n   *\n   * Properties that are cloned:\n   * - Basic text properties (fontSize, fontFamily, etc.)\n   * - Fill and stroke styles\n   * - Drop shadow configuration\n   * - CSS overrides\n   * - Tag styles (deep copied)\n   * - Word wrap settings\n   * - Alignment and spacing\n   * @returns {HTMLTextStyle} A new HTMLTextStyle instance with the same properties\n   * @see {@link HTMLTextStyle} For available style properties\n   * @see {@link HTMLTextStyle#cssOverrides} For CSS override handling\n   * @see {@link HTMLTextStyle#tagStyles} For tag style configuration\n   * @standard\n   */\n  clone() {\n    return new HTMLTextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow ? { ...this.dropShadow } : null,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth,\n      cssOverrides: this.cssOverrides,\n      tagStyles: { ...this.tagStyles }\n    });\n  }\n  /**\n   * The CSS style string that will be applied to the HTML text.\n   * @advanced\n   */\n  get cssStyle() {\n    if (!this._cssStyle) {\n      this._cssStyle = textStyleToCSS(this);\n    }\n    return this._cssStyle;\n  }\n  /**\n   * Add a style override, this can be any CSS property\n   * it will override any built-in style. This is the\n   * property and the value as a string (e.g., `color: red`).\n   * This will override any other internal style.\n   * @param {string} value - CSS style(s) to add.\n   * @example\n   * style.addOverride('background-color: red');\n   * @advanced\n   */\n  addOverride(...value) {\n    const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n    if (toAdd.length > 0) {\n      this.cssOverrides.push(...toAdd);\n      this.update();\n    }\n  }\n  /**\n   * Remove any overrides that match the value.\n   * @param {string} value - CSS style to remove.\n   * @example\n   * style.removeOverride('background-color: red');\n   * @advanced\n   */\n  removeOverride(...value) {\n    const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n    if (toRemove.length > 0) {\n      this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n      this.update();\n    }\n  }\n  /**\n   * Sets the fill style for the text. HTML text only supports color fills (string or number values).\n   * Texture fills are not supported and will trigger a warning in debug mode.\n   * @example\n   * ```ts\n   * // Using hex colors\n   * const text = new HTMLText({\n   *     text: 'Colored Text',\n   *     style: {\n   *         fill: 0xff0000 // Red color\n   *     }\n   * });\n   *\n   * // Using CSS color strings\n   * text.style.fill = '#00ff00';     // Hex string (Green)\n   * text.style.fill = 'blue';        // Named color\n   * text.style.fill = 'rgb(255,0,0)' // RGB\n   * text.style.fill = '#f0f';        // Short hex\n   *\n   * // Invalid usage (will trigger warning in debug)\n   * text.style.fill = {\n   *     type: 'pattern',\n   *     texture: Texture.from('pattern.png')\n   * }; // Not supported, falls back to default\n   * ```\n   * @param value - The fill color to use. Must be a string or number.\n   * @throws {Warning} In debug mode when attempting to use unsupported fill types\n   * @see {@link TextStyle#fill} For full fill options in canvas text\n   * @standard\n   */\n  set fill(value) {\n    if (typeof value !== \"string\" && typeof value !== \"number\") {\n      warn(\"[HTMLTextStyle] only color fill is not supported by HTMLText\");\n    }\n    super.fill = value;\n  }\n  /**\n   * Sets the stroke style for the text. HTML text only supports color strokes (string or number values).\n   * Texture strokes are not supported and will trigger a warning in debug mode.\n   * @example\n   * ```ts\n   * // Using hex colors\n   * const text = new HTMLText({\n   *     text: 'Outlined Text',\n   *     style: {\n   *         stroke: 0xff0000 // Red outline\n   *     }\n   * });\n   *\n   * // Using CSS color strings\n   * text.style.stroke = '#00ff00';     // Hex string (Green)\n   * text.style.stroke = 'blue';        // Named color\n   * text.style.stroke = 'rgb(255,0,0)' // RGB\n   * text.style.stroke = '#f0f';        // Short hex\n   *\n   * // Using stroke width\n   * text.style = {\n   *     stroke: {\n   *         color: '#ff0000',\n   *         width: 2\n   *     }\n   * };\n   *\n   * // Remove stroke\n   * text.style.stroke = null;\n   *\n   * // Invalid usage (will trigger warning in debug)\n   * text.style.stroke = {\n   *     type: 'pattern',\n   *     texture: Texture.from('pattern.png')\n   * }; // Not supported, falls back to default\n   * ```\n   * @param value - The stroke style to use. Must be a string, number, or stroke configuration object\n   * @throws {Warning} In debug mode when attempting to use unsupported stroke types\n   * @see {@link TextStyle#stroke} For full stroke options in canvas text\n   * @standard\n   */\n  set stroke(value) {\n    if (value && typeof value !== \"string\" && typeof value !== \"number\") {\n      warn(\"[HTMLTextStyle] only color stroke is not supported by HTMLText\");\n    }\n    super.stroke = value;\n  }\n}\n\nexport { HTMLTextStyle };\n//# sourceMappingURL=HTMLTextStyle.mjs.map\n","/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillInput, StrokeInput } from '../graphics/shared/FillTypes';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends standard text styling with HTML-specific capabilities.\n * Omits certain base text properties that don't apply to HTML rendering.\n * @example\n * ```ts\n * // Basic HTML text style\n * const text = new HTMLText({\n *     text: '<p>Hello World</p>',\n *     style: {\n *         fontSize: 24,\n *         fill: '#ff0000',\n *         fontFamily: 'Arial',\n *         align: 'center'\n *     }\n * });\n *\n * // Custom tag styling\n * const taggedText = new HTMLText({\n *     text: '<custom>Custom Tag</custom>',\n *     style: {\n *         fontSize: 16,\n *         tagStyles: {\n *             custom: {\n *                 fontSize: 32,\n *                 fill: '#00ff00',\n *                 fontStyle: 'italic'\n *             }\n *         }\n *     }\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' | 'filters'>\n{\n    /**\n     * List of CSS style overrides to apply to the HTML text.\n     * These styles are added after the built-in styles and can override any default styling.\n     * @advanced\n     */\n    cssOverrides?: string[];\n\n    /**\n     * Custom styles to apply to specific HTML tags.\n     * Allows for consistent styling of custom elements without CSS overrides.\n     * @example\n     * ```ts\n     * const text = new HTMLText({\n     *     text: `\n     *         <red>Main Title</red>\n     *         <grey>The subtitle</grey>\n     *         <blue>Regular content text</blue>\n     *     `,\n     *     style: {\n     *         tagStyles: {\n     *             red: {\n     *                 fill: '#ff0000',\n     *             },\n     *             grey: {\n     *                 fill: '#666666',\n     *             },\n     *             blue: {\n     *                 fill: 'blue',\n     *             }\n     *         }\n     *     }\n     * });\n     * ```\n     * @standard\n     */\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @category text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * Custom styles to apply to specific HTML tags.\n     * Allows for consistent styling of custom elements without CSS overrides.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     * @standard\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides = options.cssOverrides ?? [];\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /**\n     * List of CSS style overrides to apply to the HTML text.\n     * These styles are added after the built-in styles and can override any default styling.\n     * @advanced\n     */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    /** @advanced */\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    /**\n     * Updates the text style and triggers a refresh of the CSS style cache.\n     * This method is called automatically when style properties are changed.\n     * @example\n     * ```ts\n     * // Update after multiple changes\n     * const text = new HTMLText({\n     *     text: 'Hello World',\n     *     style\n     * });\n     *\n     * style.fontSize = 32;\n     * style.fill = '#00ff00';\n     * style.fontFamily = 'Arial';\n     * style.update(); // Apply all changes at once\n     * ```\n     * @advanced\n     * @see {@link HTMLTextStyle#cssStyle} For accessing the generated CSS\n     * @see {@link HTMLTextStyle#cssOverrides} For managing CSS overrides\n     */\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * This creates a deep copy of all style properties, including dropShadow and tag styles.\n     * @example\n     * ```ts\n     * // Create original style\n     * const originalStyle = new HTMLTextStyle({\n     *     fontSize: 24,\n     *     fill: '#ff0000',\n     *     tagStyles: {\n     *         header: { fontSize: 32, fill: '#00ff00' }\n     *     }\n     * });\n     *\n     * // Clone the style\n     * const clonedStyle = originalStyle.clone();\n     *\n     * // Modify cloned style independently\n     * clonedStyle.fontSize = 36;\n     * clonedStyle.fill = '#0000ff';\n     *\n     * // Original style remains unchanged\n     * console.log(originalStyle.fontSize); // Still 24\n     * console.log(originalStyle.fill); // Still '#ff0000'\n     * ```\n     *\n     * Properties that are cloned:\n     * - Basic text properties (fontSize, fontFamily, etc.)\n     * - Fill and stroke styles\n     * - Drop shadow configuration\n     * - CSS overrides\n     * - Tag styles (deep copied)\n     * - Word wrap settings\n     * - Alignment and spacing\n     * @returns {HTMLTextStyle} A new HTMLTextStyle instance with the same properties\n     * @see {@link HTMLTextStyle} For available style properties\n     * @see {@link HTMLTextStyle#cssOverrides} For CSS override handling\n     * @see {@link HTMLTextStyle#tagStyles} For tag style configuration\n     * @standard\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n            tagStyles: { ...this.tagStyles },\n        });\n    }\n\n    /**\n     * The CSS style string that will be applied to the HTML text.\n     * @advanced\n     */\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     * @advanced\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     * @advanced\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    /**\n     * Sets the fill style for the text. HTML text only supports color fills (string or number values).\n     * Texture fills are not supported and will trigger a warning in debug mode.\n     * @example\n     * ```ts\n     * // Using hex colors\n     * const text = new HTMLText({\n     *     text: 'Colored Text',\n     *     style: {\n     *         fill: 0xff0000 // Red color\n     *     }\n     * });\n     *\n     * // Using CSS color strings\n     * text.style.fill = '#00ff00';     // Hex string (Green)\n     * text.style.fill = 'blue';        // Named color\n     * text.style.fill = 'rgb(255,0,0)' // RGB\n     * text.style.fill = '#f0f';        // Short hex\n     *\n     * // Invalid usage (will trigger warning in debug)\n     * text.style.fill = {\n     *     type: 'pattern',\n     *     texture: Texture.from('pattern.png')\n     * }; // Not supported, falls back to default\n     * ```\n     * @param value - The fill color to use. Must be a string or number.\n     * @throws {Warning} In debug mode when attempting to use unsupported fill types\n     * @see {@link TextStyle#fill} For full fill options in canvas text\n     * @standard\n     */\n    override set fill(value: FillInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    /**\n     * Sets the stroke style for the text. HTML text only supports color strokes (string or number values).\n     * Texture strokes are not supported and will trigger a warning in debug mode.\n     * @example\n     * ```ts\n     * // Using hex colors\n     * const text = new HTMLText({\n     *     text: 'Outlined Text',\n     *     style: {\n     *         stroke: 0xff0000 // Red outline\n     *     }\n     * });\n     *\n     * // Using CSS color strings\n     * text.style.stroke = '#00ff00';     // Hex string (Green)\n     * text.style.stroke = 'blue';        // Named color\n     * text.style.stroke = 'rgb(255,0,0)' // RGB\n     * text.style.stroke = '#f0f';        // Short hex\n     *\n     * // Using stroke width\n     * text.style = {\n     *     stroke: {\n     *         color: '#ff0000',\n     *         width: 2\n     *     }\n     * };\n     *\n     * // Remove stroke\n     * text.style.stroke = null;\n     *\n     * // Invalid usage (will trigger warning in debug)\n     * text.style.stroke = {\n     *     type: 'pattern',\n     *     texture: Texture.from('pattern.png')\n     * }; // Not supported, falls back to default\n     * ```\n     * @param value - The stroke style to use. Must be a string, number, or stroke configuration object\n     * @throws {Warning} In debug mode when attempting to use unsupported stroke types\n     * @see {@link TextStyle#stroke} For full stroke options in canvas text\n     * @standard\n     */\n    override set stroke(value: StrokeInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n","import { Color } from '../../../color/Color.mjs';\n\n\"use strict\";\nfunction textStyleToCSS(style) {\n  const stroke = style._stroke;\n  const fill = style._fill;\n  const cssStyleString = [\n    `color: ${Color.shared.setValue(fill.color).toHex()}`,\n    `font-size: ${style.fontSize}px`,\n    `font-family: ${style.fontFamily}`,\n    `font-weight: ${style.fontWeight}`,\n    `font-style: ${style.fontStyle}`,\n    `font-variant: ${style.fontVariant}`,\n    `letter-spacing: ${style.letterSpacing}px`,\n    `text-align: ${style.align}`,\n    `padding: ${style.padding}px`,\n    `white-space: ${style.whiteSpace === \"pre\" && style.wordWrap ? \"pre-wrap\" : style.whiteSpace}`,\n    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n    ...style.wordWrap ? [\n      `word-wrap: ${style.breakWords ? \"break-all\" : \"break-word\"}`,\n      `max-width: ${style.wordWrapWidth}px`\n    ] : [],\n    ...stroke ? [strokeToCSS(stroke)] : [],\n    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n    ...style.cssOverrides\n  ].join(\";\");\n  const cssStyles = [`div { ${cssStyleString} }`];\n  tagStyleToCSS(style.tagStyles, cssStyles);\n  return cssStyles.join(\" \");\n}\nfunction dropShadowToCSS(dropShadowStyle) {\n  const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n  const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const position = `${x}px ${y}px`;\n  if (dropShadowStyle.blur > 0) {\n    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n  }\n  return `text-shadow: ${position} ${color}`;\n}\nfunction strokeToCSS(stroke) {\n  return [\n    `-webkit-text-stroke-width: ${stroke.width}px`,\n    `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n    `text-stroke-width: ${stroke.width}px`,\n    `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n    \"paint-order: stroke\"\n  ].join(\";\");\n}\nconst templates = {\n  fontSize: `font-size: {{VALUE}}px`,\n  fontFamily: `font-family: {{VALUE}}`,\n  fontWeight: `font-weight: {{VALUE}}`,\n  fontStyle: `font-style: {{VALUE}}`,\n  fontVariant: `font-variant: {{VALUE}}`,\n  letterSpacing: `letter-spacing: {{VALUE}}px`,\n  align: `text-align: {{VALUE}}`,\n  padding: `padding: {{VALUE}}px`,\n  whiteSpace: `white-space: {{VALUE}}`,\n  lineHeight: `line-height: {{VALUE}}px`,\n  wordWrapWidth: `max-width: {{VALUE}}px`\n};\nconst transform = {\n  fill: (value) => `color: ${Color.shared.setValue(value).toHex()}`,\n  breakWords: (value) => `word-wrap: ${value ? \"break-all\" : \"break-word\"}`,\n  stroke: strokeToCSS,\n  dropShadow: dropShadowToCSS\n};\nfunction tagStyleToCSS(tagStyles, out) {\n  for (const i in tagStyles) {\n    const tagStyle = tagStyles[i];\n    const cssTagStyle = [];\n    for (const j in tagStyle) {\n      if (transform[j]) {\n        cssTagStyle.push(transform[j](tagStyle[j]));\n      } else if (templates[j]) {\n        cssTagStyle.push(templates[j].replace(\"{{VALUE}}\", tagStyle[j]));\n      }\n    }\n    out.push(`${i} { ${cssTagStyle.join(\";\")} }`);\n  }\n}\n\nexport { textStyleToCSS };\n//# sourceMappingURL=textStyleToCSS.mjs.map\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HTMLTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n * @internal\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: ConvertedStrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n","\"use strict\";\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;\"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(\":\")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\nexport { extractFontFamilies };\n//# sourceMappingURL=extractFontFamilies.mjs.map\n","import type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n * @internal\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import { Cache } from '../../../assets/cache/Cache.mjs';\nimport { loadFontCSS } from './loadFontCSS.mjs';\n\n\"use strict\";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nasync function getFontCss(fontFamilies, style, defaultOptions) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily, i) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { url } = Cache.get(`${fontFamily}-and-url`);\n      if (i === 0) {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS({\n          fontWeight: style.fontWeight,\n          fontStyle: style.fontStyle,\n          fontFamily\n        }, url));\n      } else {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS({\n          fontWeight: defaultOptions.fontWeight,\n          fontStyle: defaultOptions.fontStyle,\n          fontFamily\n        }, url));\n      }\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join(\"\\n\");\n}\n\nexport { FontStylePromiseCache, getFontCss };\n//# sourceMappingURL=getFontCss.mjs.map\n","import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\n/** @internal */\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n * @internal\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(`${fontFamily}-and-url`);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: style.fontWeight,\n                        fontStyle: style.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64.mjs';\n\n\"use strict\";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64(url);\n  return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n\nexport { loadFontCSS };\n//# sourceMappingURL=loadFontCSS.mjs.map\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\n/**\n * Options for the font CSS style\n * @category text\n * @internal\n */\nexport interface FontCSSStyleOptions\n{\n    /**\n     * The font family to use in the CSS\n     * @example\n     * 'Arial' or ['Arial', 'Helvetica']\n     */\n    fontFamily: string | string[]\n    /**\n     * The font weight to use in the CSS\n     * @example\n     * 'normal', 'bold', '100', '200', etc.\n     */\n    fontWeight: string\n    /**\n     * The font style to use in the CSS\n     * @example\n     * 'normal', 'italic', 'oblique'\n     */\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n * @internal\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\n\n\"use strict\";\nasync function loadFontAsBase64(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\nexport { loadFontAsBase64 };\n//# sourceMappingURL=loadFontAsBase64.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n * @internal\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","\"use strict\";\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n  domElement.setAttribute(\"style\", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute(\"width\", width.toString());\n  svgRoot.setAttribute(\"height\", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\nexport { getSVGUrl };\n//# sourceMappingURL=getSVGUrl.mjs.map\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n * @internal\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\n\n\"use strict\";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  return canvasAndContext;\n}\n\nexport { getTemporaryCanvasFromImage };\n//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\nimport type { CanvasAndContext } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n * @internal\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): CanvasAndContext\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas.\n    return canvasAndContext;\n}\n\n","\"use strict\";\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = \"anonymous\";\n  });\n}\n\nexport { loadSVGImage };\n//# sourceMappingURL=loadSVGImage.mjs.map\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n * @internal\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { HTMLTextRenderData } from '../HTMLTextRenderData.mjs';\n\n\"use strict\";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData()));\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n  domElement.setAttribute(\"style\", \"transform-origin: top left; display: inline-block\");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const doublePadding = style.padding * 2;\n  return {\n    width: contentBounds.width - doublePadding,\n    height: contentBounds.height - doublePadding\n  };\n}\n\nexport { measureHtmlText };\n//# sourceMappingURL=measureHtmlText.mjs.map\n","import { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n * @internal\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData ||= tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    // padding is included in the CSS calculation, so we need to remove it here\n    const doublePadding = style.padding * 2;\n\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height - doublePadding,\n    };\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { TilingSpritePipe } from './TilingSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { State } from '../../rendering/renderers/shared/state/State.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader.mjs';\nimport { QuadGeometry } from './utils/QuadGeometry.mjs';\nimport { setPositions } from './utils/setPositions.mjs';\nimport { setUvs } from './utils/setUvs.mjs';\n\n\"use strict\";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpriteGpuData {\n  constructor() {\n    this.canBatch = true;\n    this.geometry = new MeshGeometry({\n      indices: sharedQuad.indices.slice(),\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n  }\n  destroy() {\n    this.geometry.destroy();\n    this.shader?.destroy();\n  }\n}\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._state = State.default2d;\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        renderable.texture\n      );\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite.didViewUpdate) {\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.renderable = tilingSprite;\n        batchableMesh.transform = tilingSprite.groupTransform;\n        batchableMesh.setTexture(tilingSprite._texture);\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._getTilingSpriteData(tilingSprite);\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    color32BitToUniform(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: this._state\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite.didViewUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh._batcher.updateElement(batchableMesh);\n    } else if (tilingSprite.didViewUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n  }\n  _getTilingSpriteData(renderable) {\n    return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const gpuData = new TilingSpriteGpuData();\n    gpuData.renderable = tilingSprite;\n    tilingSprite._gpuData[this._renderer.uid] = gpuData;\n    return gpuData;\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== \"repeat\") {\n      style.addressMode = \"repeat\";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === RendererType.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"tilingSprite\"\n};\n\nexport { TilingSpriteGpuData, TilingSpritePipe };\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\nconst sharedQuad = new QuadGeometry();\n\n/** @internal */\nexport class TilingSpriteGpuData\n{\n    public canBatch: boolean = true;\n    public renderable: TilingSprite;\n    public batchableMesh?: BatchableMesh;\n    public geometry?: MeshGeometry;\n    public shader?: TilingSpriteShader;\n\n    constructor()\n    {\n        this.geometry = new MeshGeometry({\n            indices: sharedQuad.indices.slice(),\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n        this.shader?.destroy();\n    }\n}\n\n/**\n * The TilingSpritePipe is a render pipe for rendering TilingSprites.\n * It handles the batching and rendering of TilingSprites using a shader.\n * @internal\n */\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                renderable.texture\n            );\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite.didViewUpdate)\n            {\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.setTexture(tilingSprite._texture);\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._getTilingSpriteData(tilingSprite);\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh._batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite.didViewUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): TilingSpriteGpuData\n    {\n        return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): TilingSpriteGpuData\n    {\n        const gpuData = new TilingSpriteGpuData();\n\n        gpuData.renderable = tilingSprite;\n        tilingSprite._gpuData[this._renderer.uid] = gpuData;\n\n        return gpuData;\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _MeshGeometry = class _MeshGeometry extends Geometry {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      deprecation(v8_0_0, \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    let uvs = options.uvs;\n    if (!uvs) {\n      if (options.positions) {\n        uvs = new Float32Array(positions.length);\n      } else {\n        uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n      }\n    }\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new Buffer({\n      data: positions,\n      label: \"attribute-mesh-positions\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const uvBuffer = new Buffer({\n      data: uvs,\n      label: \"attribute-mesh-uvs\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const indexBuffer = new Buffer({\n      data: indices,\n      label: \"index-mesh-buffer\",\n      shrinkToFit,\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = \"auto\";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  /**\n   * Set the positions of the mesh.\n   * When setting the positions, its important that the uvs array is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The positions of the mesh.\n   */\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  /**\n   * Set the UVs of the mesh.\n   * Its important that the uvs array you set is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The UVs of the mesh.\n   */\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: \"triangle-list\",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\nexport { MeshGeometry };\n//# sourceMappingURL=MeshGeometry.mjs.map\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @category scene\n * @advanced\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. If not provided, they will be filled with 0 and match the size of the positions. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @category scene\n * @advanced\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n\n        let uvs = options.uvs;\n\n        if (!uvs)\n        {\n            if (options.positions)\n            {\n                uvs = new Float32Array(positions.length);\n            }\n            else\n            {\n                uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n            }\n        }\n\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the positions of the mesh.\n     * When setting the positions, its important that the uvs array is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The positions of the mesh.\n     */\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the UVs of the mesh.\n     * Its important that the uvs array you set is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The UVs of the mesh.\n     */\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { tilingBit, tilingBitGl } from './tilingBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader {\n  constructor() {\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBit,\n        tilingBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBitGl,\n        tilingBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    const tilingUniforms = new UniformGroup({\n      uMapCoord: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: \"vec4<f32>\" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: \"vec2<f32>\" },\n      uTextureTransform: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: \"vec4<f32>\" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup({\n          uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n          uRound: { value: 0, type: \"f32\" }\n        }),\n        tilingUniforms,\n        uTexture: Texture.EMPTY.source,\n        uSampler: Texture.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\nexport { TilingSpriteShader };\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/**\n * The shader used by the TilingSprite.\n * @internal\n */\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","\"use strict\";\nconst tilingBit = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    )\n  }\n};\n\nexport { tilingBit, tilingBitGl };\n//# sourceMappingURL=tilingBit.mjs.map\n","/** @internal */\nexport const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\n/** @internal */\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    }\n\n};\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nclass QuadGeometry extends MeshGeometry {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\nexport { QuadGeometry };\n//# sourceMappingURL=QuadGeometry.mjs.map\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\n/** @internal */\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","\"use strict\";\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\nexport { setPositions };\n//# sourceMappingURL=setPositions.mjs.map\n","import type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param positions\n * @internal\n */\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { applyMatrix } from './applyMatrix.mjs';\n\n\"use strict\";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite.applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\nexport { setUvs };\n//# sourceMappingURL=setUvs.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param uvs\n * @internal\n */\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite.applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","\"use strict\";\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\nexport { applyMatrix };\n//# sourceMappingURL=applyMatrix.mjs.map\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\n/**\n * @param array\n * @param stride\n * @param offset\n * @param matrix\n * @internal\n */\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { NineSliceGeometry } from './NineSliceGeometry.mjs';\n\n\"use strict\";\nclass NineSliceSpriteGpuData extends BatchableMesh {\n  constructor() {\n    super();\n    this.geometry = new NineSliceGeometry();\n  }\n  destroy() {\n    this.geometry.destroy();\n  }\n}\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.setTexture(sprite._texture);\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n    const batchableMesh = gpuData;\n    batchableMesh.renderable = sprite;\n    batchableMesh.transform = sprite.groupTransform;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    if (!sprite.didViewUpdate) {\n      this._updateBatchableSprite(sprite, batchableMesh);\n    }\n    return gpuData;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"nineSliceSprite\"\n};\n\nexport { NineSliceSpriteGpuData, NineSliceSpritePipe };\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\n/**\n * GPU data for NineSliceSprite.\n * @internal\n */\nexport class NineSliceSpriteGpuData extends BatchableMesh\n{\n    constructor()\n    {\n        super();\n        this.geometry = new NineSliceGeometry();\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n    }\n}\n\n/**\n * The NineSliceSpritePipe is a render pipe for rendering NineSliceSprites.\n * @internal\n */\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture\n        );\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.setTexture(sprite._texture);\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n\n        const batchableMesh = gpuData;\n\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        // if the sprite has not been updated by the view, we need to update the batchable mesh now.\n        if (!sprite.didViewUpdate)\n        {\n            this._updateBatchableSprite(sprite, batchableMesh);\n        }\n\n        return gpuData;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry.mjs';\n\n\"use strict\";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    this._anchorX = options.anchor?.x;\n    this._anchorY = options.anchor?.y;\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const p = this.positions;\n    const {\n      width,\n      height,\n      _leftWidth,\n      _rightWidth,\n      _topHeight,\n      _bottomHeight,\n      _anchorX,\n      _anchorY\n    } = this;\n    const w = _leftWidth + _rightWidth;\n    const scaleW = width > w ? 1 : width / w;\n    const h = _topHeight + _bottomHeight;\n    const scaleH = height > h ? 1 : height / h;\n    const scale = Math.min(scaleW, scaleH);\n    const anchorOffsetX = _anchorX * width;\n    const anchorOffsetY = _anchorY * height;\n    p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n    p[2] = p[10] = p[18] = p[26] = _leftWidth * scale - anchorOffsetX;\n    p[4] = p[12] = p[20] = p[28] = width - _rightWidth * scale - anchorOffsetX;\n    p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n    p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n    p[9] = p[11] = p[13] = p[15] = _topHeight * scale - anchorOffsetY;\n    p[17] = p[19] = p[21] = p[23] = height - _bottomHeight * scale - anchorOffsetY;\n    p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n    this.getBuffer(\"aPosition\").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.getBuffer(\"aUV\").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\n\nexport { NineSliceGeometry };\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n","import { type PointData } from '../../maths/point/PointData';\nimport { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @category scene\n * @advanced\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n\n    /** The anchor point of the NineSliceSprite. */\n    anchor?: PointData\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @category scene\n * @advanced\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    /** @internal */\n    public _leftWidth: number;\n    /** @internal */\n    public _rightWidth: number;\n    /** @internal */\n    public _topHeight: number;\n    /** @internal */\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n    private _anchorX: any;\n    private _anchorY: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this._anchorX = options.anchor?.x;\n        this._anchorY = options.anchor?.y;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const p = this.positions;\n        const {\n            width,\n            height,\n            _leftWidth,\n            _rightWidth,\n            _topHeight,\n            _bottomHeight,\n            _anchorX,\n            _anchorY,\n        } = this;\n\n        const w = _leftWidth + _rightWidth;\n        const scaleW = width > w ? 1.0 : width / w;\n\n        const h = _topHeight + _bottomHeight;\n        const scaleH = height > h ? 1.0 : height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        const anchorOffsetX = _anchorX * width;\n        const anchorOffsetY = _anchorY * height;\n\n        p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n        p[2] = p[10] = p[18] = p[26] = (_leftWidth * scale) - anchorOffsetX;\n        p[4] = p[12] = p[20] = p[28] = width - (_rightWidth * scale) - anchorOffsetX;\n        p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n\n        p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n        p[9] = p[11] = p[13] = p[15] = (_topHeight * scale) - anchorOffsetY;\n        p[17] = p[19] = p[21] = p[23] = height - (_bottomHeight * scale) - anchorOffsetY;\n        p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(v8_0_0, \"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead\");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\nexport { PlaneGeometry };\n//# sourceMappingURL=PlaneGeometry.mjs.map\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link PlaneGeometry}\n * @category scene\n * @advanced\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @category scene\n * @advanced\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { FilterPipe } from './FilterPipe.mjs';\nimport { FilterSystem } from './FilterSystem.mjs';\n\n\"use strict\";\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      canBundle: false,\n      action: \"pushFilter\",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === \"pushFilter\") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === \"popFilter\") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"filter\"\n};\n\nexport { FilterPipe };\n//# sourceMappingURL=FilterPipe.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n/** @internal */\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterData {\n  constructor() {\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    this.skip = false;\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    this.inputTexture = null;\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    this.backTexture = null;\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    this.filters = null;\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    this.bounds = new Bounds();\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    this.container = null;\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    this.blendRequired = false;\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    this.outputRenderSurface = null;\n    /**\n     * The offset of the output render surface.\n     * @type {PointData}\n     */\n    this.outputOffset = { x: 0, y: 0 };\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n  }\n}\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputPixel: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputClamp: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uGlobalFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputTexture: { value: new Float32Array(4), type: \"vec4<f32>\" }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  /**\n   * Pushes a filter instruction onto the filter stack.\n   * @param instruction - The instruction containing the filter effect and container.\n   * @internal\n   */\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    const filterData = this._pushFilterData();\n    filterData.skip = false;\n    filterData.filters = filters;\n    filterData.container = instruction.container;\n    filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      instruction.container.getFastGlobalBounds(true, bounds);\n    }\n    if (instruction.container) {\n      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n      const filterFrameTransform = renderGroup.cacheToLocalTransform;\n      if (filterFrameTransform) {\n        bounds.applyMatrix(filterFrameTransform);\n      }\n    }\n    this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n    if (filterData.skip) {\n      return;\n    }\n    const previousFilterData = this._getPreviousFilterData();\n    let globalResolution = rootResolution;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (previousFilterData) {\n      offsetX = previousFilterData.bounds.minX;\n      offsetY = previousFilterData.bounds.minY;\n      globalResolution = previousFilterData.inputTexture.source._resolution;\n    }\n    filterData.outputOffset.x = bounds.minX - offsetX;\n    filterData.outputOffset.y = bounds.minY - offsetY;\n    const globalFrame = filterData.globalFrame;\n    globalFrame.x = offsetX * globalResolution;\n    globalFrame.y = offsetY * globalResolution;\n    globalFrame.width = colorTextureSource.width * globalResolution;\n    globalFrame.height = colorTextureSource.height * globalResolution;\n    filterData.backTexture = Texture.EMPTY;\n    if (filterData.blendRequired) {\n      renderer.renderTarget.finishRenderPass();\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n      filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n    }\n    filterData.inputTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  /**\n   * Applies filters to a texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture.\n   * @param {object} params - The parameters for applying filters.\n   * @param {Texture} params.texture - The texture to apply filters to.\n   * @param {Filter[]} params.filters - The filters to apply.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   * @example\n   *\n   * ```ts\n   * // Create a texture and a list of filters\n   * const texture = new Texture(...);\n   * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n   *\n   * // Apply the filters to the texture\n   * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n   *\n   * // Use the resulting texture\n   * sprite.texture = resultTexture;\n   * ```\n   *\n   * Key Points:\n   * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n   * 2. If all filters are disabled or skipped, the original texture is returned.\n   */\n  generateFilteredTexture({ texture, filters }) {\n    const filterData = this._pushFilterData();\n    this._activeFilterData = filterData;\n    filterData.skip = false;\n    filterData.filters = filters;\n    const colorTextureSource = texture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return texture;\n    }\n    const bounds = filterData.bounds;\n    bounds.addRect(texture.frame);\n    this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n    if (filterData.skip) {\n      return texture;\n    }\n    const globalResolution = rootResolution;\n    const offsetX = 0;\n    const offsetY = 0;\n    filterData.outputOffset.x = -bounds.minX;\n    filterData.outputOffset.y = -bounds.minY;\n    const globalFrame = filterData.globalFrame;\n    globalFrame.x = offsetX * globalResolution;\n    globalFrame.y = offsetY * globalResolution;\n    globalFrame.width = colorTextureSource.width * globalResolution;\n    globalFrame.height = colorTextureSource.height * globalResolution;\n    filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    filterData.backTexture = Texture.EMPTY;\n    filterData.inputTexture = texture;\n    const renderer = this.renderer;\n    renderer.renderTarget.finishRenderPass();\n    this._applyFiltersToTexture(filterData, true);\n    const outputTexture = filterData.outputRenderSurface;\n    outputTexture.source.alphaMode = \"premultiplied-alpha\";\n    return outputTexture;\n  }\n  /** @internal */\n  pop() {\n    const renderer = this.renderer;\n    const filterData = this._popFilterData();\n    if (filterData.skip) {\n      return;\n    }\n    renderer.globalUniforms.pop();\n    renderer.renderTarget.finishRenderPass();\n    this._activeFilterData = filterData;\n    this._applyFiltersToTexture(filterData, false);\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(filterData.backTexture);\n    }\n    TexturePool.returnTexture(filterData.inputTexture);\n  }\n  /**\n   * Copies the last render surface to a texture.\n   * @param lastRenderSurface - The last render surface to copy from.\n   * @param bounds - The bounds of the area to copy.\n   * @param previousBounds - The previous bounds to use for offsetting the copy.\n   */\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  /**\n   * Applies a filter to a texture.\n   * @param filter - The filter to apply.\n   * @param input - The input texture.\n   * @param output - The output render surface.\n   * @param clear - Whether to clear the output surface before applying the filter.\n   */\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._activeFilterData;\n    const outputRenderSurface = filterData.outputRenderSurface;\n    const filterUniforms = this._filterGlobalUniforms;\n    const uniforms = filterUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (outputRenderSurface === output) {\n      outputFrame[0] = filterData.outputOffset.x;\n      outputFrame[1] = filterData.outputOffset.y;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    globalFrame[0] = filterData.globalFrame.x;\n    globalFrame[1] = filterData.globalFrame.y;\n    globalFrame[2] = filterData.globalFrame.width;\n    globalFrame[3] = filterData.globalFrame.height;\n    if (output instanceof Texture)\n      output.source.resource = null;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    filterUniforms.update();\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(filterUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n    if (renderGroup && renderGroup.cacheToLocalTransform) {\n      worldTransform.prepend(renderGroup.cacheToLocalTransform);\n    }\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.frame.width,\n      1 / sprite.texture.frame.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n  destroy() {\n  }\n  _applyFiltersToTexture(filterData, clear) {\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n    } else {\n      let flip = filterData.inputTexture;\n      const tempTexture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let flop = tempTexture;\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.outputRenderSurface, clear);\n      TexturePool.returnTexture(tempTexture);\n    }\n  }\n  _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {\n    const renderer = this.renderer;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    let resolution = Infinity;\n    let padding = 0;\n    let antialias = true;\n    let blendRequired = false;\n    let enabled = false;\n    let clipToViewport = true;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution === \"inherit\" ? rootResolution : filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias === \"off\") {\n        antialias = false;\n      } else if (filter.antialias === \"inherit\") {\n        antialias && (antialias = rootAntialias);\n      }\n      if (!filter.clipToViewport) {\n        clipToViewport = false;\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired || (blendRequired = filter.blendRequired);\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    if (clipToViewport) {\n      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n    }\n    bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.antialias = antialias;\n    filterData.resolution = resolution;\n    filterData.blendRequired = blendRequired;\n  }\n  _popFilterData() {\n    this._filterStackIndex--;\n    return this._filterStack[this._filterStackIndex];\n  }\n  _getPreviousFilterData() {\n    let previousFilterData;\n    let index = this._filterStackIndex - 1;\n    while (index > 1) {\n      index--;\n      previousFilterData = this._filterStack[index];\n      if (!previousFilterData.skip) {\n        break;\n      }\n    }\n    return previousFilterData;\n  }\n  _pushFilterData() {\n    let filterData = this._filterStack[this._filterStackIndex];\n    if (!filterData) {\n      filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n    }\n    this._filterStackIndex++;\n    return filterData;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"filter\"\n};\n\nexport { FilterSystem };\n//# sourceMappingURL=FilterSystem.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { type PointData } from '../maths/point/PointData';\nimport { type Rectangle } from '../maths/shapes/Rectangle';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n * @internal\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: 'pushFilter' | 'popFilter',\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\n/**\n * Class representing the data required for applying filters.\n * This class holds various properties that are used during the filter application process.\n * @internal\n */\nclass FilterData\n{\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    public skip = false;\n\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    public inputTexture: Texture = null;\n\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    public backTexture?: Texture = null;\n\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    public filters: Filter[] = null;\n\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    public bounds = new Bounds();\n\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    public container: Container = null;\n\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    public blendRequired: boolean = false;\n\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    public outputRenderSurface: RenderSurface = null;\n\n    /**\n     * The offset of the output render surface.\n     * @type {PointData}\n     */\n    public outputOffset: PointData = { x: 0, y: 0 };\n\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    public globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n\n    /**\n     * Indicates whether antialiasing is enabled for the filter.\n     * @type {boolean}\n     */\n    public antialias: boolean;\n\n    /**\n     * The resolution of the filter.\n     * @type {number}\n     */\n    public resolution: number;\n}\n\n/**\n * System that manages the filter pipeline\n * @category rendering\n * @advanced\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    /**\n     * Pushes a filter instruction onto the filter stack.\n     * @param instruction - The instruction containing the filter effect and container.\n     * @internal\n     */\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        filterData.skip = false;\n\n        filterData.filters = filters as Filter[];\n        filterData.container = instruction.container;\n        filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            // we want to factor render layers to get the real visual bounds of this container.\n            // so the last param is true..\n            instruction.container.getFastGlobalBounds(true, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n\n        this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        const previousFilterData = this._getPreviousFilterData();\n\n        let globalResolution = rootResolution;\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (previousFilterData)\n        {\n            offsetX = previousFilterData.bounds.minX;\n            offsetY = previousFilterData.bounds.minY;\n            globalResolution = previousFilterData.inputTexture.source._resolution;\n        }\n\n        filterData.outputOffset.x = bounds.minX - offsetX;\n        filterData.outputOffset.y = bounds.minY - offsetY;\n\n        const globalFrame = filterData.globalFrame;\n\n        globalFrame.x = offsetX * globalResolution;\n        globalFrame.y = offsetY * globalResolution;\n        globalFrame.width = colorTextureSource.width * globalResolution;\n        globalFrame.height = colorTextureSource.height * globalResolution;\n\n        // set all the filter data\n\n        filterData.backTexture = Texture.EMPTY;\n\n        if (filterData.blendRequired)\n        {\n            renderer.renderTarget.finishRenderPass();\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n\n            filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n        }\n\n        /// ///\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    /**\n     * Applies filters to a texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture.\n     * @param {object} params - The parameters for applying filters.\n     * @param {Texture} params.texture - The texture to apply filters to.\n     * @param {Filter[]} params.filters - The filters to apply.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     * @example\n     *\n     * ```ts\n     * // Create a texture and a list of filters\n     * const texture = new Texture(...);\n     * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n     *\n     * // Apply the filters to the texture\n     * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n     *\n     * // Use the resulting texture\n     * sprite.texture = resultTexture;\n     * ```\n     *\n     * Key Points:\n     * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n     * 2. If all filters are disabled or skipped, the original texture is returned.\n     */\n    public generateFilteredTexture({ texture, filters }: {texture: Texture, filters: Filter[]}): Texture\n    {\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        this._activeFilterData = filterData;\n        filterData.skip = false;\n\n        filterData.filters = filters;\n\n        const colorTextureSource = texture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return texture;\n        }\n\n        const bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n\n        bounds.addRect(texture.frame);\n\n        this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n\n        if (filterData.skip)\n        {\n            return texture;\n        }\n\n        const globalResolution = rootResolution;\n        const offsetX = 0;\n        const offsetY = 0;\n\n        filterData.outputOffset.x = -bounds.minX;\n        filterData.outputOffset.y = -bounds.minY;\n\n        const globalFrame = filterData.globalFrame;\n\n        globalFrame.x = offsetX * globalResolution;\n        globalFrame.y = offsetY * globalResolution;\n        globalFrame.width = colorTextureSource.width * globalResolution;\n        globalFrame.height = colorTextureSource.height * globalResolution;\n\n        /// /////////\n\n        // set all the filter data\n        // get a P02 texture from our pool...\n        filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // TODO this might need looking at for padding!\n        filterData.inputTexture = texture;\n\n        /// ////////////// PART 2 POP //////////////////////\n\n        const renderer = this.renderer;\n\n        // TODO required? check with AA\n        renderer.renderTarget.finishRenderPass();\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        this._applyFiltersToTexture(filterData, true);\n\n        const outputTexture = filterData.outputRenderSurface as Texture;\n\n        outputTexture.source.alphaMode = 'premultiplied-alpha';\n\n        return outputTexture;\n    }\n\n    /** @internal */\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._popFilterData();\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        renderer.globalUniforms.pop();\n\n        renderer.renderTarget.finishRenderPass();\n\n        this._activeFilterData = filterData;\n\n        this._applyFiltersToTexture(filterData, false);\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(filterData.backTexture);\n        }\n\n        // return the texture to the pool so we can reuse the next frame\n        TexturePool.returnTexture(filterData.inputTexture);\n    }\n\n    /**\n     * Copies the last render surface to a texture.\n     * @param lastRenderSurface - The last render surface to copy from.\n     * @param bounds - The bounds of the area to copy.\n     * @param previousBounds - The previous bounds to use for offsetting the copy.\n     */\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    /**\n     * Applies a filter to a texture.\n     * @param filter - The filter to apply.\n     * @param input - The input texture.\n     * @param output - The output render surface.\n     * @param clear - Whether to clear the output surface before applying the filter.\n     */\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._activeFilterData;\n\n        const outputRenderSurface = filterData.outputRenderSurface;\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (outputRenderSurface === output)\n        {\n            outputFrame[0] = filterData.outputOffset.x;\n            outputFrame[1] = filterData.outputOffset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        globalFrame[0] = filterData.globalFrame.x;\n        globalFrame[1] = filterData.globalFrame.y;\n\n        globalFrame[2] = filterData.globalFrame.width;\n        globalFrame[3] = filterData.globalFrame.height;\n\n        // we are going to overwrite resource we can set it to null!\n        if (output instanceof Texture) output.source.resource = null;\n\n        // set the output texture - this is where we are going to render to\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy(): void\n    {\n        // BOOM!\n    }\n\n    private _applyFiltersToTexture(filterData: FilterData, clear: boolean)\n    {\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        const filters = filterData.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            filters[0].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            const tempTexture = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            // get another texture that we will render the next filter too\n            let flop = tempTexture;\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.outputRenderSurface, clear);\n\n            // return those textures for later!\n            TexturePool.returnTexture(tempTexture);\n        }\n    }\n\n    private _calculateFilterBounds(\n        filterData: FilterData,\n        viewPort: Rectangle,\n        rootAntialias: boolean,\n        rootResolution: number,\n        // a multiplier padding for the bounds calculation\n        // this prop is used when applying filters to textures\n        // as the should have padding applied to them already (until we fix padding when applying them to textures)\n        // set to 0 to remove padding from the bounds calculation\n        paddingMultiplier: number\n    )\n    {\n        const renderer = this.renderer;\n\n        const bounds = filterData.bounds;\n        const filters = filterData.filters;\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? rootResolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= rootAntialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad((padding | 0) * paddingMultiplier);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set the global frame to the root texture\n\n        // get previous bounds.. we must take into account skipped filters also..\n\n        // // to find the previous resolution we need to account for the skipped filters\n        // // the following will find the last non skipped filter...\n\n        // store the values that will be used to apply the filters\n        filterData.antialias = antialias;\n        filterData.resolution = resolution;\n        filterData.blendRequired = blendRequired;\n    }\n\n    private _popFilterData(): FilterData\n    {\n        this._filterStackIndex--;\n\n        return this._filterStack[this._filterStackIndex];\n    }\n\n    private _getPreviousFilterData(): FilterData | null\n    {\n        let previousFilterData: FilterData;\n\n        let index = this._filterStackIndex - 1;\n\n        while (index > 1)\n        {\n            index--;\n            previousFilterData = this._filterStack[index];\n\n            if (!previousFilterData.skip)\n            {\n                break;\n            }\n        }\n\n        return previousFilterData;\n    }\n\n    private _pushFilterData(): FilterData\n    {\n        let filterData = this._filterStack[this._filterStackIndex];\n\n        if (!filterData)\n        {\n            filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n        }\n\n        this._filterStackIndex++;\n\n        return filterData;\n    }\n}\n\n","\"use strict\";\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const tempMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    bounds.matrix = renderable.worldTransform;\n    bounds.addBounds(renderable.bounds);\n  }\n  bounds.matrix = tempMatrix;\n  return bounds;\n}\n\nexport { getGlobalRenderableBounds };\n//# sourceMappingURL=getRenderableBounds.mjs.map\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\n/**\n * @param renderables\n * @param bounds\n * @internal\n */\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        bounds.addBounds(renderable.bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$arnWa","$83OKg","$i3qqe","extensions","add","ResizePlugin","TickerPlugin","$422035d31f142a1f$export$6453cd852defe94a","init","options","dom","removeEventListener","queueResize","_resizeTo","addEventListener","resize","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","width","height","window","innerWidth","innerHeight","clientWidth","clientHeight","renderer","render","resizeTo","destroy","extension","ExtensionType","Application","$59a629c0f9e6fd05$export$50c361ceb4e2f4f0","$kfZeU","$7LZE9","assign","autoStart","sharedTicker","ticker","_ticker","remove","UPDATE_PRIORITY","LOW","stop","start","Ticker","shared","oldTicker","$dGhKH","$gC2ie","GraphicsPipe","GraphicsContextSystem","$4191ff7429a79856$export$56171ef5563dc803","$19C14","$ehSI3","$6WOBV","$cAXew","$4191ff7429a79856$export$2a885cf99f131046","batches","batched","forEach","batch","BigPool","return","length","adaptor","state","State","for2d","_adaptor","runners","contextChange","validateRenderable","graphics","context","wasBatched","_gpuData","gpuContext","graphicsContext","updateGpuContext","isBatchable","addRenderable","instructionSet","didViewUpdate","_rebuild","_addToBatcher","renderPipes","break","updateRenderable","gpuData","_getGpuDataForRenderable","i","_batcher","updateElement","execute","isRenderable","contextSystem","getGpuContext","shader","customShader","blendMode","groupBlendMode","localUniforms","resources","uniforms","uTransformMatrix","groupTransform","uRound","_roundPixels","color32BitToUniform","groupColorAlpha","uColor","_updateBatchesForRenderable","batchPipe","addToBatch","uid","_initGpuDataForRenderable","roundPixels","map","batchClone","BatchableGraphics","copyTo","renderable","type","WebGLPipes","WebGPUPipes","CanvasPipes","name","$2zCV3","MeshPipe","$1ee4419f36fc2e55$export$ec121977b4273ffd","$foUtO","$h6ohx","$3Nxyo","$4iD3R","$jfZ8F","$1ee4419f36fc2e55$export$9a0f2e45e685fe64","UniformGroup","value","Matrix","Float32Array","localUniformsBindGroup","BindGroup","mesh","meshData","_getMeshData","isBatched","geometry","_geometry","indices","indexSize","positions","vertexSize","batchableMesh","_getBatchableMesh","texture","_texture","_textureMatrixUpdateId","checkAndUpdateTexture","batcher","gpuBatchableMesh","setTexture","getAdjustedBlendModeBlend","_source","update","_a","_b","_initMeshData","_initBatchableMesh","gpuMesh","BatchableMesh","transform","$6a3b8dc49dafdf46$export$2fa0f0ec877329e3","batcherName","packAsQuad","indexOffset","attributeOffset","_batch","_uvUpdateId","topology","_topology","reset","uvs","uvBuffer","getBuffer","data","transformedUvs","textureMatrix","isSimple","_transformedUvs","_updateID","multiplyUvs","color","attributeSize","$btkbF","$luHtJ","GlParticleContainerPipe","GpuParticleContainerPipe","$0e66adc9b0e7ae70$export$265dc7019ac9a69c","$bIHrh","$2B7hE","ParticleContainerPipe","GlParticleContainerAdaptor","$ab6a6df33775f7e8$export$46c725f3fa23723f","particleContainerPipe","container","defaultShader","uTexture","gl","buffer","getBuffers","bind","glProgram","glType","byteSize","indexBuffer","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","TRIANGLES","particleChildren","$457289e9395f6217$export$bd0cb1ddce5f75fc","$dWJhn","$hAGaQ","uTranslationMatrix","uResolution","ParticleShader","_renderable","_initBuffer","ParticleBuffer","size","properties","_properties","children","_childrenDirty","transformationMatrix","worldTransform","prepend","globalUniforms","globalUniformData","projectionMatrix","resolution","$417f628afd2c0bd6$export$ef6bb3c375ab2229","$jcjyZ","$2M1SI","$9eCTE","$7PVXE","$1lxxr","$iIX2O","$6Ne1X","_size","_generateParticleUpdateCache","staticVertexSize","dynamicVertexSize","property","attributeInfo","getAttributeInfoFromFormat","format","dynamic","stride","_dynamicStride","_staticStride","staticAttributeBuffer","ViewableBuffer","dynamicAttributeBuffer","createIndicesForQuads","Geometry","dynamicOffset","staticOffset","_staticBuffer","Buffer","label","shrinkToFit","usage","BufferUsage","VERTEX","COPY_DST","_dynamicBuffer","addAttribute","attributeName","offset","addIndex","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","key","$417f628afd2c0bd6$var$getParticleSyncKey","keyGen","push","code","join","generateParticleUpdate","generateParticleUpdateFunction","particles","uploadStatic","Math","max","setDataWithSize","byteLength","float32View","uint32View","$b9c8656ec7314b7a$export$c56148e1bec42281","outBuffer","totalIndices","Uint32Array","Uint16Array","Error","j","$50c2c163ab86466a$export$f240bbaff81b32e9","$50c2c163ab86466a$var$generateUpdateFunction","funcFragments","unshift","Function","$8f32e171bbecdab4$export$aff9903e2c89709e","$48fkQ","$liLpc","$kU0Ff","$e7K56","$aLn8X","$f3tpA","$h19ko","$ikbMs","$5O5wk","Shader","GlProgram","from","vertex","default","fragment","gpuProgram","GpuProgram","source","entryPoint","Texture","WHITE","uSampler","TextureStyle","Color","$c5d8af36a6a7aeed$export$2e2bcd8739ae039","$62aa5f4eaed43fe2$export$2e2bcd8739ae039","$32417de8f631e47b$export$2e2bcd8739ae039","$4efa5b05cb38feda$export$1097a2b67474552c","$6upGq","GpuParticleContainerAdaptor","$3e142a964d301a66$export$b05a5c43c842f66d","groups","uniformBatch","getUniformBindGroup","getTextureBindGroup","encoder","draw","$jBf3q","$6lXlh","CanvasTextSystem","CanvasTextPipe","$782ad65665e31985$export$ed0d779e44b53050","$bANDQ","$gnDql","_renderer","text","_didTextUpdate","batchableText","_getGpuText","_updateGpuText","canvasText","returnTexture","_resolution","_autoResolution","getTexture","updateTextBounds","initGpuText","BatchableText","bounds","minX","maxX","minY","maxY","$0e70cc53a28e9d22$export$cd6ce24a38c376aa","$lQ82U","batchableSprite","updateQuadBounds","_anchor","padding","_style","_getFinalPadding","$de9bc8604c3d657e$export$f986f9176e9ba9b4","$2owzg","BatchableSprite","resolutionChange","onViewUpdate","$185a6de3ef267a4e$export$56e4907c2e518abc","$1OAPg","$3E4eL","$7zo47","$92MY1","$9s39u","_textKey","deprecation","style","TextStyle","textureStyle","toString","frame","canvasAndContext","CanvasTextGenerator","getCanvasAndContext","getPo2TextureFromSource","canvas","trim","pad","copyFrom","updateUvs","filters","filteredTexture","_applyFilters","returnCanvasAndContext","initSource","resource","uploadMethodId","alphaMode","TexturePool","renderTextToCanvas","currentRenderTarget","renderTarget","resultTexture","filter","generateFilteredTexture","WebGLSystem","WebGPUSystem","CanvasSystem","$c7538d62d0b01c84$export$80c61c6b7fb407a3","$c7538d62d0b01c84$var$tempBounds","$8SALt","Bounds","image","getOptimalTexture","emit","$hsvCm","BitmapTextPipe","$92aa6cafece1cf42$export$83d8b05a29a5f8ed","$ade8a","$9oyb9","$fxqK4","$gDCWG","$8UQWE","$chxMn","$92aa6cafece1cf42$export$b542b9239140e808","Graphics","renderableGC","addManagedHash","bitmapText","graphicsRenderable","_getGpuBitmapText","_updateContext","$92aa6cafece1cf42$var$syncWithProxy","_updateDistanceField","proxyGraphics","bitmapFont","BitmapFontManager","getFont","clear","distanceField","SdfShader","limits","maxBatchableTextures","chars","CanvasTextMetrics","graphemeSegmenter","currentY","baseLineOffset","bitmapTextLayout","getBitmapTextLayout","index","scale","tx","ty","offsetY","_stroke","translate","_x","_y","tint","applyFillAsTint","_fill","lines","line","charPositions","char","charData","round","xOffset","yOffset","lineHeight","proxyRenderable","fontFamily","dynamicFont","Cache","a","b","c","d","worldScale","abs","sqrt","fontScale","baseRenderedFontSize","fontSize","distance","range","uDistance","proxy","groupColor","globalDisplayStatus","localDisplayStatus","groupAlpha","$998fe545b76bda5f$var$gpuProgram","$998fe545b76bda5f$var$glProgram","$998fe545b76bda5f$export$f19b070f8409d54d","$ej4f8","$5YxuX","$17smN","$g7AUH","$bOtGK","$8gyqY","$7Lg6q","maxTextures","compileHighShaderGpuProgram","bits","colorBit","generateTextureBatchBit","localUniformMSDFBit","mSDFBit","roundPixelsBit","compileHighShaderGlProgram","colorBitGl","generateTextureBatchBitGl","localUniformMSDFBitGl","mSDFBitGl","roundPixelsBitGl","batchSamplers","getBatchSamplersUniformGroup","$1cb27b676a486d96$export$95191d1d81ffe694","$1cb27b676a486d96$export$7542046ad25e8068","header","main","end","$9607c446db198657$export$382a0eb192cd0a47","$9607c446db198657$export$52c5bf2a8ebe1f2a","$blhcp","$asZLE","HTMLTextSystem","HTMLTextPipe","$863662db7e570ec0$export$ffcef6958193be1c","$4wjQA","htmlText","batchableHTMLText","catch","console","error","generatingTexture","texturePromise","returnTexturePromise","getTexturePromise","renderGroup","parentRenderGroup","structureDidChange","BatchableHTMLText","EMPTY","$f25b4baeabb5c94e$export$26955126a6f3eb07","$f038542ce2b3591d$export$f1b82676a746d8e9","$iZnM3","$B03Gj","$2rOmo","$cODmL","$jsjcA","$fiXlD","$9rBIH","$28FcK","$bfoov","$jnJs9","$dcBTC","$hCLHS","_createCanvas","RendererType","WEBGPU","_buildTexturePromise","htmlTextData","HTMLTextRenderData","fontFamilies","extractFontFamilies","fontCSS","getFontCss","HTMLTextStyle","defaultTextStyle","measured","measureHtmlText","ceil","svgURL","getSVGUrl","loadSVGImage","isSafari","getTemporaryCanvasFromImage","CanvasPool","then","_cleanUp","warn","$68aeed0d3a4d122f$export$95df08bae54cb4df","$6vaX0","userAgent","DOMAdapter","getNavigator","test","$5ada3cbfc39ffa2a$export$47ab50939402e24e","$5ada3cbfc39ffa2a$var$nssvg","$5ada3cbfc39ffa2a$var$nsxhtml","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","Image","setAttribute","overflow","appendChild","$cf919ade67202e7d$export$a2664b42ece43c6c","$aI8Ic","_cssOverrides","cssOverrides","tagStyles","Array","_cssStyle","clone","align","breakWords","dropShadow","fill","fontStyle","fontVariant","fontWeight","letterSpacing","stroke","whiteSpace","wordWrap","wordWrapWidth","cssStyle","textStyleToCSS","addOverride","toAdd","includes","removeOverride","toRemove","$af5a68e1fdd228ed$export$8daecfbc002513c1","cssStyleString","setValue","toHex","$af5a68e1fdd228ed$var$strokeToCSS","$af5a68e1fdd228ed$var$dropShadowToCSS","cssStyles","$af5a68e1fdd228ed$var$tagStyleToCSS","out","tagStyle","cssTagStyle","$af5a68e1fdd228ed$var$transform","$af5a68e1fdd228ed$var$templates","replace","dropShadowStyle","setAlpha","alpha","toHexa","x","cos","angle","y","sin","position","blur","$5909f0521f2451f4$export$464e4dcbf779d16c","dedupe","matches","match","addFontFamily","fontFamily2","isArray","split","$b6e208b0ddbc61f0$export$634b39f5e6e8534d","$dh51I","$b6e208b0ddbc61f0$export$9b6075a0351ad0f8","Map","defaultOptions","fontPromises","has","url","loadFontCSS","Promise","all","$0a47f00274fea094$export$d5a8e182a5491db2","$6x5vK","dataSrc","loadFontAsBase64","$e1290b9d55306c7e$export$21404a5ba2126552","response","fetch","blob","reader","FileReader","resolve","reject","onloadend","result","onerror","readAsDataURL","$dda08f046e8bf63f$export$98b744dca5b9429f","innerHTML","textContent","XMLSerializer","serializeToString","$e9ec9b7306ce67f3$export$d871fed544c30b4e","getOptimalCanvasAndContext","clearRect","drawImage","$a663ffea206a7599$export$31cf685397f1a12a","delay","resolve2","setTimeout","onload","src","encodeURIComponent","crossOrigin","$64c9efc69c5c9e7f$var$tempHTMLTextRenderData","$64c9efc69c5c9e7f$export$9df7f2a259800030","fontStyleCSS","htmlTextRenderData","body","contentBounds","getBoundingClientRect","doublePadding","$aQv0r","TilingSpritePipe","$41435221e1c64257$export$b56051ebf906ec5d","$fSWkS","$7Obr6","$gvNpS","$b9Nfj","$igtv6","$41435221e1c64257$var$sharedQuad","QuadGeometry","$41435221e1c64257$export$885407fa78df5856","canBatch","MeshGeometry","slice","_state","default2d","tilingSpriteData","_getTilingSpriteData","couldBatch","_updateCanBatch","tilingSprite","_updateBatchableMesh","TilingSpriteShader","bindGroup","updateUniforms","_tileTransform","matrix","anchor","_initTilingSpriteData","addressMode","setUvs","setPositions","renderableData","_nonPowOf2wrapping","WEBGL","supports","nonPowOf2wrapping","isPowerOfTwo","$7e99b50a9c43e1c3$export$8d075a36a73d54bc","$7e99b50a9c43e1c3$var$_MeshGeometry","_MeshGeometry","args","v8_0_0","shrinkBuffersToFit","positionBuffer","attributes","aPosition","aUV","INDEX","batchMode","$49f7d8e45dc94ce1$var$gpuProgram","$49f7d8e45dc94ce1$var$glProgram","$49f7d8e45dc94ce1$export$d1a26cc57b383809","$eQjNz","$aMkwq","localUniformBit","tilingBit","localUniformBitGl","tilingBitGl","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","anchorX","anchorY","textureWidth","textureHeight","invert","mapCoord","$2eab715da6b63a33$export$7551c6773b6af70d","$2eab715da6b63a33$export$a104558c66046525","$72dcbea81ac68973$export$d27e254c8c1b5a0e","$d417f5ea2259a21c$export$7d390d1e3efa819a","$ffde90ef0263e011$export$f99a1f47283a6d20","$acxAJ","applyAnchorToTexture","applyMatrix","$62bb28c9ea21deba$export$8e14504c3429ee65","array","$268qR","NineSliceSpritePipe","$27e420f55975ab25$export$69030e8b070eaa80","$iOzIU","$27e420f55975ab25$export$33a15b7a67fcc678","NineSliceGeometry","sprite","gpuSprite","_getGpuSprite","_updateBatchableSprite","_initGPUSprite","$d14ebf971a0b187d$export$a1f405faf7381142","$jLSB6","$d14ebf971a0b187d$var$_NineSliceGeometry","_NineSliceGeometry","PlaneGeometry","verticesX","verticesY","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","_anchorX","_anchorY","updatePositions","p","w","h","min","anchorOffsetX","anchorOffsetY","_uvw","_uvh","$9620cf5ed25e7440$export$967d831af31f69ce","$9620cf5ed25e7440$var$_PlaneGeometry","_PlaneGeometry","build","total","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","$4OSBl","$01Fst","FilterSystem","FilterPipe","$0e1609bc1a16db8d$export$26a654548ff780c7","filterEffect","renderPipeId","canBundle","action","pop","_filterEffect","_container","instruction","$d726d91e30b6f8a3$export$e94225c0dfac29cf","$jJTWC","$d726d91e30b6f8a3$var$quadGeometry","$d726d91e30b6f8a3$var$FilterData","skip","inputTexture","backTexture","blendRequired","outputRenderSurface","outputOffset","globalFrame","_filterStackIndex","_filterStack","_filterGlobalUniforms","uInputSize","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","activeBackTexture","_activeFilterData","filterData","_pushFilterData","renderSurface","colorTextureSource","colorTexture","rootResolution","rootAntialias","antialias","renderables","getGlobalRenderableBounds","filterArea","addRect","getFastGlobalBounds","filterFrameTransform","cacheToLocalTransform","_calculateFilterBounds","rootViewPort","previousFilterData","_getPreviousFilterData","globalResolution","offsetX","finishRenderPass","getRenderTarget","getBackTexture","rectangle","_applyFiltersToTexture","outputTexture","_popFilterData","lastRenderSurface","previousBounds","backgroundResolution","floor","copyToTexture","applyFilter","input","output","filterUniforms","outputFrame","inputSize","inputPixel","inputClamp","pixelWidth","pixelHeight","isRoot","batchUniforms","getUboResource","setResource","calculateSpriteMatrix","outputMatrix","mappedMatrix","apply","flip","tempTexture","flop","t","viewPort","paddingMultiplier","Infinity","enabled","clipToViewport","compatibleRenderers","backBuffer","useBackBuffer","fitBounds","isPositive","$93739931341014c8$export$11abb8ef28048394","tempMatrix","addBounds"],"version":3,"file":"browserAll.5a68cb80.js.map"}