{"mappings":"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","sources":["<anon>","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/environment-browser/browserAll.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/accessibility/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/accessibility/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/accessibility/AccessibilitySystem.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/events/FederatedEvent.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/events/FederatedEvent.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/utils/browser/isMobile.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/utils/browser/isMobile.ts","node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/src/index.ts","node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/isMobile.js","node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/src/isMobile.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/accessibility/accessibilityTarget.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/events/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/events/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/events/EventSystem.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/events/EventSystem.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/events/EventBoundary.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/events/EventBoundary.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/events/EventTicker.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/events/EventTicker.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/events/FederatedMouseEvent.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/events/FederatedPointerEvent.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/events/FederatedWheelEvent.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/events/FederatedEventTarget.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/dom/init.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/dom/init.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/dom/DOMPipe.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/dom/DOMPipe.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","node_modules/.pnpm/pixi.js@8.10.1/node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire792f\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"8B4Px\", function(module, exports) {\nparcelRequire(\"e38Dm\");\nparcelRequire(\"5eFmp\");\nparcelRequire(\"4V3PX\");\nparcelRequire(\"175Iu\");\nparcelRequire(\"4JOgP\");\nparcelRequire(\"7zWo8\");\nparcelRequire(\"j2iTt\");\nparcelRequire(\"aoZnp\");\nparcelRequire(\"kuK0D\");\nparcelRequire(\"aJIrY\");\nparcelRequire(\"cucmg\");\nparcelRequire(\"f1viB\");\nparcelRequire(\"l7qDi\");\nparcelRequire(\"2ZRVb\");\nparcelRequire(\"hn0b8\");\n\"use strict\";\n\n});\nparcelRegister(\"e38Dm\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $39lGH = parcelRequire(\"39lGH\");\n\nvar $3FyDp = parcelRequire(\"3FyDp\");\n\nvar $ftgKc = parcelRequire(\"ftgKc\");\n\"use strict\";\n(0, $arnWa.extensions).add((0, $3FyDp.AccessibilitySystem));\n(0, $arnWa.extensions).mixin((0, $39lGH.Container), (0, $ftgKc.accessibilityTarget));\n\n});\nparcelRegister(\"3FyDp\", function(module, exports) {\n\n$parcel$export(module.exports, \"AccessibilitySystem\", () => $0d635074c2b7a040$export$982526b2aa4fb64c);\n\nvar $1KB1X = parcelRequire(\"1KB1X\");\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $4IeSv = parcelRequire(\"4IeSv\");\n\nvar $eFJqo = parcelRequire(\"eFJqo\");\n\"use strict\";\nconst $0d635074c2b7a040$var$KEY_CODE_TAB = 9;\nconst $0d635074c2b7a040$var$DIV_TOUCH_SIZE = 100;\nconst $0d635074c2b7a040$var$DIV_TOUCH_POS_X = 0;\nconst $0d635074c2b7a040$var$DIV_TOUCH_POS_Y = 0;\nconst $0d635074c2b7a040$var$DIV_TOUCH_ZINDEX = 2;\nconst $0d635074c2b7a040$var$DIV_HOOK_SIZE = 1;\nconst $0d635074c2b7a040$var$DIV_HOOK_POS_X = -1000;\nconst $0d635074c2b7a040$var$DIV_HOOK_POS_Y = -1000;\nconst $0d635074c2b7a040$var$DIV_HOOK_ZINDEX = 2;\nconst $0d635074c2b7a040$var$_AccessibilitySystem = class _AccessibilitySystem {\n    // 2fps\n    // eslint-disable-next-line jsdoc/require-param\n    /**\n   * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n   */ constructor(renderer, _mobileInfo = (0, $4IeSv.isMobile)){\n        this._mobileInfo = _mobileInfo;\n        /** Whether accessibility divs are visible for debugging */ this.debug = false;\n        /** Whether to activate on tab key press */ this._activateOnTab = true;\n        /** Whether to deactivate accessibility when mouse moves */ this._deactivateOnMouseMove = true;\n        /** Internal variable, see isActive getter. */ this._isActive = false;\n        /** Internal variable, see isMobileAccessibility getter. */ this._isMobileAccessibility = false;\n        /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */ this._div = null;\n        /** A simple pool for storing divs. */ this._pool = [];\n        /** This is a tick used to check if an object is no longer being rendered. */ this._renderId = 0;\n        /** The array of currently active accessible items. */ this._children = [];\n        /** Count to throttle div updates on android devices. */ this._androidUpdateCount = 0;\n        /**  The frequency to update the div elements. */ this._androidUpdateFrequency = 500;\n        this._hookDiv = null;\n        if (_mobileInfo.tablet || _mobileInfo.phone) this._createTouchHook();\n        this._renderer = renderer;\n    }\n    /**\n   * Value of `true` if accessibility is currently active and accessibility layers are showing.\n   * @type {boolean}\n   * @readonly\n   */ get isActive() {\n        return this._isActive;\n    }\n    /**\n   * Value of `true` if accessibility is enabled for touch devices.\n   * @type {boolean}\n   * @readonly\n   */ get isMobileAccessibility() {\n        return this._isMobileAccessibility;\n    }\n    /**\n   * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.\n   * @readonly\n   */ get hookDiv() {\n        return this._hookDiv;\n    }\n    /**\n   * Creates the touch hooks.\n   * @private\n   */ _createTouchHook() {\n        const hookDiv = document.createElement(\"button\");\n        hookDiv.style.width = `${$0d635074c2b7a040$var$DIV_HOOK_SIZE}px`;\n        hookDiv.style.height = `${$0d635074c2b7a040$var$DIV_HOOK_SIZE}px`;\n        hookDiv.style.position = \"absolute\";\n        hookDiv.style.top = `${$0d635074c2b7a040$var$DIV_HOOK_POS_X}px`;\n        hookDiv.style.left = `${$0d635074c2b7a040$var$DIV_HOOK_POS_Y}px`;\n        hookDiv.style.zIndex = $0d635074c2b7a040$var$DIV_HOOK_ZINDEX.toString();\n        hookDiv.style.backgroundColor = \"#FF0000\";\n        hookDiv.title = \"select to enable accessibility for this content\";\n        hookDiv.addEventListener(\"focus\", ()=>{\n            this._isMobileAccessibility = true;\n            this._activate();\n            this._destroyTouchHook();\n        });\n        document.body.appendChild(hookDiv);\n        this._hookDiv = hookDiv;\n    }\n    /**\n   * Destroys the touch hooks.\n   * @private\n   */ _destroyTouchHook() {\n        if (!this._hookDiv) return;\n        document.body.removeChild(this._hookDiv);\n        this._hookDiv = null;\n    }\n    /**\n   * Activating will cause the Accessibility layer to be shown.\n   * This is called when a user presses the tab key.\n   * @private\n   */ _activate() {\n        if (this._isActive) return;\n        this._isActive = true;\n        if (!this._div) {\n            this._div = document.createElement(\"div\");\n            this._div.style.width = `${$0d635074c2b7a040$var$DIV_TOUCH_SIZE}px`;\n            this._div.style.height = `${$0d635074c2b7a040$var$DIV_TOUCH_SIZE}px`;\n            this._div.style.position = \"absolute\";\n            this._div.style.top = `${$0d635074c2b7a040$var$DIV_TOUCH_POS_X}px`;\n            this._div.style.left = `${$0d635074c2b7a040$var$DIV_TOUCH_POS_Y}px`;\n            this._div.style.zIndex = $0d635074c2b7a040$var$DIV_TOUCH_ZINDEX.toString();\n            this._div.style.pointerEvents = \"none\";\n        }\n        if (this._activateOnTab) {\n            this._onKeyDown = this._onKeyDown.bind(this);\n            globalThis.addEventListener(\"keydown\", this._onKeyDown, false);\n        }\n        if (this._deactivateOnMouseMove) {\n            this._onMouseMove = this._onMouseMove.bind(this);\n            globalThis.document.addEventListener(\"mousemove\", this._onMouseMove, true);\n        }\n        const canvas = this._renderer.view.canvas;\n        if (!canvas.parentNode) {\n            const observer = new MutationObserver(()=>{\n                if (canvas.parentNode) {\n                    canvas.parentNode.appendChild(this._div);\n                    observer.disconnect();\n                    this._initAccessibilitySetup();\n                }\n            });\n            observer.observe(document.body, {\n                childList: true,\n                subtree: true\n            });\n        } else {\n            canvas.parentNode.appendChild(this._div);\n            this._initAccessibilitySetup();\n        }\n    }\n    // New method to handle initialization after div is ready\n    _initAccessibilitySetup() {\n        this._renderer.runners.postrender.add(this);\n        if (this._renderer.lastObjectRendered) this._updateAccessibleObjects(this._renderer.lastObjectRendered);\n    }\n    /**\n   * Deactivates the accessibility system. Removes listeners and accessibility elements.\n   * @private\n   */ _deactivate() {\n        if (!this._isActive || this._isMobileAccessibility) return;\n        this._isActive = false;\n        globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, true);\n        if (this._activateOnTab) globalThis.addEventListener(\"keydown\", this._onKeyDown, false);\n        this._renderer.runners.postrender.remove(this);\n        for (const child of this._children){\n            if (child._accessibleDiv && child._accessibleDiv.parentNode) {\n                child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n                child._accessibleDiv = null;\n            }\n            child._accessibleActive = false;\n        }\n        this._pool.forEach((div)=>{\n            if (div.parentNode) div.parentNode.removeChild(div);\n        });\n        if (this._div && this._div.parentNode) this._div.parentNode.removeChild(this._div);\n        this._pool = [];\n        this._children = [];\n    }\n    /**\n   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n   * @private\n   * @param {Container} container - The Container to check.\n   */ _updateAccessibleObjects(container) {\n        if (!container.visible || !container.accessibleChildren) return;\n        if (container.accessible) {\n            if (!container._accessibleActive) this._addChild(container);\n            container._renderId = this._renderId;\n        }\n        const children = container.children;\n        if (children) for(let i = 0; i < children.length; i++)this._updateAccessibleObjects(children[i]);\n    }\n    /**\n   * Runner init called, view is available at this point.\n   * @ignore\n   */ init(options) {\n        const defaultOpts = _AccessibilitySystem.defaultOptions;\n        const mergedOptions = {\n            accessibilityOptions: {\n                ...defaultOpts,\n                ...options?.accessibilityOptions || {}\n            }\n        };\n        this.debug = mergedOptions.accessibilityOptions.debug;\n        this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;\n        this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;\n        if (mergedOptions.accessibilityOptions.enabledByDefault) this._activate();\n        else if (this._activateOnTab) {\n            this._onKeyDown = this._onKeyDown.bind(this);\n            globalThis.addEventListener(\"keydown\", this._onKeyDown, false);\n        }\n        this._renderer.runners.postrender.remove(this);\n    }\n    /**\n   * Updates the accessibility layer during rendering.\n   * - Removes divs for containers no longer in the scene\n   * - Updates the position and dimensions of the root div\n   * - Updates positions of active accessibility divs\n   * Only fires while the accessibility system is active.\n   * @ignore\n   */ postrender() {\n        const now = performance.now();\n        if (this._mobileInfo.android.device && now < this._androidUpdateCount) return;\n        this._androidUpdateCount = now + this._androidUpdateFrequency;\n        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) return;\n        const activeIds = /* @__PURE__ */ new Set();\n        if (this._renderer.lastObjectRendered) {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered);\n            for (const child of this._children)if (child._renderId === this._renderId) activeIds.add(this._children.indexOf(child));\n        }\n        for(let i = this._children.length - 1; i >= 0; i--){\n            const child = this._children[i];\n            if (!activeIds.has(i)) {\n                if (child._accessibleDiv && child._accessibleDiv.parentNode) {\n                    child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n                    this._pool.push(child._accessibleDiv);\n                    child._accessibleDiv = null;\n                }\n                child._accessibleActive = false;\n                (0, $eFJqo.removeItems)(this._children, i, 1);\n            }\n        }\n        if (this._renderer.renderingToScreen) {\n            const { x: x, y: y, width: viewWidth, height: viewHeight } = this._renderer.screen;\n            const div = this._div;\n            div.style.left = `${x}px`;\n            div.style.top = `${y}px`;\n            div.style.width = `${viewWidth}px`;\n            div.style.height = `${viewHeight}px`;\n        }\n        for(let i = 0; i < this._children.length; i++){\n            const child = this._children[i];\n            if (!child._accessibleActive || !child._accessibleDiv) continue;\n            const div = child._accessibleDiv;\n            const hitArea = child.hitArea || child.getBounds().rectangle;\n            if (child.hitArea) {\n                const wt = child.worldTransform;\n                const sx = this._renderer.resolution;\n                const sy = this._renderer.resolution;\n                div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;\n                div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;\n                div.style.width = `${hitArea.width * wt.a * sx}px`;\n                div.style.height = `${hitArea.height * wt.d * sy}px`;\n            } else {\n                this._capHitArea(hitArea);\n                const sx = this._renderer.resolution;\n                const sy = this._renderer.resolution;\n                div.style.left = `${hitArea.x * sx}px`;\n                div.style.top = `${hitArea.y * sy}px`;\n                div.style.width = `${hitArea.width * sx}px`;\n                div.style.height = `${hitArea.height * sy}px`;\n            }\n        }\n        this._renderId++;\n    }\n    /**\n   * private function that will visually add the information to the\n   * accessibility div\n   * @param {HTMLElement} div -\n   */ _updateDebugHTML(div) {\n        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n    }\n    /**\n   * Adjust the hit area based on the bounds of a display object\n   * @param {Rectangle} hitArea - Bounds of the child\n   */ _capHitArea(hitArea) {\n        if (hitArea.x < 0) {\n            hitArea.width += hitArea.x;\n            hitArea.x = 0;\n        }\n        if (hitArea.y < 0) {\n            hitArea.height += hitArea.y;\n            hitArea.y = 0;\n        }\n        const { width: viewWidth, height: viewHeight } = this._renderer;\n        if (hitArea.x + hitArea.width > viewWidth) hitArea.width = viewWidth - hitArea.x;\n        if (hitArea.y + hitArea.height > viewHeight) hitArea.height = viewHeight - hitArea.y;\n    }\n    /**\n   * Creates or reuses a div element for a Container and adds it to the accessibility layer.\n   * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.\n   * @private\n   * @param {Container} container - The child to make accessible.\n   */ _addChild(container) {\n        let div = this._pool.pop();\n        if (!div) {\n            if (container.accessibleType === \"button\") div = document.createElement(\"button\");\n            else {\n                div = document.createElement(container.accessibleType);\n                div.style.cssText = `\n                        color: transparent;\n                        pointer-events: none;\n                        padding: 0;\n                        margin: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        box-sizing: border-box;\n                        user-select: none;\n                        -webkit-user-select: none;\n                        -moz-user-select: none;\n                        -ms-user-select: none;\n                    `;\n                if (container.accessibleText) div.innerText = container.accessibleText;\n            }\n            div.style.width = `${$0d635074c2b7a040$var$DIV_TOUCH_SIZE}px`;\n            div.style.height = `${$0d635074c2b7a040$var$DIV_TOUCH_SIZE}px`;\n            div.style.backgroundColor = this.debug ? \"rgba(255,255,255,0.5)\" : \"transparent\";\n            div.style.position = \"absolute\";\n            div.style.zIndex = $0d635074c2b7a040$var$DIV_TOUCH_ZINDEX.toString();\n            div.style.borderStyle = \"none\";\n            if (navigator.userAgent.toLowerCase().includes(\"chrome\")) div.setAttribute(\"aria-live\", \"off\");\n            else div.setAttribute(\"aria-live\", \"polite\");\n            if (navigator.userAgent.match(/rv:.*Gecko\\//)) div.setAttribute(\"aria-relevant\", \"additions\");\n            else div.setAttribute(\"aria-relevant\", \"text\");\n            div.addEventListener(\"click\", this._onClick.bind(this));\n            div.addEventListener(\"focus\", this._onFocus.bind(this));\n            div.addEventListener(\"focusout\", this._onFocusOut.bind(this));\n        }\n        div.style.pointerEvents = container.accessiblePointerEvents;\n        div.type = container.accessibleType;\n        if (container.accessibleTitle && container.accessibleTitle !== null) div.title = container.accessibleTitle;\n        else if (!container.accessibleHint || container.accessibleHint === null) div.title = `container ${container.tabIndex}`;\n        if (container.accessibleHint && container.accessibleHint !== null) div.setAttribute(\"aria-label\", container.accessibleHint);\n        if (this.debug) this._updateDebugHTML(div);\n        container._accessibleActive = true;\n        container._accessibleDiv = div;\n        div.container = container;\n        this._children.push(container);\n        this._div.appendChild(container._accessibleDiv);\n        if (container.interactive) container._accessibleDiv.tabIndex = container.tabIndex;\n    }\n    /**\n   * Dispatch events with the EventSystem.\n   * @param e\n   * @param type\n   * @private\n   */ _dispatchEvent(e, type) {\n        const { container: target } = e.target;\n        const boundary = this._renderer.events.rootBoundary;\n        const event = Object.assign(new (0, $1KB1X.FederatedEvent)(boundary), {\n            target: target\n        });\n        boundary.rootTarget = this._renderer.lastObjectRendered;\n        type.forEach((type2)=>boundary.dispatchEvent(event, type2));\n    }\n    /**\n   * Maps the div button press to pixi's EventSystem (click)\n   * @private\n   * @param {MouseEvent} e - The click event.\n   */ _onClick(e) {\n        this._dispatchEvent(e, [\n            \"click\",\n            \"pointertap\",\n            \"tap\"\n        ]);\n    }\n    /**\n   * Maps the div focus events to pixi's EventSystem (mouseover)\n   * @private\n   * @param {FocusEvent} e - The focus event.\n   */ _onFocus(e) {\n        if (!e.target.getAttribute(\"aria-live\")) e.target.setAttribute(\"aria-live\", \"assertive\");\n        this._dispatchEvent(e, [\n            \"mouseover\"\n        ]);\n    }\n    /**\n   * Maps the div focus events to pixi's EventSystem (mouseout)\n   * @private\n   * @param {FocusEvent} e - The focusout event.\n   */ _onFocusOut(e) {\n        if (!e.target.getAttribute(\"aria-live\")) e.target.setAttribute(\"aria-live\", \"polite\");\n        this._dispatchEvent(e, [\n            \"mouseout\"\n        ]);\n    }\n    /**\n   * Is called when a key is pressed\n   * @private\n   * @param {KeyboardEvent} e - The keydown event.\n   */ _onKeyDown(e) {\n        if (e.keyCode !== $0d635074c2b7a040$var$KEY_CODE_TAB || !this._activateOnTab) return;\n        this._activate();\n    }\n    /**\n   * Is called when the mouse moves across the renderer element\n   * @private\n   * @param {MouseEvent} e - The mouse event.\n   */ _onMouseMove(e) {\n        if (e.movementX === 0 && e.movementY === 0) return;\n        this._deactivate();\n    }\n    /**\n   * Destroys the accessibility system. Removes all elements and listeners.\n   * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.\n   * > A typically user should not need to call this method directly.\n   */ destroy() {\n        this._deactivate();\n        this._destroyTouchHook();\n        this._div = null;\n        this._pool = null;\n        this._children = null;\n        this._renderer = null;\n        if (this._activateOnTab) globalThis.removeEventListener(\"keydown\", this._onKeyDown);\n    }\n    /**\n   * Enables or disables the accessibility system.\n   * @param enabled - Whether to enable or disable accessibility.\n   * @example\n   * ```js\n   * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility\n   * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility\n   * ```\n   */ setAccessibilityEnabled(enabled) {\n        if (enabled) this._activate();\n        else this._deactivate();\n    }\n};\n/** @ignore */ $0d635074c2b7a040$var$_AccessibilitySystem.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLSystem,\n        (0, $arnWa.ExtensionType).WebGPUSystem\n    ],\n    name: \"accessibility\"\n};\n/**\n * The default options used by the system.\n * You can set these before initializing the {@link Application} to change the default behavior.\n * @example\n * ```js\n * import { AccessibilitySystem } from 'pixi.js';\n *\n * AccessibilitySystem.defaultOptions.enabledByDefault = true;\n *\n * const app = new Application()\n * app.init()\n * ```\n */ $0d635074c2b7a040$var$_AccessibilitySystem.defaultOptions = {\n    /**\n   * Whether to enable accessibility features on initialization\n   * @default false\n   */ enabledByDefault: false,\n    /**\n   * Whether to visually show the accessibility divs for debugging\n   * @default false\n   */ debug: false,\n    /**\n   * Whether to activate accessibility when tab key is pressed\n   * @default true\n   */ activateOnTab: true,\n    /**\n   * Whether to deactivate accessibility when mouse moves\n   * @default true\n   */ deactivateOnMouseMove: true\n};\nlet $0d635074c2b7a040$export$982526b2aa4fb64c = $0d635074c2b7a040$var$_AccessibilitySystem;\n\n});\nparcelRegister(\"1KB1X\", function(module, exports) {\n\n$parcel$export(module.exports, \"FederatedEvent\", () => $721d8b14c206e73c$export$5d10db92bb959d8a);\n\nvar $gmxRF = parcelRequire(\"gmxRF\");\n\"use strict\";\nclass $721d8b14c206e73c$export$5d10db92bb959d8a {\n    /**\n   * @param manager - The event boundary which manages this event. Propagation can only occur\n   *  within the boundary's jurisdiction.\n   */ constructor(manager){\n        /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */ this.bubbles = true;\n        /** @deprecated since 7.0.0 */ this.cancelBubble = true;\n        /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */ this.cancelable = false;\n        /**\n     * Flag added for compatibility with DOM `Event`. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     * @ignore\n     */ this.composed = false;\n        /** Flags whether the default response of the user agent was prevent through this event. */ this.defaultPrevented = false;\n        /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */ this.eventPhase = $721d8b14c206e73c$export$5d10db92bb959d8a.prototype.NONE;\n        /** Flags whether propagation was stopped. */ this.propagationStopped = false;\n        /** Flags whether propagation was immediately stopped. */ this.propagationImmediatelyStopped = false;\n        /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */ this.layer = new (0, $gmxRF.Point)();\n        /** The coordinates of the event relative to the DOM document. This is a non-standard property. */ this.page = new (0, $gmxRF.Point)();\n        /**\n     * The event propagation phase NONE that indicates that the event is not in any phase.\n     * @default 0\n     * @advanced\n     */ this.NONE = 0;\n        /**\n     * The event propagation phase CAPTURING_PHASE that indicates that the event is in the capturing phase.\n     * @default 1\n     * @advanced\n     */ this.CAPTURING_PHASE = 1;\n        /**\n     * The event propagation phase AT_TARGET that indicates that the event is at the target.\n     * @default 2\n     * @advanced\n     */ this.AT_TARGET = 2;\n        /**\n     * The event propagation phase BUBBLING_PHASE that indicates that the event is in the bubbling phase.\n     * @default 3\n     * @advanced\n     */ this.BUBBLING_PHASE = 3;\n        this.manager = manager;\n    }\n    /** @readonly */ get layerX() {\n        return this.layer.x;\n    }\n    /** @readonly */ get layerY() {\n        return this.layer.y;\n    }\n    /** @readonly */ get pageX() {\n        return this.page.x;\n    }\n    /** @readonly */ get pageY() {\n        return this.page.y;\n    }\n    /**\n   * Fallback for the deprecated `InteractionEvent.data`.\n   * @deprecated since 7.0.0\n   */ get data() {\n        return this;\n    }\n    /**\n   * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.\n   * @advanced\n   */ composedPath() {\n        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) this.path = this.target ? this.manager.propagationPath(this.target) : [];\n        return this.path;\n    }\n    /**\n   * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.\n   * @deprecated\n   * @ignore\n   * @param _type\n   * @param _bubbles\n   * @param _cancelable\n   */ initEvent(_type, _bubbles, _cancelable) {\n        throw new Error(\"initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.\");\n    }\n    /**\n   * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.\n   * @ignore\n   * @deprecated\n   * @param _typeArg\n   * @param _bubblesArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   */ initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {\n        throw new Error(\"initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.\");\n    }\n    /**\n   * Prevent default behavior of both PixiJS and the user agent.\n   * @example\n   * ```ts\n   * sprite.on('click', (event) => {\n   *     // Prevent both browser's default click behavior\n   *     // and PixiJS's default handling\n   *     event.preventDefault();\n   *\n   *     // Custom handling\n   *     customClickHandler();\n   * });\n   * ```\n   * @remarks\n   * - Only works if the native event is cancelable\n   * - Does not stop event propagation\n   */ preventDefault() {\n        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) this.nativeEvent.preventDefault();\n        this.defaultPrevented = true;\n    }\n    /**\n   * Stop this event from propagating to any additional listeners, including those\n   * on the current target and any following targets in the propagation path.\n   * @example\n   * ```ts\n   * container.on('pointerdown', (event) => {\n   *     // Stop all further event handling\n   *     event.stopImmediatePropagation();\n   *\n   *     // These handlers won't be called:\n   *     // - Other pointerdown listeners on this container\n   *     // - Any pointerdown listeners on parent containers\n   * });\n   * ```\n   * @remarks\n   * - Immediately stops all event propagation\n   * - Prevents other listeners on same target from being called\n   * - More aggressive than stopPropagation()\n   */ stopImmediatePropagation() {\n        this.propagationImmediatelyStopped = true;\n    }\n    /**\n   * Stop this event from propagating to the next target in the propagation path.\n   * The rest of the listeners on the current target will still be notified.\n   * @example\n   * ```ts\n   * child.on('pointermove', (event) => {\n   *     // Handle event on child\n   *     updateChild();\n   *\n   *     // Prevent parent handlers from being called\n   *     event.stopPropagation();\n   * });\n   *\n   * // This won't be called if child handles the event\n   * parent.on('pointermove', (event) => {\n   *     updateParent();\n   * });\n   * ```\n   * @remarks\n   * - Stops event bubbling to parent containers\n   * - Does not prevent other listeners on same target\n   * - Less aggressive than stopImmediatePropagation()\n   */ stopPropagation() {\n        this.propagationStopped = true;\n    }\n}\n\n});\n\nparcelRegister(\"4IeSv\", function(module, exports) {\n\n$parcel$export(module.exports, \"isMobile\", () => $d52e978f520f6185$export$d0a8044dce8ff2fc);\nparcelRequire(\"3FAem\");\nvar $kOAor = parcelRequire(\"kOAor\");\n\"use strict\";\nconst $d52e978f520f6185$var$isMobileCall = (0, $kOAor.default).default ?? (0, $kOAor.default);\nconst $d52e978f520f6185$export$d0a8044dce8ff2fc = $d52e978f520f6185$var$isMobileCall(globalThis.navigator);\n\n});\nparcelRegister(\"3FAem\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => (parcelRequire(\"kOAor\")).default);\n\nvar $kOAor = parcelRequire(\"kOAor\");\n\n});\nparcelRegister(\"kOAor\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $f274b51b862d63d3$export$2e2bcd8739ae039);\nvar $f274b51b862d63d3$var$appleIphone = /iPhone/i;\nvar $f274b51b862d63d3$var$appleIpod = /iPod/i;\nvar $f274b51b862d63d3$var$appleTablet = /iPad/i;\nvar $f274b51b862d63d3$var$appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nvar $f274b51b862d63d3$var$androidPhone = /\\bAndroid(?:.+)Mobile\\b/i;\nvar $f274b51b862d63d3$var$androidTablet = /Android/i;\nvar $f274b51b862d63d3$var$amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i;\nvar $f274b51b862d63d3$var$amazonTablet = /Silk/i;\nvar $f274b51b862d63d3$var$windowsPhone = /Windows Phone/i;\nvar $f274b51b862d63d3$var$windowsTablet = /\\bWindows(?:.+)ARM\\b/i;\nvar $f274b51b862d63d3$var$otherBlackBerry = /BlackBerry/i;\nvar $f274b51b862d63d3$var$otherBlackBerry10 = /BB10/i;\nvar $f274b51b862d63d3$var$otherOpera = /Opera Mini/i;\nvar $f274b51b862d63d3$var$otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nvar $f274b51b862d63d3$var$otherFirefox = /Mobile(?:.+)Firefox\\b/i;\nvar $f274b51b862d63d3$var$isAppleTabletOnIos13 = function(navigator1) {\n    return typeof navigator1 !== 'undefined' && navigator1.platform === 'MacIntel' && typeof navigator1.maxTouchPoints === 'number' && navigator1.maxTouchPoints > 1 && typeof MSStream === 'undefined';\n};\nfunction $f274b51b862d63d3$var$createMatch(userAgent) {\n    return function(regex) {\n        return regex.test(userAgent);\n    };\n}\nfunction $f274b51b862d63d3$export$2e2bcd8739ae039(param) {\n    var nav = {\n        userAgent: '',\n        platform: '',\n        maxTouchPoints: 0\n    };\n    if (!param && typeof navigator !== 'undefined') nav = {\n        userAgent: navigator.userAgent,\n        platform: navigator.platform,\n        maxTouchPoints: navigator.maxTouchPoints || 0\n    };\n    else if (typeof param === 'string') nav.userAgent = param;\n    else if (param && param.userAgent) nav = {\n        userAgent: param.userAgent,\n        platform: param.platform,\n        maxTouchPoints: param.maxTouchPoints || 0\n    };\n    var userAgent = nav.userAgent;\n    var tmp = userAgent.split('[FBAN');\n    if (typeof tmp[1] !== 'undefined') userAgent = tmp[0];\n    tmp = userAgent.split('Twitter');\n    if (typeof tmp[1] !== 'undefined') userAgent = tmp[0];\n    var match = $f274b51b862d63d3$var$createMatch(userAgent);\n    var result = {\n        apple: {\n            phone: match($f274b51b862d63d3$var$appleIphone) && !match($f274b51b862d63d3$var$windowsPhone),\n            ipod: match($f274b51b862d63d3$var$appleIpod),\n            tablet: !match($f274b51b862d63d3$var$appleIphone) && (match($f274b51b862d63d3$var$appleTablet) || $f274b51b862d63d3$var$isAppleTabletOnIos13(nav)) && !match($f274b51b862d63d3$var$windowsPhone),\n            universal: match($f274b51b862d63d3$var$appleUniversal),\n            device: (match($f274b51b862d63d3$var$appleIphone) || match($f274b51b862d63d3$var$appleIpod) || match($f274b51b862d63d3$var$appleTablet) || match($f274b51b862d63d3$var$appleUniversal) || $f274b51b862d63d3$var$isAppleTabletOnIos13(nav)) && !match($f274b51b862d63d3$var$windowsPhone)\n        },\n        amazon: {\n            phone: match($f274b51b862d63d3$var$amazonPhone),\n            tablet: !match($f274b51b862d63d3$var$amazonPhone) && match($f274b51b862d63d3$var$amazonTablet),\n            device: match($f274b51b862d63d3$var$amazonPhone) || match($f274b51b862d63d3$var$amazonTablet)\n        },\n        android: {\n            phone: !match($f274b51b862d63d3$var$windowsPhone) && match($f274b51b862d63d3$var$amazonPhone) || !match($f274b51b862d63d3$var$windowsPhone) && match($f274b51b862d63d3$var$androidPhone),\n            tablet: !match($f274b51b862d63d3$var$windowsPhone) && !match($f274b51b862d63d3$var$amazonPhone) && !match($f274b51b862d63d3$var$androidPhone) && (match($f274b51b862d63d3$var$amazonTablet) || match($f274b51b862d63d3$var$androidTablet)),\n            device: !match($f274b51b862d63d3$var$windowsPhone) && (match($f274b51b862d63d3$var$amazonPhone) || match($f274b51b862d63d3$var$amazonTablet) || match($f274b51b862d63d3$var$androidPhone) || match($f274b51b862d63d3$var$androidTablet)) || match(/\\bokhttp\\b/i)\n        },\n        windows: {\n            phone: match($f274b51b862d63d3$var$windowsPhone),\n            tablet: match($f274b51b862d63d3$var$windowsTablet),\n            device: match($f274b51b862d63d3$var$windowsPhone) || match($f274b51b862d63d3$var$windowsTablet)\n        },\n        other: {\n            blackberry: match($f274b51b862d63d3$var$otherBlackBerry),\n            blackberry10: match($f274b51b862d63d3$var$otherBlackBerry10),\n            opera: match($f274b51b862d63d3$var$otherOpera),\n            firefox: match($f274b51b862d63d3$var$otherFirefox),\n            chrome: match($f274b51b862d63d3$var$otherChrome),\n            device: match($f274b51b862d63d3$var$otherBlackBerry) || match($f274b51b862d63d3$var$otherBlackBerry10) || match($f274b51b862d63d3$var$otherOpera) || match($f274b51b862d63d3$var$otherFirefox) || match($f274b51b862d63d3$var$otherChrome)\n        },\n        any: false,\n        phone: false,\n        tablet: false\n    };\n    result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;\n    result.phone = result.apple.phone || result.android.phone || result.windows.phone;\n    result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;\n    return result;\n}\n\n});\n\n\n\n\nparcelRegister(\"ftgKc\", function(module, exports) {\n\n$parcel$export(module.exports, \"accessibilityTarget\", () => $af15c2f7e43544d6$export$fd4b6e2c3e09104f);\n\"use strict\";\nconst $af15c2f7e43544d6$export$fd4b6e2c3e09104f = {\n    accessible: false,\n    accessibleTitle: null,\n    accessibleHint: null,\n    tabIndex: 0,\n    accessibleType: \"button\",\n    accessibleText: null,\n    accessiblePointerEvents: \"auto\",\n    accessibleChildren: true,\n    _accessibleActive: false,\n    _accessibleDiv: null,\n    _renderId: -1\n};\n\n});\n\n\nparcelRegister(\"4V3PX\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $39lGH = parcelRequire(\"39lGH\");\n\nvar $1XYIp = parcelRequire(\"1XYIp\");\n\nvar $f8xtB = parcelRequire(\"f8xtB\");\n\"use strict\";\n(0, $arnWa.extensions).add((0, $1XYIp.EventSystem));\n(0, $arnWa.extensions).mixin((0, $39lGH.Container), (0, $f8xtB.FederatedContainer));\n\n});\nparcelRegister(\"1XYIp\", function(module, exports) {\n\n$parcel$export(module.exports, \"EventSystem\", () => $343253f2585e0d1c$export$bf477d624b56bf15);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $lQTX9 = parcelRequire(\"lQTX9\");\n\nvar $j41U2 = parcelRequire(\"j41U2\");\n\nvar $gaPze = parcelRequire(\"gaPze\");\n\nvar $2tRWs = parcelRequire(\"2tRWs\");\n\"use strict\";\nconst $343253f2585e0d1c$var$MOUSE_POINTER_ID = 1;\nconst $343253f2585e0d1c$var$TOUCH_TO_POINTER = {\n    touchstart: \"pointerdown\",\n    touchend: \"pointerup\",\n    touchendoutside: \"pointerupoutside\",\n    touchmove: \"pointermove\",\n    touchcancel: \"pointercancel\"\n};\nconst $343253f2585e0d1c$var$_EventSystem = class _EventSystem {\n    /**\n   * @param {Renderer} renderer\n   */ constructor(renderer){\n        /**\n     * Indicates whether the current device supports touch events according to the W3C Touch Events spec.\n     * This is used to determine the appropriate event handling strategy.\n     * @see {@link https://www.w3.org/TR/touch-events/} W3C Touch Events Specification\n     * @readonly\n     * @default 'ontouchstart' in globalThis\n     */ this.supportsTouchEvents = \"ontouchstart\" in globalThis;\n        /**\n     * Indicates whether the current device supports pointer events according to the W3C Pointer Events spec.\n     * Used to optimize event handling and provide more consistent cross-device interaction.\n     * @see {@link https://www.w3.org/TR/pointerevents/} W3C Pointer Events Specification\n     * @readonly\n     * @default !!globalThis.PointerEvent\n     */ this.supportsPointerEvents = !!globalThis.PointerEvent;\n        /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link Renderer#view view}.\n     */ this.domElement = null;\n        /** The resolution used to convert between the DOM client space into world space. */ this.resolution = 1;\n        this.renderer = renderer;\n        this.rootBoundary = new (0, $lQTX9.EventBoundary)(null);\n        (0, $j41U2.EventsTicker).init(this);\n        this.autoPreventDefault = true;\n        this._eventsAdded = false;\n        this._rootPointerEvent = new (0, $gaPze.FederatedPointerEvent)(null);\n        this._rootWheelEvent = new (0, $2tRWs.FederatedWheelEvent)(null);\n        this.cursorStyles = {\n            default: \"inherit\",\n            pointer: \"pointer\"\n        };\n        this.features = new Proxy({\n            ..._EventSystem.defaultEventFeatures\n        }, {\n            set: (target, key, value)=>{\n                if (key === \"globalMove\") this.rootBoundary.enableGlobalMoveEvents = value;\n                target[key] = value;\n                return true;\n            }\n        });\n        this._onPointerDown = this._onPointerDown.bind(this);\n        this._onPointerMove = this._onPointerMove.bind(this);\n        this._onPointerUp = this._onPointerUp.bind(this);\n        this._onPointerOverOut = this._onPointerOverOut.bind(this);\n        this.onWheel = this.onWheel.bind(this);\n    }\n    /**\n   * The default interaction mode for all display objects.\n   * @see Container.eventMode\n   * @type {EventMode}\n   * @readonly\n   * @since 7.2.0\n   */ static get defaultEventMode() {\n        return this._defaultEventMode;\n    }\n    /**\n   * Runner init called, view is available at this point.\n   * @ignore\n   */ init(options) {\n        const { canvas: canvas, resolution: resolution } = this.renderer;\n        this.setTargetElement(canvas);\n        this.resolution = resolution;\n        _EventSystem._defaultEventMode = options.eventMode ?? \"passive\";\n        Object.assign(this.features, options.eventFeatures ?? {});\n        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n    }\n    /**\n   * Handle changing resolution.\n   * @ignore\n   */ resolutionChange(resolution) {\n        this.resolution = resolution;\n    }\n    /** Destroys all event listeners and detaches the renderer. */ destroy() {\n        this.setTargetElement(null);\n        this.renderer = null;\n        this._currentCursor = null;\n    }\n    /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.\n   * @param mode - Cursor mode to set. Can be:\n   * - A CSS cursor string (e.g., 'pointer', 'grab')\n   * - A key from the cursorStyles dictionary\n   * - null/undefined to reset to default\n   * @example\n   * ```ts\n   * // Using predefined cursor styles\n   * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor\n   * app.renderer.events.setCursor('grab');       // Set grab cursor\n   * app.renderer.events.setCursor(null);         // Reset to default\n   *\n   * // Using custom cursor styles\n   * app.renderer.events.cursorStyles.custom = 'url(\"cursor.png\"), auto';\n   * app.renderer.events.setCursor('custom');     // Apply custom cursor\n   *\n   * // Using callback-based cursor\n   * app.renderer.events.cursorStyles.dynamic = (mode) => {\n   *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';\n   * };\n   * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback\n   * ```\n   * @remarks\n   * - Has no effect on OffscreenCanvas except for callback-based cursors\n   * - Caches current cursor to avoid unnecessary DOM updates\n   * - Supports CSS cursor values, style objects, and callback functions\n   * @see {@link EventSystem.cursorStyles} For defining custom cursor styles\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference\n   */ setCursor(mode) {\n        mode || (mode = \"default\");\n        let applyStyles = true;\n        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) applyStyles = false;\n        if (this._currentCursor === mode) return;\n        this._currentCursor = mode;\n        const style = this.cursorStyles[mode];\n        if (style) switch(typeof style){\n            case \"string\":\n                if (applyStyles) this.domElement.style.cursor = style;\n                break;\n            case \"function\":\n                style(mode);\n                break;\n            case \"object\":\n                if (applyStyles) Object.assign(this.domElement.style, style);\n                break;\n        }\n        else if (applyStyles && typeof mode === \"string\" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) this.domElement.style.cursor = mode;\n    }\n    /**\n   * The global pointer event instance containing the most recent pointer state.\n   * This is useful for accessing pointer information without listening to events.\n   * @example\n   * ```ts\n   * // Access current pointer position at any time\n   * const eventSystem = app.renderer.events;\n   * const pointer = eventSystem.pointer;\n   *\n   * // Get global coordinates\n   * console.log('Position:', pointer.global.x, pointer.global.y);\n   *\n   * // Check button state\n   * console.log('Buttons pressed:', pointer.buttons);\n   *\n   * // Get pointer type and pressure\n   * console.log('Type:', pointer.pointerType);\n   * console.log('Pressure:', pointer.pressure);\n   * ```\n   * @readonly\n   * @since 7.2.0\n   * @see {@link FederatedPointerEvent} For all available pointer properties\n   */ get pointer() {\n        return this._rootPointerEvent;\n    }\n    /**\n   * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */ _onPointerDown(nativeEvent) {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        const events = this._normalizeToPointerData(nativeEvent);\n        if (this.autoPreventDefault && events[0].isNormalized) {\n            const cancelable = nativeEvent.cancelable || !(\"cancelable\" in nativeEvent);\n            if (cancelable) nativeEvent.preventDefault();\n        }\n        for(let i = 0, j = events.length; i < j; i++){\n            const nativeEvent2 = events[i];\n            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);\n            this.rootBoundary.mapEvent(federatedEvent);\n        }\n        this.setCursor(this.rootBoundary.cursor);\n    }\n    /**\n   * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch events.\n   */ _onPointerMove(nativeEvent) {\n        if (!this.features.move) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        (0, $j41U2.EventsTicker).pointerMoved();\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n        for(let i = 0, j = normalizedEvents.length; i < j; i++){\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n            this.rootBoundary.mapEvent(event);\n        }\n        this.setCursor(this.rootBoundary.cursor);\n    }\n    /**\n   * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */ _onPointerUp(nativeEvent) {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        let target = nativeEvent.target;\n        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) target = nativeEvent.composedPath()[0];\n        const outside = target !== this.domElement ? \"outside\" : \"\";\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n        for(let i = 0, j = normalizedEvents.length; i < j; i++){\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n            event.type += outside;\n            this.rootBoundary.mapEvent(event);\n        }\n        this.setCursor(this.rootBoundary.cursor);\n    }\n    /**\n   * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */ _onPointerOverOut(nativeEvent) {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n        for(let i = 0, j = normalizedEvents.length; i < j; i++){\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n            this.rootBoundary.mapEvent(event);\n        }\n        this.setCursor(this.rootBoundary.cursor);\n    }\n    /**\n   * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n   * @param nativeEvent - The native wheel event.\n   */ onWheel(nativeEvent) {\n        if (!this.features.wheel) return;\n        const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        this.rootBoundary.mapEvent(wheelEvent);\n    }\n    /**\n   * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n   * This method manages the DOM event bindings for the event system, allowing you to\n   * change or remove the target element that receives input events.\n   * > [!IMPORTANT] This will default to the canvas element of the renderer, so you\n   * > should not need to call this unless you are using a custom element.\n   * @param element - The new DOM element to bind events to, or null to remove all event bindings\n   * @example\n   * ```ts\n   * // Set a new canvas element as the target\n   * const canvas = document.createElement('canvas');\n   * app.renderer.events.setTargetElement(canvas);\n   *\n   * // Remove all event bindings\n   * app.renderer.events.setTargetElement(null);\n   *\n   * // Switch to a different canvas\n   * const newCanvas = document.querySelector('#game-canvas');\n   * app.renderer.events.setTargetElement(newCanvas);\n   * ```\n   * @remarks\n   * - Automatically removes event listeners from previous element\n   * - Required for the event system to function\n   * - Safe to call multiple times\n   * @see {@link EventSystem#domElement} The current DOM element\n   * @see {@link EventsTicker} For the ticker system that tracks pointer movement\n   */ setTargetElement(element) {\n        this._removeEvents();\n        this.domElement = element;\n        (0, $j41U2.EventsTicker).domElement = element;\n        this._addEvents();\n    }\n    /** Register event listeners on {@link Renderer#domElement this.domElement}. */ _addEvents() {\n        if (this._eventsAdded || !this.domElement) return;\n        (0, $j41U2.EventsTicker).addTickerListener();\n        const style = this.domElement.style;\n        if (style) {\n            if (globalThis.navigator.msPointerEnabled) {\n                style.msContentZooming = \"none\";\n                style.msTouchAction = \"none\";\n            } else if (this.supportsPointerEvents) style.touchAction = \"none\";\n        }\n        if (this.supportsPointerEvents) {\n            globalThis.document.addEventListener(\"pointermove\", this._onPointerMove, true);\n            this.domElement.addEventListener(\"pointerdown\", this._onPointerDown, true);\n            this.domElement.addEventListener(\"pointerleave\", this._onPointerOverOut, true);\n            this.domElement.addEventListener(\"pointerover\", this._onPointerOverOut, true);\n            globalThis.addEventListener(\"pointerup\", this._onPointerUp, true);\n        } else {\n            globalThis.document.addEventListener(\"mousemove\", this._onPointerMove, true);\n            this.domElement.addEventListener(\"mousedown\", this._onPointerDown, true);\n            this.domElement.addEventListener(\"mouseout\", this._onPointerOverOut, true);\n            this.domElement.addEventListener(\"mouseover\", this._onPointerOverOut, true);\n            globalThis.addEventListener(\"mouseup\", this._onPointerUp, true);\n            if (this.supportsTouchEvents) {\n                this.domElement.addEventListener(\"touchstart\", this._onPointerDown, true);\n                this.domElement.addEventListener(\"touchend\", this._onPointerUp, true);\n                this.domElement.addEventListener(\"touchmove\", this._onPointerMove, true);\n            }\n        }\n        this.domElement.addEventListener(\"wheel\", this.onWheel, {\n            passive: true,\n            capture: true\n        });\n        this._eventsAdded = true;\n    }\n    /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */ _removeEvents() {\n        if (!this._eventsAdded || !this.domElement) return;\n        (0, $j41U2.EventsTicker).removeTickerListener();\n        const style = this.domElement.style;\n        if (style) {\n            if (globalThis.navigator.msPointerEnabled) {\n                style.msContentZooming = \"\";\n                style.msTouchAction = \"\";\n            } else if (this.supportsPointerEvents) style.touchAction = \"\";\n        }\n        if (this.supportsPointerEvents) {\n            globalThis.document.removeEventListener(\"pointermove\", this._onPointerMove, true);\n            this.domElement.removeEventListener(\"pointerdown\", this._onPointerDown, true);\n            this.domElement.removeEventListener(\"pointerleave\", this._onPointerOverOut, true);\n            this.domElement.removeEventListener(\"pointerover\", this._onPointerOverOut, true);\n            globalThis.removeEventListener(\"pointerup\", this._onPointerUp, true);\n        } else {\n            globalThis.document.removeEventListener(\"mousemove\", this._onPointerMove, true);\n            this.domElement.removeEventListener(\"mousedown\", this._onPointerDown, true);\n            this.domElement.removeEventListener(\"mouseout\", this._onPointerOverOut, true);\n            this.domElement.removeEventListener(\"mouseover\", this._onPointerOverOut, true);\n            globalThis.removeEventListener(\"mouseup\", this._onPointerUp, true);\n            if (this.supportsTouchEvents) {\n                this.domElement.removeEventListener(\"touchstart\", this._onPointerDown, true);\n                this.domElement.removeEventListener(\"touchend\", this._onPointerUp, true);\n                this.domElement.removeEventListener(\"touchmove\", this._onPointerMove, true);\n            }\n        }\n        this.domElement.removeEventListener(\"wheel\", this.onWheel, true);\n        this.domElement = null;\n        this._eventsAdded = false;\n    }\n    /**\n   * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.\n   * This takes into account the current scale, position, and resolution of the DOM element.\n   * @param point - The point to store the mapped coordinates in\n   * @param x - The x coordinate in DOM/client space\n   * @param y - The y coordinate in DOM/client space\n   * @example\n   * ```ts\n   * // Map mouse coordinates to PixiJS space\n   * const point = new Point();\n   * app.renderer.events.mapPositionToPoint(\n   *     point,\n   *     event.clientX,\n   *     event.clientY\n   * );\n   * console.log('Mapped position:', point.x, point.y);\n   *\n   * // Using with pointer events\n   * sprite.on('pointermove', (event) => {\n   *     // event.global already contains mapped coordinates\n   *     console.log('Global:', event.global.x, event.global.y);\n   *\n   *     // Map to local coordinates\n   *     const local = event.getLocalPosition(sprite);\n   *     console.log('Local:', local.x, local.y);\n   * });\n   * ```\n   * @remarks\n   * - Accounts for element scaling and positioning\n   * - Adjusts for device pixel ratio/resolution\n   */ mapPositionToPoint(point, x, y) {\n        const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {\n            x: 0,\n            y: 0,\n            width: this.domElement.width,\n            height: this.domElement.height,\n            left: 0,\n            top: 0\n        };\n        const resolutionMultiplier = 1 / this.resolution;\n        point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;\n        point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;\n    }\n    /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   * @param event - The original event data from a touch or mouse event\n   * @returns An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */ _normalizeToPointerData(event) {\n        const normalizedEvents = [];\n        if (this.supportsTouchEvents && event instanceof TouchEvent) for(let i = 0, li = event.changedTouches.length; i < li; i++){\n            const touch = event.changedTouches[i];\n            if (typeof touch.button === \"undefined\") touch.button = 0;\n            if (typeof touch.buttons === \"undefined\") touch.buttons = 1;\n            if (typeof touch.isPrimary === \"undefined\") touch.isPrimary = event.touches.length === 1 && event.type === \"touchstart\";\n            if (typeof touch.width === \"undefined\") touch.width = touch.radiusX || 1;\n            if (typeof touch.height === \"undefined\") touch.height = touch.radiusY || 1;\n            if (typeof touch.tiltX === \"undefined\") touch.tiltX = 0;\n            if (typeof touch.tiltY === \"undefined\") touch.tiltY = 0;\n            if (typeof touch.pointerType === \"undefined\") touch.pointerType = \"touch\";\n            if (typeof touch.pointerId === \"undefined\") touch.pointerId = touch.identifier || 0;\n            if (typeof touch.pressure === \"undefined\") touch.pressure = touch.force || 0.5;\n            if (typeof touch.twist === \"undefined\") touch.twist = 0;\n            if (typeof touch.tangentialPressure === \"undefined\") touch.tangentialPressure = 0;\n            if (typeof touch.layerX === \"undefined\") touch.layerX = touch.offsetX = touch.clientX;\n            if (typeof touch.layerY === \"undefined\") touch.layerY = touch.offsetY = touch.clientY;\n            touch.isNormalized = true;\n            touch.type = event.type;\n            normalizedEvents.push(touch);\n        }\n        else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n            const tempEvent = event;\n            if (typeof tempEvent.isPrimary === \"undefined\") tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === \"undefined\") tempEvent.width = 1;\n            if (typeof tempEvent.height === \"undefined\") tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === \"undefined\") tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === \"undefined\") tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === \"undefined\") tempEvent.pointerType = \"mouse\";\n            if (typeof tempEvent.pointerId === \"undefined\") tempEvent.pointerId = $343253f2585e0d1c$var$MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === \"undefined\") tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === \"undefined\") tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === \"undefined\") tempEvent.tangentialPressure = 0;\n            tempEvent.isNormalized = true;\n            normalizedEvents.push(tempEvent);\n        } else normalizedEvents.push(event);\n        return normalizedEvents;\n    }\n    /**\n   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n   *\n   * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n   * multiple native wheel events.\n   * @param nativeEvent - The native wheel event that occurred on the canvas.\n   * @returns A federated wheel event.\n   */ normalizeWheelEvent(nativeEvent) {\n        const event = this._rootWheelEvent;\n        this._transferMouseData(event, nativeEvent);\n        event.deltaX = nativeEvent.deltaX;\n        event.deltaY = nativeEvent.deltaY;\n        event.deltaZ = nativeEvent.deltaZ;\n        event.deltaMode = nativeEvent.deltaMode;\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n        event.nativeEvent = nativeEvent;\n        event.type = nativeEvent.type;\n        return event;\n    }\n    /**\n   * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n   * @param event\n   * @param nativeEvent\n   */ _bootstrapEvent(event, nativeEvent) {\n        event.originalEvent = null;\n        event.nativeEvent = nativeEvent;\n        event.pointerId = nativeEvent.pointerId;\n        event.width = nativeEvent.width;\n        event.height = nativeEvent.height;\n        event.isPrimary = nativeEvent.isPrimary;\n        event.pointerType = nativeEvent.pointerType;\n        event.pressure = nativeEvent.pressure;\n        event.tangentialPressure = nativeEvent.tangentialPressure;\n        event.tiltX = nativeEvent.tiltX;\n        event.tiltY = nativeEvent.tiltY;\n        event.twist = nativeEvent.twist;\n        this._transferMouseData(event, nativeEvent);\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n        event.isTrusted = nativeEvent.isTrusted;\n        if (event.type === \"pointerleave\") event.type = \"pointerout\";\n        if (event.type.startsWith(\"mouse\")) event.type = event.type.replace(\"mouse\", \"pointer\");\n        if (event.type.startsWith(\"touch\")) event.type = $343253f2585e0d1c$var$TOUCH_TO_POINTER[event.type] || event.type;\n        return event;\n    }\n    /**\n   * Transfers base & mouse event data from the `nativeEvent` to the federated event.\n   * @param event\n   * @param nativeEvent\n   */ _transferMouseData(event, nativeEvent) {\n        event.isTrusted = nativeEvent.isTrusted;\n        event.srcElement = nativeEvent.srcElement;\n        event.timeStamp = performance.now();\n        event.type = nativeEvent.type;\n        event.altKey = nativeEvent.altKey;\n        event.button = nativeEvent.button;\n        event.buttons = nativeEvent.buttons;\n        event.client.x = nativeEvent.clientX;\n        event.client.y = nativeEvent.clientY;\n        event.ctrlKey = nativeEvent.ctrlKey;\n        event.metaKey = nativeEvent.metaKey;\n        event.movement.x = nativeEvent.movementX;\n        event.movement.y = nativeEvent.movementY;\n        event.page.x = nativeEvent.pageX;\n        event.page.y = nativeEvent.pageY;\n        event.relatedTarget = null;\n        event.shiftKey = nativeEvent.shiftKey;\n    }\n};\n/** @ignore */ $343253f2585e0d1c$var$_EventSystem.extension = {\n    name: \"events\",\n    type: [\n        (0, $arnWa.ExtensionType).WebGLSystem,\n        (0, $arnWa.ExtensionType).CanvasSystem,\n        (0, $arnWa.ExtensionType).WebGPUSystem\n    ],\n    priority: -1\n};\n/**\n * The event features that are enabled by the EventSystem\n * @since 7.2.0\n * @example\n * ```ts\n * import { EventSystem, EventSystemFeatures } from 'pixi.js';\n * // Access the default event features\n * EventSystem.defaultEventFeatures = {\n *     // Enable pointer movement events\n *     move: true,\n *     // Enable global pointer move events\n *     globalMove: true,\n *     // Enable click events\n *     click: true,\n *     // Enable wheel events\n *     wheel: true,\n * };\n * ```\n */ $343253f2585e0d1c$var$_EventSystem.defaultEventFeatures = {\n    /** Enables pointer events associated with pointer movement. */ move: true,\n    /** Enables global pointer move events. */ globalMove: true,\n    /** Enables pointer events associated with clicking. */ click: true,\n    /** Enables wheel events. */ wheel: true\n};\nlet $343253f2585e0d1c$export$bf477d624b56bf15 = $343253f2585e0d1c$var$_EventSystem;\n\n});\nparcelRegister(\"lQTX9\", function(module, exports) {\n\n$parcel$export(module.exports, \"EventBoundary\", () => $c7ca36a2eb4d0686$export$532e8c243078d2cd);\n\nvar $gpXaq = parcelRequire(\"gpXaq\");\n\nvar $gmxRF = parcelRequire(\"gmxRF\");\n\nvar $cODmL = parcelRequire(\"cODmL\");\n\nvar $j41U2 = parcelRequire(\"j41U2\");\n\nvar $1y6A0 = parcelRequire(\"1y6A0\");\n\nvar $gaPze = parcelRequire(\"gaPze\");\n\nvar $2tRWs = parcelRequire(\"2tRWs\");\n\"use strict\";\nconst $c7ca36a2eb4d0686$var$PROPAGATION_LIMIT = 2048;\nconst $c7ca36a2eb4d0686$var$tempHitLocation = new (0, $gmxRF.Point)();\nconst $c7ca36a2eb4d0686$var$tempLocalMapping = new (0, $gmxRF.Point)();\nclass $c7ca36a2eb4d0686$export$532e8c243078d2cd {\n    /**\n   * @param rootTarget - The holder of the event boundary.\n   */ constructor(rootTarget){\n        /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */ this.dispatch = new (0, (/*@__PURE__*/$parcel$interopDefault($gpXaq)))();\n        /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */ this.moveOnAll = false;\n        /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */ this.enableGlobalMoveEvents = true;\n        /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */ this.mappingState = {\n            trackingData: {}\n        };\n        /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */ this.eventPool = /* @__PURE__ */ new Map();\n        /** Every interactive element gathered from the scene. Only used in `pointermove` */ this._allInteractiveElements = [];\n        /** Every element that passed the hit test. Only used in `pointermove` */ this._hitElements = [];\n        /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */ this._isPointerMoveEvent = false;\n        this.rootTarget = rootTarget;\n        this.hitPruneFn = this.hitPruneFn.bind(this);\n        this.hitTestFn = this.hitTestFn.bind(this);\n        this.mapPointerDown = this.mapPointerDown.bind(this);\n        this.mapPointerMove = this.mapPointerMove.bind(this);\n        this.mapPointerOut = this.mapPointerOut.bind(this);\n        this.mapPointerOver = this.mapPointerOver.bind(this);\n        this.mapPointerUp = this.mapPointerUp.bind(this);\n        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n        this.mapWheel = this.mapWheel.bind(this);\n        this.mappingTable = {};\n        this.addEventMapping(\"pointerdown\", this.mapPointerDown);\n        this.addEventMapping(\"pointermove\", this.mapPointerMove);\n        this.addEventMapping(\"pointerout\", this.mapPointerOut);\n        this.addEventMapping(\"pointerleave\", this.mapPointerOut);\n        this.addEventMapping(\"pointerover\", this.mapPointerOver);\n        this.addEventMapping(\"pointerup\", this.mapPointerUp);\n        this.addEventMapping(\"pointerupoutside\", this.mapPointerUpOutside);\n        this.addEventMapping(\"wheel\", this.mapWheel);\n    }\n    /**\n   * Adds an event mapping for the event `type` handled by `fn`.\n   *\n   * Event mappings can be used to implement additional or custom events. They take an event\n   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n   *\n   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n   * instead.\n   * @param type - The type of upstream event to map.\n   * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n   */ addEventMapping(type, fn) {\n        if (!this.mappingTable[type]) this.mappingTable[type] = [];\n        this.mappingTable[type].push({\n            fn: fn,\n            priority: 0\n        });\n        this.mappingTable[type].sort((a, b)=>a.priority - b.priority);\n    }\n    /**\n   * Dispatches the given event\n   * @param e - The event to dispatch.\n   * @param type - The type of event to dispatch. Defaults to `e.type`.\n   */ dispatchEvent(e, type) {\n        e.propagationStopped = false;\n        e.propagationImmediatelyStopped = false;\n        this.propagate(e, type);\n        this.dispatch.emit(type || e.type, e);\n    }\n    /**\n   * Maps the given upstream event through the event boundary and propagates it downstream.\n   * @param e - The event to map.\n   */ mapEvent(e) {\n        if (!this.rootTarget) return;\n        const mappers = this.mappingTable[e.type];\n        if (mappers) for(let i = 0, j = mappers.length; i < j; i++)mappers[i].fn(e);\n        else (0, $cODmL.warn)(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n    }\n    /**\n   * Finds the Container that is the target of a event at the given coordinates.\n   *\n   * The passed (x,y) coordinates are in the world space above this event boundary.\n   * @param x - The x coordinate of the event.\n   * @param y - The y coordinate of the event.\n   */ hitTest(x, y) {\n        (0, $j41U2.EventsTicker).pauseUpdate = true;\n        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n        const fn = useMove ? \"hitTestMoveRecursive\" : \"hitTestRecursive\";\n        const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, $c7ca36a2eb4d0686$var$tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn);\n        return invertedPath && invertedPath[0];\n    }\n    /**\n   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n   * target `e.target`.\n   * @param e - The event to propagate.\n   * @param type - The type of event to propagate. Defaults to `e.type`.\n   */ propagate(e, type) {\n        if (!e.target) return;\n        const composedPath = e.composedPath();\n        e.eventPhase = e.CAPTURING_PHASE;\n        for(let i = 0, j = composedPath.length - 1; i < j; i++){\n            e.currentTarget = composedPath[i];\n            this.notifyTarget(e, type);\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n        e.eventPhase = e.AT_TARGET;\n        e.currentTarget = e.target;\n        this.notifyTarget(e, type);\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        e.eventPhase = e.BUBBLING_PHASE;\n        for(let i = composedPath.length - 2; i >= 0; i--){\n            e.currentTarget = composedPath[i];\n            this.notifyTarget(e, type);\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n    /**\n   * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.\n   *\n   * This is used in the `globalpointermove` event.\n   * @param e - The emitted event.\n   * @param type - The listeners to notify.\n   * @param targets - The targets to notify.\n   */ all(e, type, targets = this._allInteractiveElements) {\n        if (targets.length === 0) return;\n        e.eventPhase = e.BUBBLING_PHASE;\n        const events = Array.isArray(type) ? type : [\n            type\n        ];\n        for(let i = targets.length - 1; i >= 0; i--)events.forEach((event)=>{\n            e.currentTarget = targets[i];\n            this.notifyTarget(e, event);\n        });\n    }\n    /**\n   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n   * `target`. The last element in the path is `target`.\n   * @param target - The target to find the propagation path to.\n   */ propagationPath(target) {\n        const propagationPath = [\n            target\n        ];\n        for(let i = 0; i < $c7ca36a2eb4d0686$var$PROPAGATION_LIMIT && target !== this.rootTarget && target.parent; i++){\n            if (!target.parent) throw new Error(\"Cannot find propagation path to disconnected target\");\n            propagationPath.push(target.parent);\n            target = target.parent;\n        }\n        propagationPath.reverse();\n        return propagationPath;\n    }\n    hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {\n        let shouldReturn = false;\n        if (this._interactivePrune(currentTarget)) return null;\n        if (currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") (0, $j41U2.EventsTicker).pauseUpdate = false;\n        if (currentTarget.interactiveChildren && currentTarget.children) {\n            const children = currentTarget.children;\n            for(let i = children.length - 1; i >= 0; i--){\n                const child = children[i];\n                const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location));\n                if (nestedHit) {\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) continue;\n                    const isInteractive = currentTarget.isInteractive();\n                    if (nestedHit.length > 0 || isInteractive) {\n                        if (isInteractive) this._allInteractiveElements.push(currentTarget);\n                        nestedHit.push(currentTarget);\n                    }\n                    if (this._hitElements.length === 0) this._hitElements = nestedHit;\n                    shouldReturn = true;\n                }\n            }\n        }\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n        if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);\n        if (ignore || this._hitElements.length > 0) return null;\n        if (shouldReturn) return this._hitElements;\n        if (isInteractiveMode && !pruneFn(currentTarget, location) && testFn(currentTarget, location)) return isInteractiveTarget ? [\n            currentTarget\n        ] : [];\n        return null;\n    }\n    /**\n   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n   * @param currentTarget - The Container that is to be hit tested.\n   * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n   * @param location - The location that is being tested for overlap.\n   * @param testFn - Callback that determines whether the target passes hit testing. This callback\n   *  can assume that `pruneFn` failed to prune the container.\n   * @param pruneFn - Callback that determiness whether the target and all of its children\n   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n   *  of the scene graph.\n   * @returns An array holding the hit testing target and all its ancestors in order. The first element\n   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n   */ hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) return null;\n        if (currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") (0, $j41U2.EventsTicker).pauseUpdate = false;\n        if (currentTarget.interactiveChildren && currentTarget.children) {\n            const children = currentTarget.children;\n            const relativeLocation = location;\n            for(let i = children.length - 1; i >= 0; i--){\n                const child = children[i];\n                const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, relativeLocation, testFn, pruneFn);\n                if (nestedHit) {\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) continue;\n                    const isInteractive = currentTarget.isInteractive();\n                    if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);\n                    return nestedHit;\n                }\n            }\n        }\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n        if (isInteractiveMode && testFn(currentTarget, location)) return isInteractiveTarget ? [\n            currentTarget\n        ] : [];\n        return null;\n    }\n    _isInteractive(int) {\n        return int === \"static\" || int === \"dynamic\";\n    }\n    _interactivePrune(container) {\n        if (!container || !container.visible || !container.renderable || !container.measurable) return true;\n        if (container.eventMode === \"none\") return true;\n        if (container.eventMode === \"passive\" && !container.interactiveChildren) return true;\n        return false;\n    }\n    /**\n   * Checks whether the container or any of its children cannot pass the hit test at all.\n   *\n   * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n   * and {@link Container._maskEffect} for pruning.\n   * @param container - The container to prune.\n   * @param location - The location to test for overlap.\n   */ hitPruneFn(container, location) {\n        if (container.hitArea) {\n            container.worldTransform.applyInverse(location, $c7ca36a2eb4d0686$var$tempLocalMapping);\n            if (!container.hitArea.contains($c7ca36a2eb4d0686$var$tempLocalMapping.x, $c7ca36a2eb4d0686$var$tempLocalMapping.y)) return true;\n        }\n        if (container.effects && container.effects.length) for(let i = 0; i < container.effects.length; i++){\n            const effect = container.effects[i];\n            if (effect.containsPoint) {\n                const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n                if (!effectContainsPoint) return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * Checks whether the container passes hit testing for the given location.\n   * @param container - The container to test.\n   * @param location - The location to test for overlap.\n   * @returns - Whether `container` passes hit testing for `location`.\n   */ hitTestFn(container, location) {\n        if (container.hitArea) return true;\n        if (container?.containsPoint) {\n            container.worldTransform.applyInverse(location, $c7ca36a2eb4d0686$var$tempLocalMapping);\n            return container.containsPoint($c7ca36a2eb4d0686$var$tempLocalMapping);\n        }\n        return false;\n    }\n    /**\n   * Notify all the listeners to the event's `currentTarget`.\n   *\n   * If the `currentTarget` contains the property `on<type>`, then it is called here,\n   * simulating the behavior from version 6.x and prior.\n   * @param e - The event passed to the target.\n   * @param type - The type of event to notify. Defaults to `e.type`.\n   */ notifyTarget(e, type) {\n        if (!e.currentTarget.isInteractive()) return;\n        type ?? (type = e.type);\n        const handlerKey = `on${type}`;\n        e.currentTarget[handlerKey]?.(e);\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n        this._notifyListeners(e, key);\n        if (e.eventPhase === e.AT_TARGET) this._notifyListeners(e, type);\n    }\n    /**\n   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n   *\n   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n   * @param from - The upstream `pointerdown` event.\n   */ mapPointerDown(from) {\n        if (!(from instanceof (0, $gaPze.FederatedPointerEvent))) {\n            (0, $cODmL.warn)(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n            return;\n        }\n        const e = this.createPointerEvent(from);\n        this.dispatchEvent(e, \"pointerdown\");\n        if (e.pointerType === \"touch\") this.dispatchEvent(e, \"touchstart\");\n        else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n            const isRightButton = e.button === 2;\n            this.dispatchEvent(e, isRightButton ? \"rightdown\" : \"mousedown\");\n        }\n        const trackingData = this.trackingData(from.pointerId);\n        trackingData.pressTargetsByButton[from.button] = e.composedPath();\n        this.freeEvent(e);\n    }\n    /**\n   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n   *\n   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n   * @param from - The upstream `pointermove` event.\n   */ mapPointerMove(from) {\n        if (!(from instanceof (0, $gaPze.FederatedPointerEvent))) {\n            (0, $cODmL.warn)(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n            return;\n        }\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n        this._isPointerMoveEvent = true;\n        const e = this.createPointerEvent(from);\n        this._isPointerMoveEvent = false;\n        const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n        const trackingData = this.trackingData(from.pointerId);\n        const outTarget = this.findMountedTarget(trackingData.overTargets);\n        if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {\n            const outType = from.type === \"mousemove\" ? \"mouseout\" : \"pointerout\";\n            const outEvent = this.createPointerEvent(from, outType, outTarget);\n            this.dispatchEvent(outEvent, \"pointerout\");\n            if (isMouse) this.dispatchEvent(outEvent, \"mouseout\");\n            if (!e.composedPath().includes(outTarget)) {\n                const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n                while(leaveEvent.target && !e.composedPath().includes(leaveEvent.target)){\n                    leaveEvent.currentTarget = leaveEvent.target;\n                    this.notifyTarget(leaveEvent);\n                    if (isMouse) this.notifyTarget(leaveEvent, \"mouseleave\");\n                    leaveEvent.target = leaveEvent.target.parent;\n                }\n                this.freeEvent(leaveEvent);\n            }\n            this.freeEvent(outEvent);\n        }\n        if (outTarget !== e.target) {\n            const overType = from.type === \"mousemove\" ? \"mouseover\" : \"pointerover\";\n            const overEvent = this.clonePointerEvent(e, overType);\n            this.dispatchEvent(overEvent, \"pointerover\");\n            if (isMouse) this.dispatchEvent(overEvent, \"mouseover\");\n            let overTargetAncestor = outTarget?.parent;\n            while(overTargetAncestor && overTargetAncestor !== this.rootTarget.parent){\n                if (overTargetAncestor === e.target) break;\n                overTargetAncestor = overTargetAncestor.parent;\n            }\n            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n            if (didPointerEnter) {\n                const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n                enterEvent.eventPhase = enterEvent.AT_TARGET;\n                while(enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent){\n                    enterEvent.currentTarget = enterEvent.target;\n                    this.notifyTarget(enterEvent);\n                    if (isMouse) this.notifyTarget(enterEvent, \"mouseenter\");\n                    enterEvent.target = enterEvent.target.parent;\n                }\n                this.freeEvent(enterEvent);\n            }\n            this.freeEvent(overEvent);\n        }\n        const allMethods = [];\n        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n        this.moveOnAll ? allMethods.push(\"pointermove\") : this.dispatchEvent(e, \"pointermove\");\n        allowGlobalPointerEvents && allMethods.push(\"globalpointermove\");\n        if (e.pointerType === \"touch\") {\n            this.moveOnAll ? allMethods.splice(1, 0, \"touchmove\") : this.dispatchEvent(e, \"touchmove\");\n            allowGlobalPointerEvents && allMethods.push(\"globaltouchmove\");\n        }\n        if (isMouse) {\n            this.moveOnAll ? allMethods.splice(1, 0, \"mousemove\") : this.dispatchEvent(e, \"mousemove\");\n            allowGlobalPointerEvents && allMethods.push(\"globalmousemove\");\n            this.cursor = e.target?.cursor;\n        }\n        if (allMethods.length > 0) this.all(e, allMethods);\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n        trackingData.overTargets = e.composedPath();\n        this.freeEvent(e);\n    }\n    /**\n   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n   *\n   * The tracking data for the specific pointer gets a new `overTarget`.\n   * @param from - The upstream `pointerover` event.\n   */ mapPointerOver(from) {\n        if (!(from instanceof (0, $gaPze.FederatedPointerEvent))) {\n            (0, $cODmL.warn)(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n            return;\n        }\n        const trackingData = this.trackingData(from.pointerId);\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n        this.dispatchEvent(e, \"pointerover\");\n        if (isMouse) this.dispatchEvent(e, \"mouseover\");\n        if (e.pointerType === \"mouse\") this.cursor = e.target?.cursor;\n        const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n        while(enterEvent.target && enterEvent.target !== this.rootTarget.parent){\n            enterEvent.currentTarget = enterEvent.target;\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, \"mouseenter\");\n            enterEvent.target = enterEvent.target.parent;\n        }\n        trackingData.overTargets = e.composedPath();\n        this.freeEvent(e);\n        this.freeEvent(enterEvent);\n    }\n    /**\n   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n   *\n   * The tracking data for the specific pointer is cleared of a `overTarget`.\n   * @param from - The upstream `pointerout` event.\n   */ mapPointerOut(from) {\n        if (!(from instanceof (0, $gaPze.FederatedPointerEvent))) {\n            (0, $cODmL.warn)(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n            return;\n        }\n        const trackingData = this.trackingData(from.pointerId);\n        if (trackingData.overTargets) {\n            const isMouse = from.pointerType === \"mouse\" || from.pointerType === \"pen\";\n            const outTarget = this.findMountedTarget(trackingData.overTargets);\n            const outEvent = this.createPointerEvent(from, \"pointerout\", outTarget);\n            this.dispatchEvent(outEvent);\n            if (isMouse) this.dispatchEvent(outEvent, \"mouseout\");\n            const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n            leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n            while(leaveEvent.target && leaveEvent.target !== this.rootTarget.parent){\n                leaveEvent.currentTarget = leaveEvent.target;\n                this.notifyTarget(leaveEvent);\n                if (isMouse) this.notifyTarget(leaveEvent, \"mouseleave\");\n                leaveEvent.target = leaveEvent.target.parent;\n            }\n            trackingData.overTargets = null;\n            this.freeEvent(outEvent);\n            this.freeEvent(leaveEvent);\n        }\n        this.cursor = null;\n    }\n    /**\n   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n   * and `click`/`rightclick`/`pointertap` events, in that order.\n   *\n   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n   * specific pointer types.\n   * @param from - The upstream `pointerup` event.\n   */ mapPointerUp(from) {\n        if (!(from instanceof (0, $gaPze.FederatedPointerEvent))) {\n            (0, $cODmL.warn)(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n            return;\n        }\n        const now = performance.now();\n        const e = this.createPointerEvent(from);\n        this.dispatchEvent(e, \"pointerup\");\n        if (e.pointerType === \"touch\") this.dispatchEvent(e, \"touchend\");\n        else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n            const isRightButton = e.button === 2;\n            this.dispatchEvent(e, isRightButton ? \"rightup\" : \"mouseup\");\n        }\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        let clickTarget = pressTarget;\n        if (pressTarget && !e.composedPath().includes(pressTarget)) {\n            let currentTarget = pressTarget;\n            while(currentTarget && !e.composedPath().includes(currentTarget)){\n                e.currentTarget = currentTarget;\n                this.notifyTarget(e, \"pointerupoutside\");\n                if (e.pointerType === \"touch\") this.notifyTarget(e, \"touchendoutside\");\n                else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n                    const isRightButton = e.button === 2;\n                    this.notifyTarget(e, isRightButton ? \"rightupoutside\" : \"mouseupoutside\");\n                }\n                currentTarget = currentTarget.parent;\n            }\n            delete trackingData.pressTargetsByButton[from.button];\n            clickTarget = currentTarget;\n        }\n        if (clickTarget) {\n            const clickEvent = this.clonePointerEvent(e, \"click\");\n            clickEvent.target = clickTarget;\n            clickEvent.path = null;\n            if (!trackingData.clicksByButton[from.button]) trackingData.clicksByButton[from.button] = {\n                clickCount: 0,\n                target: clickEvent.target,\n                timeStamp: now\n            };\n            const clickHistory = trackingData.clicksByButton[from.button];\n            if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) ++clickHistory.clickCount;\n            else clickHistory.clickCount = 1;\n            clickHistory.target = clickEvent.target;\n            clickHistory.timeStamp = now;\n            clickEvent.detail = clickHistory.clickCount;\n            if (clickEvent.pointerType === \"mouse\") {\n                const isRightButton = clickEvent.button === 2;\n                this.dispatchEvent(clickEvent, isRightButton ? \"rightclick\" : \"click\");\n            } else if (clickEvent.pointerType === \"touch\") this.dispatchEvent(clickEvent, \"tap\");\n            this.dispatchEvent(clickEvent, \"pointertap\");\n            this.freeEvent(clickEvent);\n        }\n        this.freeEvent(e);\n    }\n    /**\n   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n   * `pointerdown` target to `rootTarget`.\n   *\n   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n   * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n   *\n   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n   * @param from - The upstream `pointerupoutside` event.\n   */ mapPointerUpOutside(from) {\n        if (!(from instanceof (0, $gaPze.FederatedPointerEvent))) {\n            (0, $cODmL.warn)(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n            return;\n        }\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        const e = this.createPointerEvent(from);\n        if (pressTarget) {\n            let currentTarget = pressTarget;\n            while(currentTarget){\n                e.currentTarget = currentTarget;\n                this.notifyTarget(e, \"pointerupoutside\");\n                if (e.pointerType === \"touch\") this.notifyTarget(e, \"touchendoutside\");\n                else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") this.notifyTarget(e, e.button === 2 ? \"rightupoutside\" : \"mouseupoutside\");\n                currentTarget = currentTarget.parent;\n            }\n            delete trackingData.pressTargetsByButton[from.button];\n        }\n        this.freeEvent(e);\n    }\n    /**\n   * Maps the upstream `wheel` event to a downstream `wheel` event.\n   * @param from - The upstream `wheel` event.\n   */ mapWheel(from) {\n        if (!(from instanceof (0, $2tRWs.FederatedWheelEvent))) {\n            (0, $cODmL.warn)(\"EventBoundary cannot map a non-wheel event as a wheel event\");\n            return;\n        }\n        const wheelEvent = this.createWheelEvent(from);\n        this.dispatchEvent(wheelEvent);\n        this.freeEvent(wheelEvent);\n    }\n    /**\n   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n   *\n   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n   * or `pointerover` target was unmounted from the scene graph.\n   * @param propagationPath - The propagation path was valid in the past.\n   * @returns - The most specific event-target still mounted at the same location in the scene graph.\n   */ findMountedTarget(propagationPath) {\n        if (!propagationPath) return null;\n        let currentTarget = propagationPath[0];\n        for(let i = 1; i < propagationPath.length; i++){\n            if (propagationPath[i].parent === currentTarget) currentTarget = propagationPath[i];\n            else break;\n        }\n        return currentTarget;\n    }\n    /**\n   * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The `originalEvent` for the returned event.\n   * @param [type=from.type] - The type of the returned event.\n   * @param target - The target of the returned event.\n   */ createPointerEvent(from, type, target) {\n        const event = this.allocateEvent((0, $gaPze.FederatedPointerEvent));\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];\n        if (typeof type === \"string\") event.type = type;\n        return event;\n    }\n    /**\n   * Creates a wheel event whose `originalEvent` is `from`.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The upstream wheel event.\n   */ createWheelEvent(from) {\n        const event = this.allocateEvent((0, $2tRWs.FederatedWheelEvent));\n        this.copyWheelData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = this.hitTest(event.global.x, event.global.y);\n        return event;\n    }\n    /**\n   * Clones the event `from`, with an optional `type` override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The event to clone.\n   * @param [type=from.type] - The type of the returned event.\n   */ clonePointerEvent(from, type) {\n        const event = this.allocateEvent((0, $gaPze.FederatedPointerEvent));\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from.originalEvent;\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n        event.target = from.target;\n        event.path = from.composedPath().slice();\n        event.type = type ?? event.type;\n        return event;\n    }\n    /**\n   * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.\n   *\n   * The following properties are copied:\n   * + deltaMode\n   * + deltaX\n   * + deltaY\n   * + deltaZ\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */ copyWheelData(from, to) {\n        to.deltaMode = from.deltaMode;\n        to.deltaX = from.deltaX;\n        to.deltaY = from.deltaY;\n        to.deltaZ = from.deltaZ;\n    }\n    /**\n   * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.\n   *\n   * The following properties are copied:\n   * + pointerId\n   * + width\n   * + height\n   * + isPrimary\n   * + pointerType\n   * + pressure\n   * + tangentialPressure\n   * + tiltX\n   * + tiltY\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */ copyPointerData(from, to) {\n        if (!(from instanceof (0, $gaPze.FederatedPointerEvent) && to instanceof (0, $gaPze.FederatedPointerEvent))) return;\n        to.pointerId = from.pointerId;\n        to.width = from.width;\n        to.height = from.height;\n        to.isPrimary = from.isPrimary;\n        to.pointerType = from.pointerType;\n        to.pressure = from.pressure;\n        to.tangentialPressure = from.tangentialPressure;\n        to.tiltX = from.tiltX;\n        to.tiltY = from.tiltY;\n        to.twist = from.twist;\n    }\n    /**\n   * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.\n   *\n   * The following properties are copied:\n   * + altKey\n   * + button\n   * + buttons\n   * + clientX\n   * + clientY\n   * + metaKey\n   * + movementX\n   * + movementY\n   * + pageX\n   * + pageY\n   * + x\n   * + y\n   * + screen\n   * + shiftKey\n   * + global\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */ copyMouseData(from, to) {\n        if (!(from instanceof (0, $1y6A0.FederatedMouseEvent) && to instanceof (0, $1y6A0.FederatedMouseEvent))) return;\n        to.altKey = from.altKey;\n        to.button = from.button;\n        to.buttons = from.buttons;\n        to.client.copyFrom(from.client);\n        to.ctrlKey = from.ctrlKey;\n        to.metaKey = from.metaKey;\n        to.movement.copyFrom(from.movement);\n        to.screen.copyFrom(from.screen);\n        to.shiftKey = from.shiftKey;\n        to.global.copyFrom(from.global);\n    }\n    /**\n   * Copies base {@link FederatedEvent} data from `from` into `to`.\n   *\n   * The following properties are copied:\n   * + isTrusted\n   * + srcElement\n   * + timeStamp\n   * + type\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */ copyData(from, to) {\n        to.isTrusted = from.isTrusted;\n        to.srcElement = from.srcElement;\n        to.timeStamp = performance.now();\n        to.type = from.type;\n        to.detail = from.detail;\n        to.view = from.view;\n        to.which = from.which;\n        to.layer.copyFrom(from.layer);\n        to.page.copyFrom(from.page);\n    }\n    /**\n   * @param id - The pointer ID.\n   * @returns The tracking data stored for the given pointer. If no data exists, a blank\n   *  state will be created.\n   */ trackingData(id) {\n        if (!this.mappingState.trackingData[id]) this.mappingState.trackingData[id] = {\n            pressTargetsByButton: {},\n            clicksByButton: {},\n            overTarget: null\n        };\n        return this.mappingState.trackingData[id];\n    }\n    /**\n   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n   *\n   * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n   * boundary.\n   * @param constructor - The event's constructor.\n   */ allocateEvent(constructor) {\n        if (!this.eventPool.has(constructor)) this.eventPool.set(constructor, []);\n        const event = this.eventPool.get(constructor).pop() || new constructor(this);\n        event.eventPhase = event.NONE;\n        event.currentTarget = null;\n        event.defaultPrevented = false;\n        event.path = null;\n        event.target = null;\n        return event;\n    }\n    /**\n   * Frees the event and puts it back into the event pool.\n   *\n   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n   *\n   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n   * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n   * it to be allocated twice & result in overwriting.\n   * @param event - The event to be freed.\n   * @throws Error if the event is managed by another event boundary.\n   */ freeEvent(event) {\n        if (event.manager !== this) throw new Error(\"It is illegal to free an event not managed by this EventBoundary!\");\n        const constructor = event.constructor;\n        if (!this.eventPool.has(constructor)) this.eventPool.set(constructor, []);\n        this.eventPool.get(constructor).push(event);\n    }\n    /**\n   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n   * is set on the event.\n   * @param e - The event to call each listener with.\n   * @param type - The event key.\n   */ _notifyListeners(e, type) {\n        const listeners = e.currentTarget._events[type];\n        if (!listeners) return;\n        if (\"fn\" in listeners) {\n            if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, void 0, true);\n            listeners.fn.call(listeners.context, e);\n        } else for(let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++){\n            if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);\n            listeners[i].fn.call(listeners[i].context, e);\n        }\n    }\n}\n\n});\nparcelRegister(\"j41U2\", function(module, exports) {\n\n$parcel$export(module.exports, \"EventsTicker\", () => $75701bf9f630df0d$export$57a493ed609e53ea);\n\nvar $kfZeU = parcelRequire(\"kfZeU\");\n\nvar $7LZE9 = parcelRequire(\"7LZE9\");\n\"use strict\";\nclass $75701bf9f630df0d$var$EventsTickerClass {\n    constructor(){\n        /** The frequency that fake events will be fired. */ this.interactionFrequency = 10;\n        this._deltaTime = 0;\n        this._didMove = false;\n        this._tickerAdded = false;\n        this._pauseUpdate = true;\n    }\n    /**\n   * Initializes the event ticker.\n   * @param events - The event system.\n   */ init(events) {\n        this.removeTickerListener();\n        this.events = events;\n        this.interactionFrequency = 10;\n        this._deltaTime = 0;\n        this._didMove = false;\n        this._tickerAdded = false;\n        this._pauseUpdate = true;\n    }\n    /** Whether to pause the update checks or not. */ get pauseUpdate() {\n        return this._pauseUpdate;\n    }\n    set pauseUpdate(paused) {\n        this._pauseUpdate = paused;\n    }\n    /** Adds the ticker listener. */ addTickerListener() {\n        if (this._tickerAdded || !this.domElement) return;\n        (0, $7LZE9.Ticker).system.add(this._tickerUpdate, this, (0, $kfZeU.UPDATE_PRIORITY).INTERACTION);\n        this._tickerAdded = true;\n    }\n    /** Removes the ticker listener. */ removeTickerListener() {\n        if (!this._tickerAdded) return;\n        (0, $7LZE9.Ticker).system.remove(this._tickerUpdate, this);\n        this._tickerAdded = false;\n    }\n    /** Sets flag to not fire extra events when the user has already moved there mouse */ pointerMoved() {\n        this._didMove = true;\n    }\n    /** Updates the state of interactive objects. */ _update() {\n        if (!this.domElement || this._pauseUpdate) return;\n        if (this._didMove) {\n            this._didMove = false;\n            return;\n        }\n        const rootPointerEvent = this.events[\"_rootPointerEvent\"];\n        if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === \"touch\") return;\n        globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent(\"pointermove\", {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY,\n            pointerType: rootPointerEvent.pointerType,\n            pointerId: rootPointerEvent.pointerId\n        }) : new MouseEvent(\"mousemove\", {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY\n        }));\n    }\n    /**\n   * Updates the state of interactive objects if at least {@link interactionFrequency}\n   * milliseconds have passed since the last invocation.\n   *\n   * Invoked by a throttled ticker update from {@link Ticker.system}.\n   * @param ticker - The throttled ticker.\n   */ _tickerUpdate(ticker) {\n        this._deltaTime += ticker.deltaTime;\n        if (this._deltaTime < this.interactionFrequency) return;\n        this._deltaTime = 0;\n        this._update();\n    }\n}\nconst $75701bf9f630df0d$export$57a493ed609e53ea = new $75701bf9f630df0d$var$EventsTickerClass();\n\n});\n\nparcelRegister(\"1y6A0\", function(module, exports) {\n\n$parcel$export(module.exports, \"FederatedMouseEvent\", () => $968a1335872aaa6e$export$aeb79caab92d155a);\n\nvar $gmxRF = parcelRequire(\"gmxRF\");\n\nvar $1KB1X = parcelRequire(\"1KB1X\");\n\"use strict\";\nclass $968a1335872aaa6e$export$aeb79caab92d155a extends (0, $1KB1X.FederatedEvent) {\n    constructor(){\n        super(...arguments);\n        /** The coordinates of the mouse event relative to the canvas. */ this.client = new (0, $gmxRF.Point)();\n        /** The movement in this pointer relative to the last `mousemove` event. */ this.movement = new (0, $gmxRF.Point)();\n        /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */ this.offset = new (0, $gmxRF.Point)();\n        /** The pointer coordinates in world space. */ this.global = new (0, $gmxRF.Point)();\n        /**\n     * The pointer coordinates in the renderer's {@link AbstractRenderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */ this.screen = new (0, $gmxRF.Point)();\n    }\n    /** @readonly */ get clientX() {\n        return this.client.x;\n    }\n    /** @readonly */ get clientY() {\n        return this.client.y;\n    }\n    /**\n   * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n   * @readonly\n   */ get x() {\n        return this.clientX;\n    }\n    /**\n   * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n   * @readonly\n   */ get y() {\n        return this.clientY;\n    }\n    /** @readonly */ get movementX() {\n        return this.movement.x;\n    }\n    /** @readonly */ get movementY() {\n        return this.movement.y;\n    }\n    /** @readonly */ get offsetX() {\n        return this.offset.x;\n    }\n    /** @readonly */ get offsetY() {\n        return this.offset.y;\n    }\n    /** @readonly */ get globalX() {\n        return this.global.x;\n    }\n    /** @readonly */ get globalY() {\n        return this.global.y;\n    }\n    /**\n   * The pointer coordinates in the renderer's screen. Alias for `screen.x`.\n   * @readonly\n   */ get screenX() {\n        return this.screen.x;\n    }\n    /**\n   * The pointer coordinates in the renderer's screen. Alias for `screen.y`.\n   * @readonly\n   */ get screenY() {\n        return this.screen.y;\n    }\n    /**\n   * Converts global coordinates into container-local coordinates.\n   *\n   * This method transforms coordinates from world space to a container's local space,\n   * useful for precise positioning and hit testing.\n   * @param container - The Container to get local coordinates for\n   * @param point - Optional Point object to store the result. If not provided, a new Point will be created\n   * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used\n   * @returns The local coordinates as a Point object\n   * @example\n   * ```ts\n   * // Basic usage - get local coordinates relative to a container\n   * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n   *     // Get position relative to the sprite\n   *     const localPos = event.getLocalPosition(sprite);\n   *     console.log('Local position:', localPos.x, localPos.y);\n   * });\n   * // Using custom global coordinates\n   * const customGlobal = new Point(100, 100);\n   * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n   *     // Transform custom coordinates\n   *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);\n   *     console.log('Custom local position:', localPos.x, localPos.y);\n   * });\n   * ```\n   * @see {@link Container.worldTransform} For the transformation matrix\n   * @see {@link Point} For the point class used to store coordinates\n   */ getLocalPosition(container, point, globalPos) {\n        return container.worldTransform.applyInverse(globalPos || this.global, point);\n    }\n    /**\n   * Whether the modifier key was pressed when this event natively occurred.\n   * @param key - The modifier key.\n   */ getModifierState(key) {\n        return \"getModifierState\" in this.nativeEvent && this.nativeEvent.getModifierState(key);\n    }\n    /**\n   * Not supported.\n   * @param _typeArg\n   * @param _canBubbleArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   * @param _screenXArg\n   * @param _screenYArg\n   * @param _clientXArg\n   * @param _clientYArg\n   * @param _ctrlKeyArg\n   * @param _altKeyArg\n   * @param _shiftKeyArg\n   * @param _metaKeyArg\n   * @param _buttonArg\n   * @param _relatedTargetArg\n   * @deprecated since 7.0.0\n   * @ignore\n   */ // eslint-disable-next-line max-params\n    initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {\n        throw new Error(\"Method not implemented.\");\n    }\n}\n\n});\n\nparcelRegister(\"gaPze\", function(module, exports) {\n\n$parcel$export(module.exports, \"FederatedPointerEvent\", () => $55afba1b23327af0$export$44ac16aa0ab81db6);\n\nvar $1y6A0 = parcelRequire(\"1y6A0\");\n\"use strict\";\nclass $55afba1b23327af0$export$44ac16aa0ab81db6 extends (0, $1y6A0.FederatedMouseEvent) {\n    constructor(){\n        super(...arguments);\n        /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */ this.width = 0;\n        /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */ this.height = 0;\n        /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */ this.isPrimary = false;\n    }\n    /**\n   * Only included for completeness for now\n   * @ignore\n   */ getCoalescedEvents() {\n        if (this.type === \"pointermove\" || this.type === \"mousemove\" || this.type === \"touchmove\") return [\n            this\n        ];\n        return [];\n    }\n    /**\n   * Only included for completeness for now\n   * @ignore\n   */ getPredictedEvents() {\n        throw new Error(\"getPredictedEvents is not supported!\");\n    }\n}\n\n});\n\nparcelRegister(\"2tRWs\", function(module, exports) {\n\n$parcel$export(module.exports, \"FederatedWheelEvent\", () => $c4179de99dc711c4$export$1fd8b94eb532974d);\n\nvar $1y6A0 = parcelRequire(\"1y6A0\");\n\"use strict\";\nclass $c4179de99dc711c4$export$1fd8b94eb532974d extends (0, $1y6A0.FederatedMouseEvent) {\n    constructor(){\n        super(...arguments);\n        /**\n     * Units specified in pixels.\n     * @ignore\n     */ this.DOM_DELTA_PIXEL = 0;\n        /**\n     * Units specified in lines.\n     * @ignore\n     */ this.DOM_DELTA_LINE = 1;\n        /**\n     * Units specified in pages.\n     * @ignore\n     */ this.DOM_DELTA_PAGE = 2;\n    }\n}\n/**\n * Units specified in pixels.\n * @ignore\n */ $c4179de99dc711c4$export$1fd8b94eb532974d.DOM_DELTA_PIXEL = 0;\n/**\n * Units specified in lines.\n * @ignore\n */ $c4179de99dc711c4$export$1fd8b94eb532974d.DOM_DELTA_LINE = 1;\n/**\n * Units specified in pages.\n * @ignore\n */ $c4179de99dc711c4$export$1fd8b94eb532974d.DOM_DELTA_PAGE = 2;\n\n});\n\n\n\nparcelRegister(\"f8xtB\", function(module, exports) {\n\n$parcel$export(module.exports, \"FederatedContainer\", () => $1b27ee9d63451714$export$403593d9e6c7baa6);\n\nvar $1XYIp = parcelRequire(\"1XYIp\");\n\nvar $1KB1X = parcelRequire(\"1KB1X\");\n\"use strict\";\nconst $1b27ee9d63451714$export$403593d9e6c7baa6 = {\n    onclick: null,\n    onmousedown: null,\n    onmouseenter: null,\n    onmouseleave: null,\n    onmousemove: null,\n    onglobalmousemove: null,\n    onmouseout: null,\n    onmouseover: null,\n    onmouseup: null,\n    onmouseupoutside: null,\n    onpointercancel: null,\n    onpointerdown: null,\n    onpointerenter: null,\n    onpointerleave: null,\n    onpointermove: null,\n    onglobalpointermove: null,\n    onpointerout: null,\n    onpointerover: null,\n    onpointertap: null,\n    onpointerup: null,\n    onpointerupoutside: null,\n    onrightclick: null,\n    onrightdown: null,\n    onrightup: null,\n    onrightupoutside: null,\n    ontap: null,\n    ontouchcancel: null,\n    ontouchend: null,\n    ontouchendoutside: null,\n    ontouchmove: null,\n    onglobaltouchmove: null,\n    ontouchstart: null,\n    onwheel: null,\n    get interactive () {\n        return this.eventMode === \"dynamic\" || this.eventMode === \"static\";\n    },\n    set interactive (value){\n        this.eventMode = value ? \"static\" : \"passive\";\n    },\n    _internalEventMode: void 0,\n    get eventMode () {\n        return this._internalEventMode ?? (0, $1XYIp.EventSystem).defaultEventMode;\n    },\n    set eventMode (value){\n        this._internalEventMode = value;\n    },\n    isInteractive () {\n        return this.eventMode === \"static\" || this.eventMode === \"dynamic\";\n    },\n    interactiveChildren: true,\n    hitArea: null,\n    addEventListener (type, listener, options) {\n        const capture = typeof options === \"boolean\" && options || typeof options === \"object\" && options.capture;\n        const signal = typeof options === \"object\" ? options.signal : void 0;\n        const once = typeof options === \"object\" ? options.once === true : false;\n        const context = typeof listener === \"function\" ? void 0 : listener;\n        type = capture ? `${type}capture` : type;\n        const listenerFn = typeof listener === \"function\" ? listener : listener.handleEvent;\n        const emitter = this;\n        if (signal) signal.addEventListener(\"abort\", ()=>{\n            emitter.off(type, listenerFn, context);\n        });\n        if (once) emitter.once(type, listenerFn, context);\n        else emitter.on(type, listenerFn, context);\n    },\n    removeEventListener (type, listener, options) {\n        const capture = typeof options === \"boolean\" && options || typeof options === \"object\" && options.capture;\n        const context = typeof listener === \"function\" ? void 0 : listener;\n        type = capture ? `${type}capture` : type;\n        listener = typeof listener === \"function\" ? listener : listener.handleEvent;\n        this.off(type, listener, context);\n    },\n    dispatchEvent (e) {\n        if (!(e instanceof (0, $1KB1X.FederatedEvent))) throw new Error(\"Container cannot propagate events outside of the Federated Events API\");\n        e.defaultPrevented = false;\n        e.path = null;\n        e.target = this;\n        e.manager.dispatchEvent(e);\n        return !e.defaultPrevented;\n    }\n};\n\n});\n\n\nparcelRegister(\"175Iu\", function(module, exports) {\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\nvar $cWKHz = parcelRequire(\"cWKHz\");\n\n\n\"use strict\";\n(0, $arnWa.extensions).add((0, $cWKHz.DOMPipe));\n\n});\nparcelRegister(\"cWKHz\", function(module, exports) {\n\n$parcel$export(module.exports, \"DOMPipe\", () => $ad168e3f95387bb9$export$ee59129a62c98408);\n\nvar $arnWa = parcelRequire(\"arnWa\");\n\"use strict\";\nclass $ad168e3f95387bb9$export$ee59129a62c98408 {\n    /**\n   * Constructor for the DOMPipe class.\n   * @param renderer - The renderer instance that this DOMPipe will be associated with.\n   */ constructor(renderer){\n        /** Array to keep track of attached DOM elements */ this._attachedDomElements = [];\n        this._renderer = renderer;\n        this._renderer.runners.postrender.add(this);\n        this._domElement = document.createElement(\"div\");\n        this._domElement.style.position = \"absolute\";\n        this._domElement.style.top = \"0\";\n        this._domElement.style.left = \"0\";\n        this._domElement.style.pointerEvents = \"none\";\n        this._domElement.style.zIndex = \"1000\";\n    }\n    /**\n   * Adds a renderable DOM container to the list of attached elements.\n   * @param domContainer - The DOM container to be added.\n   * @param _instructionSet - The instruction set (unused).\n   */ addRenderable(domContainer, _instructionSet) {\n        if (!this._attachedDomElements.includes(domContainer)) this._attachedDomElements.push(domContainer);\n    }\n    /**\n   * Updates a renderable DOM container.\n   * @param _domContainer - The DOM container to be updated (unused).\n   */ updateRenderable(_domContainer) {}\n    /**\n   * Validates a renderable DOM container.\n   * @param _domContainer - The DOM container to be validated (unused).\n   * @returns Always returns true as validation is not required.\n   */ validateRenderable(_domContainer) {\n        return true;\n    }\n    /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */ postrender() {\n        const attachedDomElements = this._attachedDomElements;\n        if (attachedDomElements.length === 0) {\n            this._domElement.remove();\n            return;\n        }\n        const canvas = this._renderer.view.canvas;\n        if (this._domElement.parentNode !== canvas.parentNode) canvas.parentNode?.appendChild(this._domElement);\n        const sx = parseFloat(canvas.style.width) / canvas.width * this._renderer.resolution;\n        const sy = parseFloat(canvas.style.height) / canvas.height * this._renderer.resolution;\n        this._domElement.style.transform = `translate(${canvas.offsetLeft}px, ${canvas.offsetTop}px) scale(${sx}, ${sy})`;\n        for(let i = 0; i < attachedDomElements.length; i++){\n            const domContainer = attachedDomElements[i];\n            const element = domContainer.element;\n            if (!domContainer.parent || domContainer.globalDisplayStatus < 7) {\n                element?.remove();\n                attachedDomElements.splice(i, 1);\n                i--;\n            } else {\n                if (!this._domElement.contains(element)) {\n                    element.style.position = \"absolute\";\n                    element.style.pointerEvents = \"auto\";\n                    this._domElement.appendChild(element);\n                }\n                const wt = domContainer.worldTransform;\n                const anchor = domContainer._anchor;\n                const ax = domContainer.width * anchor.x;\n                const ay = domContainer.height * anchor.y;\n                element.style.transformOrigin = `${ax}px ${ay}px`;\n                element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;\n                element.style.opacity = domContainer.groupAlpha.toString();\n            }\n        }\n    }\n    /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */ destroy() {\n        this._renderer.runners.postrender.remove(this);\n        for(let i = 0; i < this._attachedDomElements.length; i++){\n            const domContainer = this._attachedDomElements[i];\n            domContainer.element?.remove();\n        }\n        this._attachedDomElements.length = 0;\n        this._domElement.remove();\n        this._renderer = null;\n    }\n}\n/**\n * Static property defining the extension type and name for the DOMPipe.\n * This is used to register the DOMPipe with different rendering pipelines.\n */ $ad168e3f95387bb9$export$ee59129a62c98408.extension = {\n    type: [\n        (0, $arnWa.ExtensionType).WebGLPipes,\n        (0, $arnWa.ExtensionType).WebGPUPipes,\n        (0, $arnWa.ExtensionType).CanvasPipes\n    ],\n    name: \"dom\"\n};\n\n});\n\n\n\nparcelRegister(\"19C14\", function(module, exports) {\n\n$parcel$export(module.exports, \"State\", () => $7a0735955a6c768b$export$7254cc27399e90bd);\n\"use strict\";\nconst $7a0735955a6c768b$var$blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    \"normal-npm\": 6,\n    \"add-npm\": 7,\n    \"screen-npm\": 8,\n    min: 9,\n    max: 10\n};\nconst $7a0735955a6c768b$var$BLEND = 0;\nconst $7a0735955a6c768b$var$OFFSET = 1;\nconst $7a0735955a6c768b$var$CULLING = 2;\nconst $7a0735955a6c768b$var$DEPTH_TEST = 3;\nconst $7a0735955a6c768b$var$WINDING = 4;\nconst $7a0735955a6c768b$var$DEPTH_MASK = 5;\nconst $7a0735955a6c768b$var$_State = class _State {\n    constructor(){\n        this.data = 0;\n        this.blendMode = \"normal\";\n        this.polygonOffset = 0;\n        this.blend = true;\n        this.depthMask = true;\n    }\n    /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */ get blend() {\n        return !!(this.data & 1 << $7a0735955a6c768b$var$BLEND);\n    }\n    set blend(value) {\n        if (!!(this.data & 1 << $7a0735955a6c768b$var$BLEND) !== value) this.data ^= 1 << $7a0735955a6c768b$var$BLEND;\n    }\n    /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */ get offsets() {\n        return !!(this.data & 1 << $7a0735955a6c768b$var$OFFSET);\n    }\n    set offsets(value) {\n        if (!!(this.data & 1 << $7a0735955a6c768b$var$OFFSET) !== value) this.data ^= 1 << $7a0735955a6c768b$var$OFFSET;\n    }\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */ set cullMode(value) {\n        if (value === \"none\") {\n            this.culling = false;\n            return;\n        }\n        this.culling = true;\n        this.clockwiseFrontFace = value === \"front\";\n    }\n    get cullMode() {\n        if (!this.culling) return \"none\";\n        return this.clockwiseFrontFace ? \"front\" : \"back\";\n    }\n    /**\n   * Activates culling of polygons.\n   * @default false\n   */ get culling() {\n        return !!(this.data & 1 << $7a0735955a6c768b$var$CULLING);\n    }\n    set culling(value) {\n        if (!!(this.data & 1 << $7a0735955a6c768b$var$CULLING) !== value) this.data ^= 1 << $7a0735955a6c768b$var$CULLING;\n    }\n    /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */ get depthTest() {\n        return !!(this.data & 1 << $7a0735955a6c768b$var$DEPTH_TEST);\n    }\n    set depthTest(value) {\n        if (!!(this.data & 1 << $7a0735955a6c768b$var$DEPTH_TEST) !== value) this.data ^= 1 << $7a0735955a6c768b$var$DEPTH_TEST;\n    }\n    /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */ get depthMask() {\n        return !!(this.data & 1 << $7a0735955a6c768b$var$DEPTH_MASK);\n    }\n    set depthMask(value) {\n        if (!!(this.data & 1 << $7a0735955a6c768b$var$DEPTH_MASK) !== value) this.data ^= 1 << $7a0735955a6c768b$var$DEPTH_MASK;\n    }\n    /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */ get clockwiseFrontFace() {\n        return !!(this.data & 1 << $7a0735955a6c768b$var$WINDING);\n    }\n    set clockwiseFrontFace(value) {\n        if (!!(this.data & 1 << $7a0735955a6c768b$var$WINDING) !== value) this.data ^= 1 << $7a0735955a6c768b$var$WINDING;\n    }\n    /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */ get blendMode() {\n        return this._blendMode;\n    }\n    set blendMode(value) {\n        this.blend = value !== \"none\";\n        this._blendMode = value;\n        this._blendModeId = $7a0735955a6c768b$var$blendModeIds[value] || 0;\n    }\n    /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */ get polygonOffset() {\n        return this._polygonOffset;\n    }\n    set polygonOffset(value) {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n    toString() {\n        return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n    }\n    /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */ static for2d() {\n        const state = new _State();\n        state.depthTest = false;\n        state.blend = true;\n        return state;\n    }\n};\n$7a0735955a6c768b$var$_State.default2d = $7a0735955a6c768b$var$_State.for2d();\nlet $7a0735955a6c768b$export$7254cc27399e90bd = $7a0735955a6c768b$var$_State;\n\n});\n\nparcelRegister(\"6WOBV\", function(module, exports) {\n\n$parcel$export(module.exports, \"color32BitToUniform\", () => $47b411752eea9339$export$2c68e848c5b81f5);\n\"use strict\";\nfunction $47b411752eea9339$export$d13a52631f102a23(rgb, alpha, out, offset) {\n    out[offset++] = (rgb >> 16 & 255) / 255;\n    out[offset++] = (rgb >> 8 & 255) / 255;\n    out[offset++] = (rgb & 255) / 255;\n    out[offset++] = alpha;\n}\nfunction $47b411752eea9339$export$2c68e848c5b81f5(abgr, out, offset) {\n    const alpha = (abgr >> 24 & 255) / 255;\n    out[offset++] = (abgr & 255) / 255 * alpha;\n    out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n    out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n    out[offset++] = alpha;\n}\n\n});\n\nparcelRegister(\"2owzg\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableSprite\", () => $7da9a5be1a7b34c8$export$fe4bdc7069ee0b9c);\n\"use strict\";\nclass $7da9a5be1a7b34c8$export$fe4bdc7069ee0b9c {\n    constructor(){\n        this.batcherName = \"default\";\n        this.topology = \"triangle-list\";\n        // batch specific..\n        this.attributeSize = 4;\n        this.indexSize = 6;\n        this.packAsQuad = true;\n        this.roundPixels = 0;\n        this._attributeStart = 0;\n        // location in the buffer\n        this._batcher = null;\n        this._batch = null;\n    }\n    get blendMode() {\n        return this.renderable.groupBlendMode;\n    }\n    get color() {\n        return this.renderable.groupColorAlpha;\n    }\n    reset() {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n    destroy() {}\n}\n\n});\n\nparcelRegister(\"eQjNz\", function(module, exports) {\n\n$parcel$export(module.exports, \"localUniformBit\", () => $82ae999195aec18d$export$1723ac05bd5e9336);\n$parcel$export(module.exports, \"localUniformBitGroup2\", () => $82ae999195aec18d$export$adb0f80794f644d9);\n$parcel$export(module.exports, \"localUniformBitGl\", () => $82ae999195aec18d$export$36099520d0a716a);\n\"use strict\";\nconst $82ae999195aec18d$export$1723ac05bd5e9336 = {\n    name: \"local-uniform-bit\",\n    vertex: {\n        header: /* wgsl */ `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */ `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */ `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    }\n};\nconst $82ae999195aec18d$export$adb0f80794f644d9 = {\n    ...$82ae999195aec18d$export$1723ac05bd5e9336,\n    vertex: {\n        ...$82ae999195aec18d$export$1723ac05bd5e9336.vertex,\n        // replace the group!\n        header: $82ae999195aec18d$export$1723ac05bd5e9336.vertex.header.replace(\"group(1)\", \"group(2)\")\n    }\n};\nconst $82ae999195aec18d$export$36099520d0a716a = {\n    name: \"local-uniform-bit\",\n    vertex: {\n        header: /* glsl */ `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */ `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */ `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    }\n};\n\n});\n\n\n//# sourceMappingURL=browserAll.76ffaff7.js.map\n","import '../accessibility/init.mjs';\nimport '../app/init.mjs';\nimport '../events/init.mjs';\nimport '../dom/init.mjs';\nimport '../spritesheet/init.mjs';\nimport '../rendering/init.mjs';\nimport '../scene/graphics/init.mjs';\nimport '../scene/mesh/init.mjs';\nimport '../scene/particle-container/init.mjs';\nimport '../scene/text/init.mjs';\nimport '../scene/text-bitmap/init.mjs';\nimport '../scene/text-html/init.mjs';\nimport '../scene/sprite-tiling/init.mjs';\nimport '../scene/sprite-nine-slice/init.mjs';\nimport '../filters/init.mjs';\n\n\"use strict\";\n//# sourceMappingURL=browserAll.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { Container } from '../scene/container/Container.mjs';\nimport { AccessibilitySystem } from './AccessibilitySystem.mjs';\nimport { accessibilityTarget } from './accessibilityTarget.mjs';\n\n\"use strict\";\nextensions.add(AccessibilitySystem);\nextensions.mixin(Container, accessibilityTarget);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { Container } from '../scene/container/Container';\nimport { AccessibilitySystem } from './AccessibilitySystem';\nimport { accessibilityTarget } from './accessibilityTarget';\n\nextensions.add(AccessibilitySystem);\nextensions.mixin(Container, accessibilityTarget);\n","import { FederatedEvent } from '../events/FederatedEvent.mjs';\nimport { ExtensionType } from '../extensions/Extensions.mjs';\nimport { isMobile } from '../utils/browser/isMobile.mjs';\nimport { removeItems } from '../utils/data/removeItems.mjs';\n\n\"use strict\";\nconst KEY_CODE_TAB = 9;\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1e3;\nconst DIV_HOOK_POS_Y = -1e3;\nconst DIV_HOOK_ZINDEX = 2;\nconst _AccessibilitySystem = class _AccessibilitySystem {\n  // 2fps\n  // eslint-disable-next-line jsdoc/require-param\n  /**\n   * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n   */\n  constructor(renderer, _mobileInfo = isMobile) {\n    this._mobileInfo = _mobileInfo;\n    /** Whether accessibility divs are visible for debugging */\n    this.debug = false;\n    /** Whether to activate on tab key press */\n    this._activateOnTab = true;\n    /** Whether to deactivate accessibility when mouse moves */\n    this._deactivateOnMouseMove = true;\n    /** Internal variable, see isActive getter. */\n    this._isActive = false;\n    /** Internal variable, see isMobileAccessibility getter. */\n    this._isMobileAccessibility = false;\n    /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */\n    this._div = null;\n    /** A simple pool for storing divs. */\n    this._pool = [];\n    /** This is a tick used to check if an object is no longer being rendered. */\n    this._renderId = 0;\n    /** The array of currently active accessible items. */\n    this._children = [];\n    /** Count to throttle div updates on android devices. */\n    this._androidUpdateCount = 0;\n    /**  The frequency to update the div elements. */\n    this._androidUpdateFrequency = 500;\n    this._hookDiv = null;\n    if (_mobileInfo.tablet || _mobileInfo.phone) {\n      this._createTouchHook();\n    }\n    this._renderer = renderer;\n  }\n  /**\n   * Value of `true` if accessibility is currently active and accessibility layers are showing.\n   * @type {boolean}\n   * @readonly\n   */\n  get isActive() {\n    return this._isActive;\n  }\n  /**\n   * Value of `true` if accessibility is enabled for touch devices.\n   * @type {boolean}\n   * @readonly\n   */\n  get isMobileAccessibility() {\n    return this._isMobileAccessibility;\n  }\n  /**\n   * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.\n   * @readonly\n   */\n  get hookDiv() {\n    return this._hookDiv;\n  }\n  /**\n   * Creates the touch hooks.\n   * @private\n   */\n  _createTouchHook() {\n    const hookDiv = document.createElement(\"button\");\n    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n    hookDiv.style.position = \"absolute\";\n    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n    hookDiv.style.backgroundColor = \"#FF0000\";\n    hookDiv.title = \"select to enable accessibility for this content\";\n    hookDiv.addEventListener(\"focus\", () => {\n      this._isMobileAccessibility = true;\n      this._activate();\n      this._destroyTouchHook();\n    });\n    document.body.appendChild(hookDiv);\n    this._hookDiv = hookDiv;\n  }\n  /**\n   * Destroys the touch hooks.\n   * @private\n   */\n  _destroyTouchHook() {\n    if (!this._hookDiv) {\n      return;\n    }\n    document.body.removeChild(this._hookDiv);\n    this._hookDiv = null;\n  }\n  /**\n   * Activating will cause the Accessibility layer to be shown.\n   * This is called when a user presses the tab key.\n   * @private\n   */\n  _activate() {\n    if (this._isActive) {\n      return;\n    }\n    this._isActive = true;\n    if (!this._div) {\n      this._div = document.createElement(\"div\");\n      this._div.style.width = `${DIV_TOUCH_SIZE}px`;\n      this._div.style.height = `${DIV_TOUCH_SIZE}px`;\n      this._div.style.position = \"absolute\";\n      this._div.style.top = `${DIV_TOUCH_POS_X}px`;\n      this._div.style.left = `${DIV_TOUCH_POS_Y}px`;\n      this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n      this._div.style.pointerEvents = \"none\";\n    }\n    if (this._activateOnTab) {\n      this._onKeyDown = this._onKeyDown.bind(this);\n      globalThis.addEventListener(\"keydown\", this._onKeyDown, false);\n    }\n    if (this._deactivateOnMouseMove) {\n      this._onMouseMove = this._onMouseMove.bind(this);\n      globalThis.document.addEventListener(\"mousemove\", this._onMouseMove, true);\n    }\n    const canvas = this._renderer.view.canvas;\n    if (!canvas.parentNode) {\n      const observer = new MutationObserver(() => {\n        if (canvas.parentNode) {\n          canvas.parentNode.appendChild(this._div);\n          observer.disconnect();\n          this._initAccessibilitySetup();\n        }\n      });\n      observer.observe(document.body, { childList: true, subtree: true });\n    } else {\n      canvas.parentNode.appendChild(this._div);\n      this._initAccessibilitySetup();\n    }\n  }\n  // New method to handle initialization after div is ready\n  _initAccessibilitySetup() {\n    this._renderer.runners.postrender.add(this);\n    if (this._renderer.lastObjectRendered) {\n      this._updateAccessibleObjects(this._renderer.lastObjectRendered);\n    }\n  }\n  /**\n   * Deactivates the accessibility system. Removes listeners and accessibility elements.\n   * @private\n   */\n  _deactivate() {\n    if (!this._isActive || this._isMobileAccessibility) {\n      return;\n    }\n    this._isActive = false;\n    globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, true);\n    if (this._activateOnTab) {\n      globalThis.addEventListener(\"keydown\", this._onKeyDown, false);\n    }\n    this._renderer.runners.postrender.remove(this);\n    for (const child of this._children) {\n      if (child._accessibleDiv && child._accessibleDiv.parentNode) {\n        child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n        child._accessibleDiv = null;\n      }\n      child._accessibleActive = false;\n    }\n    this._pool.forEach((div) => {\n      if (div.parentNode) {\n        div.parentNode.removeChild(div);\n      }\n    });\n    if (this._div && this._div.parentNode) {\n      this._div.parentNode.removeChild(this._div);\n    }\n    this._pool = [];\n    this._children = [];\n  }\n  /**\n   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n   * @private\n   * @param {Container} container - The Container to check.\n   */\n  _updateAccessibleObjects(container) {\n    if (!container.visible || !container.accessibleChildren) {\n      return;\n    }\n    if (container.accessible) {\n      if (!container._accessibleActive) {\n        this._addChild(container);\n      }\n      container._renderId = this._renderId;\n    }\n    const children = container.children;\n    if (children) {\n      for (let i = 0; i < children.length; i++) {\n        this._updateAccessibleObjects(children[i]);\n      }\n    }\n  }\n  /**\n   * Runner init called, view is available at this point.\n   * @ignore\n   */\n  init(options) {\n    const defaultOpts = _AccessibilitySystem.defaultOptions;\n    const mergedOptions = {\n      accessibilityOptions: {\n        ...defaultOpts,\n        ...options?.accessibilityOptions || {}\n      }\n    };\n    this.debug = mergedOptions.accessibilityOptions.debug;\n    this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;\n    this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;\n    if (mergedOptions.accessibilityOptions.enabledByDefault) {\n      this._activate();\n    } else if (this._activateOnTab) {\n      this._onKeyDown = this._onKeyDown.bind(this);\n      globalThis.addEventListener(\"keydown\", this._onKeyDown, false);\n    }\n    this._renderer.runners.postrender.remove(this);\n  }\n  /**\n   * Updates the accessibility layer during rendering.\n   * - Removes divs for containers no longer in the scene\n   * - Updates the position and dimensions of the root div\n   * - Updates positions of active accessibility divs\n   * Only fires while the accessibility system is active.\n   * @ignore\n   */\n  postrender() {\n    const now = performance.now();\n    if (this._mobileInfo.android.device && now < this._androidUpdateCount) {\n      return;\n    }\n    this._androidUpdateCount = now + this._androidUpdateFrequency;\n    if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {\n      return;\n    }\n    const activeIds = /* @__PURE__ */ new Set();\n    if (this._renderer.lastObjectRendered) {\n      this._updateAccessibleObjects(this._renderer.lastObjectRendered);\n      for (const child of this._children) {\n        if (child._renderId === this._renderId) {\n          activeIds.add(this._children.indexOf(child));\n        }\n      }\n    }\n    for (let i = this._children.length - 1; i >= 0; i--) {\n      const child = this._children[i];\n      if (!activeIds.has(i)) {\n        if (child._accessibleDiv && child._accessibleDiv.parentNode) {\n          child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n          this._pool.push(child._accessibleDiv);\n          child._accessibleDiv = null;\n        }\n        child._accessibleActive = false;\n        removeItems(this._children, i, 1);\n      }\n    }\n    if (this._renderer.renderingToScreen) {\n      const { x, y, width: viewWidth, height: viewHeight } = this._renderer.screen;\n      const div = this._div;\n      div.style.left = `${x}px`;\n      div.style.top = `${y}px`;\n      div.style.width = `${viewWidth}px`;\n      div.style.height = `${viewHeight}px`;\n    }\n    for (let i = 0; i < this._children.length; i++) {\n      const child = this._children[i];\n      if (!child._accessibleActive || !child._accessibleDiv) {\n        continue;\n      }\n      const div = child._accessibleDiv;\n      const hitArea = child.hitArea || child.getBounds().rectangle;\n      if (child.hitArea) {\n        const wt = child.worldTransform;\n        const sx = this._renderer.resolution;\n        const sy = this._renderer.resolution;\n        div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;\n        div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;\n        div.style.width = `${hitArea.width * wt.a * sx}px`;\n        div.style.height = `${hitArea.height * wt.d * sy}px`;\n      } else {\n        this._capHitArea(hitArea);\n        const sx = this._renderer.resolution;\n        const sy = this._renderer.resolution;\n        div.style.left = `${hitArea.x * sx}px`;\n        div.style.top = `${hitArea.y * sy}px`;\n        div.style.width = `${hitArea.width * sx}px`;\n        div.style.height = `${hitArea.height * sy}px`;\n      }\n    }\n    this._renderId++;\n  }\n  /**\n   * private function that will visually add the information to the\n   * accessibility div\n   * @param {HTMLElement} div -\n   */\n  _updateDebugHTML(div) {\n    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n  }\n  /**\n   * Adjust the hit area based on the bounds of a display object\n   * @param {Rectangle} hitArea - Bounds of the child\n   */\n  _capHitArea(hitArea) {\n    if (hitArea.x < 0) {\n      hitArea.width += hitArea.x;\n      hitArea.x = 0;\n    }\n    if (hitArea.y < 0) {\n      hitArea.height += hitArea.y;\n      hitArea.y = 0;\n    }\n    const { width: viewWidth, height: viewHeight } = this._renderer;\n    if (hitArea.x + hitArea.width > viewWidth) {\n      hitArea.width = viewWidth - hitArea.x;\n    }\n    if (hitArea.y + hitArea.height > viewHeight) {\n      hitArea.height = viewHeight - hitArea.y;\n    }\n  }\n  /**\n   * Creates or reuses a div element for a Container and adds it to the accessibility layer.\n   * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.\n   * @private\n   * @param {Container} container - The child to make accessible.\n   */\n  _addChild(container) {\n    let div = this._pool.pop();\n    if (!div) {\n      if (container.accessibleType === \"button\") {\n        div = document.createElement(\"button\");\n      } else {\n        div = document.createElement(container.accessibleType);\n        div.style.cssText = `\n                        color: transparent;\n                        pointer-events: none;\n                        padding: 0;\n                        margin: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        box-sizing: border-box;\n                        user-select: none;\n                        -webkit-user-select: none;\n                        -moz-user-select: none;\n                        -ms-user-select: none;\n                    `;\n        if (container.accessibleText) {\n          div.innerText = container.accessibleText;\n        }\n      }\n      div.style.width = `${DIV_TOUCH_SIZE}px`;\n      div.style.height = `${DIV_TOUCH_SIZE}px`;\n      div.style.backgroundColor = this.debug ? \"rgba(255,255,255,0.5)\" : \"transparent\";\n      div.style.position = \"absolute\";\n      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n      div.style.borderStyle = \"none\";\n      if (navigator.userAgent.toLowerCase().includes(\"chrome\")) {\n        div.setAttribute(\"aria-live\", \"off\");\n      } else {\n        div.setAttribute(\"aria-live\", \"polite\");\n      }\n      if (navigator.userAgent.match(/rv:.*Gecko\\//)) {\n        div.setAttribute(\"aria-relevant\", \"additions\");\n      } else {\n        div.setAttribute(\"aria-relevant\", \"text\");\n      }\n      div.addEventListener(\"click\", this._onClick.bind(this));\n      div.addEventListener(\"focus\", this._onFocus.bind(this));\n      div.addEventListener(\"focusout\", this._onFocusOut.bind(this));\n    }\n    div.style.pointerEvents = container.accessiblePointerEvents;\n    div.type = container.accessibleType;\n    if (container.accessibleTitle && container.accessibleTitle !== null) {\n      div.title = container.accessibleTitle;\n    } else if (!container.accessibleHint || container.accessibleHint === null) {\n      div.title = `container ${container.tabIndex}`;\n    }\n    if (container.accessibleHint && container.accessibleHint !== null) {\n      div.setAttribute(\"aria-label\", container.accessibleHint);\n    }\n    if (this.debug) {\n      this._updateDebugHTML(div);\n    }\n    container._accessibleActive = true;\n    container._accessibleDiv = div;\n    div.container = container;\n    this._children.push(container);\n    this._div.appendChild(container._accessibleDiv);\n    if (container.interactive) {\n      container._accessibleDiv.tabIndex = container.tabIndex;\n    }\n  }\n  /**\n   * Dispatch events with the EventSystem.\n   * @param e\n   * @param type\n   * @private\n   */\n  _dispatchEvent(e, type) {\n    const { container: target } = e.target;\n    const boundary = this._renderer.events.rootBoundary;\n    const event = Object.assign(new FederatedEvent(boundary), { target });\n    boundary.rootTarget = this._renderer.lastObjectRendered;\n    type.forEach((type2) => boundary.dispatchEvent(event, type2));\n  }\n  /**\n   * Maps the div button press to pixi's EventSystem (click)\n   * @private\n   * @param {MouseEvent} e - The click event.\n   */\n  _onClick(e) {\n    this._dispatchEvent(e, [\"click\", \"pointertap\", \"tap\"]);\n  }\n  /**\n   * Maps the div focus events to pixi's EventSystem (mouseover)\n   * @private\n   * @param {FocusEvent} e - The focus event.\n   */\n  _onFocus(e) {\n    if (!e.target.getAttribute(\"aria-live\")) {\n      e.target.setAttribute(\"aria-live\", \"assertive\");\n    }\n    this._dispatchEvent(e, [\"mouseover\"]);\n  }\n  /**\n   * Maps the div focus events to pixi's EventSystem (mouseout)\n   * @private\n   * @param {FocusEvent} e - The focusout event.\n   */\n  _onFocusOut(e) {\n    if (!e.target.getAttribute(\"aria-live\")) {\n      e.target.setAttribute(\"aria-live\", \"polite\");\n    }\n    this._dispatchEvent(e, [\"mouseout\"]);\n  }\n  /**\n   * Is called when a key is pressed\n   * @private\n   * @param {KeyboardEvent} e - The keydown event.\n   */\n  _onKeyDown(e) {\n    if (e.keyCode !== KEY_CODE_TAB || !this._activateOnTab) {\n      return;\n    }\n    this._activate();\n  }\n  /**\n   * Is called when the mouse moves across the renderer element\n   * @private\n   * @param {MouseEvent} e - The mouse event.\n   */\n  _onMouseMove(e) {\n    if (e.movementX === 0 && e.movementY === 0) {\n      return;\n    }\n    this._deactivate();\n  }\n  /**\n   * Destroys the accessibility system. Removes all elements and listeners.\n   * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.\n   * > A typically user should not need to call this method directly.\n   */\n  destroy() {\n    this._deactivate();\n    this._destroyTouchHook();\n    this._div = null;\n    this._pool = null;\n    this._children = null;\n    this._renderer = null;\n    if (this._activateOnTab) {\n      globalThis.removeEventListener(\"keydown\", this._onKeyDown);\n    }\n  }\n  /**\n   * Enables or disables the accessibility system.\n   * @param enabled - Whether to enable or disable accessibility.\n   * @example\n   * ```js\n   * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility\n   * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility\n   * ```\n   */\n  setAccessibilityEnabled(enabled) {\n    if (enabled) {\n      this._activate();\n    } else {\n      this._deactivate();\n    }\n  }\n};\n/** @ignore */\n_AccessibilitySystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"accessibility\"\n};\n/**\n * The default options used by the system.\n * You can set these before initializing the {@link Application} to change the default behavior.\n * @example\n * ```js\n * import { AccessibilitySystem } from 'pixi.js';\n *\n * AccessibilitySystem.defaultOptions.enabledByDefault = true;\n *\n * const app = new Application()\n * app.init()\n * ```\n */\n_AccessibilitySystem.defaultOptions = {\n  /**\n   * Whether to enable accessibility features on initialization\n   * @default false\n   */\n  enabledByDefault: false,\n  /**\n   * Whether to visually show the accessibility divs for debugging\n   * @default false\n   */\n  debug: false,\n  /**\n   * Whether to activate accessibility when tab key is pressed\n   * @default true\n   */\n  activateOnTab: true,\n  /**\n   * Whether to deactivate accessibility when mouse moves\n   * @default true\n   */\n  deactivateOnMouseMove: true\n};\nlet AccessibilitySystem = _AccessibilitySystem;\n\nexport { AccessibilitySystem };\n//# sourceMappingURL=AccessibilitySystem.mjs.map\n","import { FederatedEvent } from '../events/FederatedEvent';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { isMobile } from '../utils/browser/isMobile';\nimport { removeItems } from '../utils/data/removeItems';\nimport { type AccessibleHTMLElement } from './accessibilityTarget';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { isMobileResult } from '../utils/browser/isMobile';\n\n/** @ignore */\nconst KEY_CODE_TAB = 9;\n\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\n\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1000;\nconst DIV_HOOK_POS_Y = -1000;\nconst DIV_HOOK_ZINDEX = 2;\n\n/**\n * Initialisation options for the accessibility system when used with an Application.\n * @category accessibility\n * @advanced\n */\nexport interface AccessibilitySystemOptions\n{\n    /** Options for the accessibility system */\n    accessibilityOptions?: AccessibilityOptions;\n}\n\n/**\n * The options for the accessibility system.\n * @category accessibility\n * @advanced\n */\nexport interface AccessibilityOptions\n{\n    /** Whether to enable accessibility features on initialization instead of waiting for tab key */\n    enabledByDefault?: boolean;\n    /** Whether to visually show the accessibility divs for debugging */\n    debug?: boolean;\n    /** Whether to allow tab key press to activate accessibility features */\n    activateOnTab?: boolean;\n    /** Whether to deactivate accessibility when mouse moves */\n    deactivateOnMouseMove?: boolean;\n}\n\n/**\n * The Accessibility system provides screen reader and keyboard navigation support for PixiJS content.\n * It creates an accessible DOM layer over the canvas that can be controlled programmatically or through user interaction.\n *\n * By default, the system activates when users press the tab key. This behavior can be customized through options:\n * ```js\n * const app = new Application({\n *     accessibilityOptions: {\n *     // Enable immediately instead of waiting for tab\n *     enabledByDefault: true,\n *     // Disable tab key activation\n *     activateOnTab: false,\n *     // Show/hide accessibility divs\n *     debug: false,\n *     // Prevent accessibility from being deactivated when mouse moves\n *     deactivateOnMouseMove: false,\n * }\n * });\n * ```\n *\n * The system can also be controlled programmatically by accessing the `renderer.accessibility` property:\n * ```js\n * app.renderer.accessibility.setAccessibilityEnabled(true);\n * ```\n *\n * To make individual containers accessible:\n * ```js\n * container.accessible = true;\n * ```\n * There are several properties that can be set on a Container to control its accessibility which can\n * be found here: {@link AccessibleOptions}.\n * @category accessibility\n * @standard\n */\nexport class AccessibilitySystem implements System<AccessibilitySystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'accessibility',\n    } as const;\n\n    /**\n     * The default options used by the system.\n     * You can set these before initializing the {@link Application} to change the default behavior.\n     * @example\n     * ```js\n     * import { AccessibilitySystem } from 'pixi.js';\n     *\n     * AccessibilitySystem.defaultOptions.enabledByDefault = true;\n     *\n     * const app = new Application()\n     * app.init()\n     * ```\n     */\n    public static defaultOptions: AccessibilityOptions = {\n        /**\n         * Whether to enable accessibility features on initialization\n         * @default false\n         */\n        enabledByDefault: false,\n        /**\n         * Whether to visually show the accessibility divs for debugging\n         * @default false\n         */\n        debug: false,\n        /**\n         * Whether to activate accessibility when tab key is pressed\n         * @default true\n         */\n        activateOnTab: true,\n        /**\n         * Whether to deactivate accessibility when mouse moves\n         * @default true\n         */\n        deactivateOnMouseMove: true,\n    };\n\n    /** Whether accessibility divs are visible for debugging */\n    public debug = false;\n\n    /** Whether to activate on tab key press */\n    private _activateOnTab = true;\n\n    /** Whether to deactivate accessibility when mouse moves */\n    private _deactivateOnMouseMove = true;\n\n    /**\n     * The renderer this accessibility manager works for.\n     * @type {WebGLRenderer|WebGPURenderer}\n     */\n    private _renderer: Renderer;\n\n    /** Internal variable, see isActive getter. */\n    private _isActive = false;\n\n    /** Internal variable, see isMobileAccessibility getter. */\n    private _isMobileAccessibility = false;\n\n    /** Button element for handling touch hooks. */\n    private _hookDiv: HTMLElement | null;\n\n    /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */\n    private _div: HTMLElement | null = null;\n\n    /** A simple pool for storing divs. */\n    private _pool: AccessibleHTMLElement[] = [];\n\n    /** This is a tick used to check if an object is no longer being rendered. */\n    private _renderId = 0;\n\n    /** The array of currently active accessible items. */\n    private _children: Container[] = [];\n\n    /** Count to throttle div updates on android devices. */\n    private _androidUpdateCount = 0;\n\n    /**  The frequency to update the div elements. */\n    private readonly _androidUpdateFrequency = 500; // 2fps\n\n    // eslint-disable-next-line jsdoc/require-param\n    /**\n     * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer, private readonly _mobileInfo: isMobileResult = isMobile)\n    {\n        this._hookDiv = null;\n\n        if (_mobileInfo.tablet || _mobileInfo.phone)\n        {\n            this._createTouchHook();\n        }\n\n        this._renderer = renderer;\n    }\n\n    /**\n     * Value of `true` if accessibility is currently active and accessibility layers are showing.\n     * @type {boolean}\n     * @readonly\n     */\n    get isActive(): boolean\n    {\n        return this._isActive;\n    }\n\n    /**\n     * Value of `true` if accessibility is enabled for touch devices.\n     * @type {boolean}\n     * @readonly\n     */\n    get isMobileAccessibility(): boolean\n    {\n        return this._isMobileAccessibility;\n    }\n\n    /**\n     * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.\n     * @readonly\n     */\n    get hookDiv()\n    {\n        return this._hookDiv;\n    }\n\n    /**\n     * Creates the touch hooks.\n     * @private\n     */\n    private _createTouchHook(): void\n    {\n        const hookDiv = document.createElement('button');\n\n        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.position = 'absolute';\n        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n        hookDiv.style.backgroundColor = '#FF0000';\n        hookDiv.title = 'select to enable accessibility for this content';\n\n        hookDiv.addEventListener('focus', () =>\n        {\n            this._isMobileAccessibility = true;\n            this._activate();\n            this._destroyTouchHook();\n        });\n\n        document.body.appendChild(hookDiv);\n        this._hookDiv = hookDiv;\n    }\n\n    /**\n     * Destroys the touch hooks.\n     * @private\n     */\n    private _destroyTouchHook(): void\n    {\n        if (!this._hookDiv)\n        {\n            return;\n        }\n        document.body.removeChild(this._hookDiv);\n        this._hookDiv = null;\n    }\n\n    /**\n     * Activating will cause the Accessibility layer to be shown.\n     * This is called when a user presses the tab key.\n     * @private\n     */\n    private _activate(): void\n    {\n        if (this._isActive)\n        {\n            return;\n        }\n\n        this._isActive = true;\n\n        // Create and add div if needed\n        if (!this._div)\n        {\n            this._div = document.createElement('div');\n            this._div.style.width = `${DIV_TOUCH_SIZE}px`;\n            this._div.style.height = `${DIV_TOUCH_SIZE}px`;\n            this._div.style.position = 'absolute';\n            this._div.style.top = `${DIV_TOUCH_POS_X}px`;\n            this._div.style.left = `${DIV_TOUCH_POS_Y}px`;\n            this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n            this._div.style.pointerEvents = 'none';\n        }\n\n        // Bind event handlers and add listeners when activating\n        if (this._activateOnTab)\n        {\n            this._onKeyDown = this._onKeyDown.bind(this);\n            globalThis.addEventListener('keydown', this._onKeyDown, false);\n        }\n\n        if (this._deactivateOnMouseMove)\n        {\n            this._onMouseMove = this._onMouseMove.bind(this);\n            globalThis.document.addEventListener('mousemove', this._onMouseMove, true);\n        }\n\n        // Check if canvas is in DOM\n        const canvas = this._renderer.view.canvas;\n\n        if (!canvas.parentNode)\n        {\n            const observer = new MutationObserver(() =>\n            {\n                if (canvas.parentNode)\n                {\n                    canvas.parentNode.appendChild(this._div);\n                    observer.disconnect();\n\n                    // Only start the postrender runner after div is ready\n                    this._initAccessibilitySetup();\n                }\n            });\n\n            observer.observe(document.body, { childList: true, subtree: true });\n        }\n        else\n        {\n            // Add to DOM\n            canvas.parentNode.appendChild(this._div);\n\n            // Div is ready, initialize accessibility\n            this._initAccessibilitySetup();\n        }\n    }\n\n    // New method to handle initialization after div is ready\n    private _initAccessibilitySetup(): void\n    {\n        // Add the postrender runner to start processing accessible objects\n        this._renderer.runners.postrender.add(this);\n\n        // Force an initial update of accessible objects\n        if (this._renderer.lastObjectRendered)\n        {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered as Container);\n        }\n    }\n\n    /**\n     * Deactivates the accessibility system. Removes listeners and accessibility elements.\n     * @private\n     */\n    private _deactivate(): void\n    {\n        if (!this._isActive || this._isMobileAccessibility)\n        {\n            return;\n        }\n\n        this._isActive = false;\n\n        // Switch listeners\n        globalThis.document.removeEventListener('mousemove', this._onMouseMove, true);\n        if (this._activateOnTab)\n        {\n            globalThis.addEventListener('keydown', this._onKeyDown, false);\n        }\n\n        this._renderer.runners.postrender.remove(this);\n\n        // Remove all active accessibility elements\n        for (const child of this._children)\n        {\n            if (child._accessibleDiv && child._accessibleDiv.parentNode)\n            {\n                child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n                child._accessibleDiv = null;\n            }\n            child._accessibleActive = false;\n        }\n\n        // Clear the pool of divs\n        this._pool.forEach((div) =>\n        {\n            if (div.parentNode)\n            {\n                div.parentNode.removeChild(div);\n            }\n        });\n\n        // Remove parent div from DOM\n        if (this._div && this._div.parentNode)\n        {\n            this._div.parentNode.removeChild(this._div);\n        }\n\n        this._pool = [];\n        this._children = [];\n    }\n\n    /**\n     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n     * @private\n     * @param {Container} container - The Container to check.\n     */\n    private _updateAccessibleObjects(container: Container): void\n    {\n        if (!container.visible || !container.accessibleChildren)\n        {\n            return;\n        }\n\n        // Separate check for accessibility without requiring interactivity\n        if (container.accessible)\n        {\n            if (!container._accessibleActive)\n            {\n                this._addChild(container);\n            }\n\n            container._renderId = this._renderId;\n        }\n\n        const children = container.children;\n\n        if (children)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._updateAccessibleObjects(children[i] as Container);\n            }\n        }\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options?: AccessibilitySystemOptions): void\n    {\n        // Ensure we have the accessibilityOptions object\n        const defaultOpts = AccessibilitySystem.defaultOptions;\n        const mergedOptions = {\n            accessibilityOptions: {\n                ...defaultOpts,\n                ...(options?.accessibilityOptions || {})\n            }\n        };\n\n        this.debug = mergedOptions.accessibilityOptions.debug;\n        this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;\n        this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;\n\n        if (mergedOptions.accessibilityOptions.enabledByDefault)\n        {\n            this._activate();\n        }\n        else if (this._activateOnTab)\n        {\n            this._onKeyDown = this._onKeyDown.bind(this);\n            globalThis.addEventListener('keydown', this._onKeyDown, false);\n        }\n\n        this._renderer.runners.postrender.remove(this);\n    }\n\n    /**\n     * Updates the accessibility layer during rendering.\n     * - Removes divs for containers no longer in the scene\n     * - Updates the position and dimensions of the root div\n     * - Updates positions of active accessibility divs\n     * Only fires while the accessibility system is active.\n     * @ignore\n     */\n    public postrender(): void\n    {\n        /* On Android default web browser, tab order seems to be calculated by position rather than tabIndex,\n        *  moving buttons can cause focus to flicker between two buttons making it hard/impossible to navigate,\n        *  so I am just running update every half a second, seems to fix it.\n        */\n        const now = performance.now();\n\n        if (this._mobileInfo.android.device && now < this._androidUpdateCount)\n        {\n            return;\n        }\n\n        this._androidUpdateCount = now + this._androidUpdateFrequency;\n\n        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas)\n        {\n            return;\n        }\n\n        // Track which containers are still active this frame\n        const activeIds = new Set<number>();\n\n        if (this._renderer.lastObjectRendered)\n        {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered as Container);\n\n            // Mark all updated containers as active\n            for (const child of this._children)\n            {\n                if (child._renderId === this._renderId)\n                {\n                    activeIds.add(this._children.indexOf(child));\n                }\n            }\n        }\n\n        // Remove any containers that weren't updated this frame\n        for (let i = this._children.length - 1; i >= 0; i--)\n        {\n            const child = this._children[i];\n\n            if (!activeIds.has(i))\n            {\n                // Container was removed, clean up its accessibility div\n                if (child._accessibleDiv && child._accessibleDiv.parentNode)\n                {\n                    child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n\n                    this._pool.push(child._accessibleDiv);\n                    child._accessibleDiv = null;\n                }\n                child._accessibleActive = false;\n                removeItems(this._children, i, 1);\n            }\n        }\n\n        // Update root div dimensions if needed\n        if (this._renderer.renderingToScreen)\n        {\n            const { x, y, width: viewWidth, height: viewHeight } = this._renderer.screen;\n            const div = this._div;\n\n            div.style.left = `${x}px`;\n            div.style.top = `${y}px`;\n            div.style.width = `${viewWidth}px`;\n            div.style.height = `${viewHeight}px`;\n        }\n\n        // Update positions of existing divs\n        for (let i = 0; i < this._children.length; i++)\n        {\n            const child = this._children[i];\n\n            if (!child._accessibleActive || !child._accessibleDiv)\n            {\n                continue;\n            }\n\n            // Only update position-related properties\n            const div = child._accessibleDiv;\n            const hitArea = (child.hitArea || child.getBounds().rectangle) as Rectangle;\n\n            if (child.hitArea)\n            {\n                const wt = child.worldTransform;\n                const sx = this._renderer.resolution;\n                const sy = this._renderer.resolution;\n\n                div.style.left = `${(wt.tx + (hitArea.x * wt.a)) * sx}px`;\n                div.style.top = `${(wt.ty + (hitArea.y * wt.d)) * sy}px`;\n                div.style.width = `${hitArea.width * wt.a * sx}px`;\n                div.style.height = `${hitArea.height * wt.d * sy}px`;\n            }\n            else\n            {\n                this._capHitArea(hitArea);\n                const sx = this._renderer.resolution;\n                const sy = this._renderer.resolution;\n\n                div.style.left = `${hitArea.x * sx}px`;\n                div.style.top = `${hitArea.y * sy}px`;\n                div.style.width = `${hitArea.width * sx}px`;\n                div.style.height = `${hitArea.height * sy}px`;\n            }\n        }\n\n        // increment the render id..\n        this._renderId++;\n    }\n\n    /**\n     * private function that will visually add the information to the\n     * accessibility div\n     * @param {HTMLElement} div -\n     */\n    private _updateDebugHTML(div: AccessibleHTMLElement): void\n    {\n        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n    }\n\n    /**\n     * Adjust the hit area based on the bounds of a display object\n     * @param {Rectangle} hitArea - Bounds of the child\n     */\n    private _capHitArea(hitArea: Rectangle): void\n    {\n        if (hitArea.x < 0)\n        {\n            hitArea.width += hitArea.x;\n            hitArea.x = 0;\n        }\n\n        if (hitArea.y < 0)\n        {\n            hitArea.height += hitArea.y;\n            hitArea.y = 0;\n        }\n\n        const { width: viewWidth, height: viewHeight } = this._renderer;\n\n        if (hitArea.x + hitArea.width > viewWidth)\n        {\n            hitArea.width = viewWidth - hitArea.x;\n        }\n\n        if (hitArea.y + hitArea.height > viewHeight)\n        {\n            hitArea.height = viewHeight - hitArea.y;\n        }\n    }\n\n    /**\n     * Creates or reuses a div element for a Container and adds it to the accessibility layer.\n     * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.\n     * @private\n     * @param {Container} container - The child to make accessible.\n     */\n    private _addChild<T extends Container>(container: T): void\n    {\n        let div = this._pool.pop();\n\n        if (!div)\n        {\n            if (container.accessibleType === 'button')\n            {\n                div = document.createElement('button');\n            }\n            else\n            {\n                div = document.createElement(container.accessibleType);\n                div.style.cssText = `\n                        color: transparent;\n                        pointer-events: none;\n                        padding: 0;\n                        margin: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        box-sizing: border-box;\n                        user-select: none;\n                        -webkit-user-select: none;\n                        -moz-user-select: none;\n                        -ms-user-select: none;\n                    `;\n                if (container.accessibleText)\n                {\n                    div.innerText = container.accessibleText;\n                }\n            }\n            div.style.width = `${DIV_TOUCH_SIZE}px`;\n            div.style.height = `${DIV_TOUCH_SIZE}px`;\n            div.style.backgroundColor = this.debug ? 'rgba(255,255,255,0.5)' : 'transparent';\n            div.style.position = 'absolute';\n            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n            div.style.borderStyle = 'none';\n\n            // ARIA attributes ensure that button title and hint updates are announced properly\n            if (navigator.userAgent.toLowerCase().includes('chrome'))\n            {\n                // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.\n                div.setAttribute('aria-live', 'off');\n            }\n            else\n            {\n                div.setAttribute('aria-live', 'polite');\n            }\n\n            if (navigator.userAgent.match(/rv:.*Gecko\\//))\n            {\n                // FireFox needs this to announce only the new button name\n                div.setAttribute('aria-relevant', 'additions');\n            }\n            else\n            {\n                // required by IE, other browsers don't much care\n                div.setAttribute('aria-relevant', 'text');\n            }\n\n            div.addEventListener('click', this._onClick.bind(this));\n            div.addEventListener('focus', this._onFocus.bind(this));\n            div.addEventListener('focusout', this._onFocusOut.bind(this));\n        }\n\n        // set pointer events\n        div.style.pointerEvents = container.accessiblePointerEvents;\n        // set the type, this defaults to button!\n        div.type = container.accessibleType;\n\n        if (container.accessibleTitle && container.accessibleTitle !== null)\n        {\n            div.title = container.accessibleTitle;\n        }\n        else if (!container.accessibleHint\n            || container.accessibleHint === null)\n        {\n            div.title = `container ${container.tabIndex}`;\n        }\n\n        if (container.accessibleHint\n            && container.accessibleHint !== null)\n        {\n            div.setAttribute('aria-label', container.accessibleHint);\n        }\n\n        if (this.debug)\n        {\n            this._updateDebugHTML(div);\n        }\n\n        container._accessibleActive = true;\n        container._accessibleDiv = div;\n        div.container = container;\n\n        this._children.push(container);\n        this._div.appendChild(container._accessibleDiv);\n        if (container.interactive)\n        {\n            container._accessibleDiv.tabIndex = container.tabIndex;\n        }\n    }\n\n    /**\n     * Dispatch events with the EventSystem.\n     * @param e\n     * @param type\n     * @private\n     */\n    private _dispatchEvent(e: UIEvent, type: string[]): void\n    {\n        const { container: target } = e.target as AccessibleHTMLElement;\n        const boundary = this._renderer.events.rootBoundary;\n        const event: FederatedEvent = Object.assign(new FederatedEvent(boundary), { target });\n\n        boundary.rootTarget = this._renderer.lastObjectRendered as Container;\n        type.forEach((type) => boundary.dispatchEvent(event, type));\n    }\n\n    /**\n     * Maps the div button press to pixi's EventSystem (click)\n     * @private\n     * @param {MouseEvent} e - The click event.\n     */\n    private _onClick(e: MouseEvent): void\n    {\n        this._dispatchEvent(e, ['click', 'pointertap', 'tap']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseover)\n     * @private\n     * @param {FocusEvent} e - The focus event.\n     */\n    private _onFocus(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'assertive');\n        }\n\n        this._dispatchEvent(e, ['mouseover']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseout)\n     * @private\n     * @param {FocusEvent} e - The focusout event.\n     */\n    private _onFocusOut(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'polite');\n        }\n\n        this._dispatchEvent(e, ['mouseout']);\n    }\n\n    /**\n     * Is called when a key is pressed\n     * @private\n     * @param {KeyboardEvent} e - The keydown event.\n     */\n    private _onKeyDown(e: KeyboardEvent): void\n    {\n        if (e.keyCode !== KEY_CODE_TAB || !this._activateOnTab)\n        {\n            return;\n        }\n\n        this._activate();\n    }\n\n    /**\n     * Is called when the mouse moves across the renderer element\n     * @private\n     * @param {MouseEvent} e - The mouse event.\n     */\n    private _onMouseMove(e: MouseEvent): void\n    {\n        if (e.movementX === 0 && e.movementY === 0)\n        {\n            return;\n        }\n\n        this._deactivate();\n    }\n\n    /**\n     * Destroys the accessibility system. Removes all elements and listeners.\n     * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.\n     * > A typically user should not need to call this method directly.\n     */\n    public destroy(): void\n    {\n        this._deactivate();\n        this._destroyTouchHook();\n\n        this._div = null;\n        this._pool = null;\n        this._children = null;\n        this._renderer = null;\n\n        if (this._activateOnTab)\n        {\n            globalThis.removeEventListener('keydown', this._onKeyDown);\n        }\n    }\n\n    /**\n     * Enables or disables the accessibility system.\n     * @param enabled - Whether to enable or disable accessibility.\n     * @example\n     * ```js\n     * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility\n     * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility\n     * ```\n     */\n    public setAccessibilityEnabled(enabled: boolean): void\n    {\n        if (enabled)\n        {\n            this._activate();\n        }\n        else\n        {\n            this._deactivate();\n        }\n    }\n}\n","import { Point } from '../maths/point/Point.mjs';\n\n\"use strict\";\nclass FederatedEvent {\n  /**\n   * @param manager - The event boundary which manages this event. Propagation can only occur\n   *  within the boundary's jurisdiction.\n   */\n  constructor(manager) {\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    this.bubbles = true;\n    /** @deprecated since 7.0.0 */\n    this.cancelBubble = true;\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    this.cancelable = false;\n    /**\n     * Flag added for compatibility with DOM `Event`. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     * @ignore\n     */\n    this.composed = false;\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    this.defaultPrevented = false;\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    this.eventPhase = FederatedEvent.prototype.NONE;\n    /** Flags whether propagation was stopped. */\n    this.propagationStopped = false;\n    /** Flags whether propagation was immediately stopped. */\n    this.propagationImmediatelyStopped = false;\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    this.layer = new Point();\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    this.page = new Point();\n    /**\n     * The event propagation phase NONE that indicates that the event is not in any phase.\n     * @default 0\n     * @advanced\n     */\n    this.NONE = 0;\n    /**\n     * The event propagation phase CAPTURING_PHASE that indicates that the event is in the capturing phase.\n     * @default 1\n     * @advanced\n     */\n    this.CAPTURING_PHASE = 1;\n    /**\n     * The event propagation phase AT_TARGET that indicates that the event is at the target.\n     * @default 2\n     * @advanced\n     */\n    this.AT_TARGET = 2;\n    /**\n     * The event propagation phase BUBBLING_PHASE that indicates that the event is in the bubbling phase.\n     * @default 3\n     * @advanced\n     */\n    this.BUBBLING_PHASE = 3;\n    this.manager = manager;\n  }\n  /** @readonly */\n  get layerX() {\n    return this.layer.x;\n  }\n  /** @readonly */\n  get layerY() {\n    return this.layer.y;\n  }\n  /** @readonly */\n  get pageX() {\n    return this.page.x;\n  }\n  /** @readonly */\n  get pageY() {\n    return this.page.y;\n  }\n  /**\n   * Fallback for the deprecated `InteractionEvent.data`.\n   * @deprecated since 7.0.0\n   */\n  get data() {\n    return this;\n  }\n  /**\n   * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.\n   * @advanced\n   */\n  composedPath() {\n    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {\n      this.path = this.target ? this.manager.propagationPath(this.target) : [];\n    }\n    return this.path;\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.\n   * @deprecated\n   * @ignore\n   * @param _type\n   * @param _bubbles\n   * @param _cancelable\n   */\n  initEvent(_type, _bubbles, _cancelable) {\n    throw new Error(\"initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.\");\n  }\n  /**\n   * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.\n   * @ignore\n   * @deprecated\n   * @param _typeArg\n   * @param _bubblesArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   */\n  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {\n    throw new Error(\"initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.\");\n  }\n  /**\n   * Prevent default behavior of both PixiJS and the user agent.\n   * @example\n   * ```ts\n   * sprite.on('click', (event) => {\n   *     // Prevent both browser's default click behavior\n   *     // and PixiJS's default handling\n   *     event.preventDefault();\n   *\n   *     // Custom handling\n   *     customClickHandler();\n   * });\n   * ```\n   * @remarks\n   * - Only works if the native event is cancelable\n   * - Does not stop event propagation\n   */\n  preventDefault() {\n    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {\n      this.nativeEvent.preventDefault();\n    }\n    this.defaultPrevented = true;\n  }\n  /**\n   * Stop this event from propagating to any additional listeners, including those\n   * on the current target and any following targets in the propagation path.\n   * @example\n   * ```ts\n   * container.on('pointerdown', (event) => {\n   *     // Stop all further event handling\n   *     event.stopImmediatePropagation();\n   *\n   *     // These handlers won't be called:\n   *     // - Other pointerdown listeners on this container\n   *     // - Any pointerdown listeners on parent containers\n   * });\n   * ```\n   * @remarks\n   * - Immediately stops all event propagation\n   * - Prevents other listeners on same target from being called\n   * - More aggressive than stopPropagation()\n   */\n  stopImmediatePropagation() {\n    this.propagationImmediatelyStopped = true;\n  }\n  /**\n   * Stop this event from propagating to the next target in the propagation path.\n   * The rest of the listeners on the current target will still be notified.\n   * @example\n   * ```ts\n   * child.on('pointermove', (event) => {\n   *     // Handle event on child\n   *     updateChild();\n   *\n   *     // Prevent parent handlers from being called\n   *     event.stopPropagation();\n   * });\n   *\n   * // This won't be called if child handles the event\n   * parent.on('pointermove', (event) => {\n   *     updateParent();\n   * });\n   * ```\n   * @remarks\n   * - Stops event bubbling to parent containers\n   * - Does not prevent other listeners on same target\n   * - Less aggressive than stopImmediatePropagation()\n   */\n  stopPropagation() {\n    this.propagationStopped = true;\n  }\n}\n\nexport { FederatedEvent };\n//# sourceMappingURL=FederatedEvent.mjs.map\n","import { Point } from '../maths/point/Point';\n\nimport type { Container } from '../scene/container/Container';\nimport type { EventBoundary } from './EventBoundary';\n\n/**\n * A PixiJS compatible touch event interface that extends the standard DOM Touch interface.\n * Provides additional properties to normalize touch input with mouse/pointer events.\n * @example\n * ```ts\n * // Access touch information\n * sprite.on('touchstart', (event) => {\n *     // Standard touch properties\n *     console.log('Touch position:', event.clientX, event.clientY);\n *     console.log('Touch ID:', event.pointerId);\n *\n *     // Additional PixiJS properties\n *     console.log('Pressure:', event.pressure);\n *     console.log('Size:', event.width, event.height);\n *     console.log('Tilt:', event.tiltX, event.tiltY);\n * });\n * ```\n * @category events\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Touch} DOM Touch Interface\n * @standard\n */\nexport interface PixiTouch extends Touch\n{\n    /** The button being pressed (0: left, 1: middle, 2: right) */\n    button: number;\n\n    /** Bitmap of currently pressed buttons */\n    buttons: number;\n\n    /** Whether this is the primary touch point */\n    isPrimary: boolean;\n\n    /** The width of the touch contact area */\n    width: number;\n\n    /** The height of the touch contact area */\n    height: number;\n\n    /** The angle of tilt along the x-axis (in degrees) */\n    tiltX: number;\n\n    /** The angle of tilt along the y-axis (in degrees) */\n    tiltY: number;\n\n    /** The type of pointer that triggered this event */\n    pointerType: string;\n\n    /** Unique identifier for this touch point */\n    pointerId: number;\n\n    /** The normalized pressure of the pointer (0 to 1) */\n    pressure: number;\n\n    /** The rotation angle of the pointer (e.g., pen) */\n    twist: number;\n\n    /** The normalized tangential pressure of the pointer */\n    tangentialPressure: number;\n\n    /** The x coordinate relative to the current layer */\n    layerX: number;\n\n    /** The y coordinate relative to the current layer */\n    layerY: number;\n\n    /** The x coordinate relative to the target's offset parent */\n    offsetX: number;\n\n    /** The y coordinate relative to the target's offset parent */\n    offsetY: number;\n\n    /** Whether the event was normalized by PixiJS */\n    isNormalized: boolean;\n\n    /** The type of touch event */\n    type: string;\n}\n\n/**\n * A DOM-compatible synthetic event implementation for PixiJS's event system.\n * This class implements the standard DOM Event interface while providing additional\n * functionality specific to PixiJS events.\n * > [!NOTE] You wont receive an instance of this class directly, but rather a subclass\n * > of this class, such as {@link FederatedPointerEvent}, {@link FederatedMouseEvent}, or\n * > {@link FederatedWheelEvent}. This class is the base for all federated events.\n * @example\n * ```ts\n * // Basic event handling\n * sprite.on('pointerdown', (event: FederatedEvent) => {\n *     // Access standard DOM event properties\n *     console.log('Target:', event.target);\n *     console.log('Phase:', event.eventPhase);\n *     console.log('Type:', event.type);\n *\n *     // Control propagation\n *     event.stopPropagation();\n * });\n * ```\n * @typeParam N - The type of native event held. Can be either a UIEvent or PixiTouch.\n * @remarks\n * - Implements the standard DOM UIEvent interface\n * - Provides event bubbling and capturing phases\n * - Supports propagation control\n * - Manages event paths through display tree\n * - Normalizes native browser events\n * @see {@link https://dom.spec.whatwg.org/#event} DOM Event Specification\n * @see {@link FederatedPointerEvent} For pointer-specific events\n * @see {@link FederatedMouseEvent} For mouse-specific events\n * @see {@link FederatedWheelEvent} For wheel-specific events\n * @category events\n * @standard\n */\nexport class FederatedEvent<N extends UIEvent | PixiTouch = UIEvent | PixiTouch> implements UIEvent\n{\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    public bubbles = true;\n\n    /** @deprecated since 7.0.0 */\n    public cancelBubble = true;\n\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    public readonly cancelable = false;\n\n    /**\n     * Flag added for compatibility with DOM `Event`. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     * @ignore\n     */\n    public readonly composed = false;\n\n    /** The listeners of the event target that are being notified. */\n    public currentTarget: Container;\n\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    public defaultPrevented = false;\n\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    public eventPhase = FederatedEvent.prototype.NONE;\n\n    /** Flags whether this is a user-trusted event */\n    public isTrusted: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public returnValue: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public srcElement: EventTarget;\n\n    /** The event target that this will be dispatched to. */\n    public target: Container;\n\n    /** The timestamp of when the event was created. */\n    public timeStamp: number;\n\n    /** The type of event, e.g. `\"mouseup\"`. */\n    public type: string;\n\n    /** The native event that caused the foremost original event. */\n    public nativeEvent: N;\n\n    /** The original event that caused this event, if any. */\n    public originalEvent: FederatedEvent<N>;\n\n    /** Flags whether propagation was stopped. */\n    public propagationStopped = false;\n\n    /** Flags whether propagation was immediately stopped. */\n    public propagationImmediatelyStopped = false;\n\n    /** The composed path of the event's propagation. The `target` is at the end. */\n    public path: Container[];\n\n    /** The {@link EventBoundary} that manages this event. Null for root events. */\n    public readonly manager: EventBoundary;\n\n    /** Event-specific detail */\n    public detail: number;\n\n    /** The global Window object. */\n    public view: WindowProxy;\n\n    /**\n     * Not supported.\n     * @deprecated since 7.0.0\n     * @ignore\n     */\n    public which: number;\n\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    public layer: Point = new Point();\n\n    /** @readonly */\n    get layerX(): number { return this.layer.x; }\n\n    /** @readonly */\n    get layerY(): number { return this.layer.y; }\n\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    public page: Point = new Point();\n\n    /** @readonly */\n    get pageX(): number { return this.page.x; }\n\n    /** @readonly */\n    get pageY(): number { return this.page.y; }\n\n    /**\n     * @param manager - The event boundary which manages this event. Propagation can only occur\n     *  within the boundary's jurisdiction.\n     */\n    constructor(manager: EventBoundary)\n    {\n        this.manager = manager;\n    }\n\n    /**\n     * Fallback for the deprecated `InteractionEvent.data`.\n     * @deprecated since 7.0.0\n     */\n    get data(): this\n    {\n        return this;\n    }\n\n    /**\n     * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.\n     * @advanced\n     */\n    public composedPath(): Container[]\n    {\n        // Find the propagation path if it isn't cached or if the target has changed since since\n        // the last evaluation.\n        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target))\n        {\n            this.path = this.target ? this.manager.propagationPath(this.target) : [];\n        }\n\n        return this.path;\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.\n     * @deprecated\n     * @ignore\n     * @param _type\n     * @param _bubbles\n     * @param _cancelable\n     */\n    public initEvent(_type: string, _bubbles?: boolean, _cancelable?: boolean): void\n    {\n        throw new Error('initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.\n     * @ignore\n     * @deprecated\n     * @param _typeArg\n     * @param _bubblesArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     */\n    public initUIEvent(_typeArg: string, _bubblesArg?: boolean, _cancelableArg?: boolean, _viewArg?: Window | null,\n        _detailArg?: number): void\n    {\n        throw new Error('initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /**\n     * Prevent default behavior of both PixiJS and the user agent.\n     * @example\n     * ```ts\n     * sprite.on('click', (event) => {\n     *     // Prevent both browser's default click behavior\n     *     // and PixiJS's default handling\n     *     event.preventDefault();\n     *\n     *     // Custom handling\n     *     customClickHandler();\n     * });\n     * ```\n     * @remarks\n     * - Only works if the native event is cancelable\n     * - Does not stop event propagation\n     */\n    public preventDefault(): void\n    {\n        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable)\n        {\n            this.nativeEvent.preventDefault();\n        }\n\n        this.defaultPrevented = true;\n    }\n\n    /**\n     * Stop this event from propagating to any additional listeners, including those\n     * on the current target and any following targets in the propagation path.\n     * @example\n     * ```ts\n     * container.on('pointerdown', (event) => {\n     *     // Stop all further event handling\n     *     event.stopImmediatePropagation();\n     *\n     *     // These handlers won't be called:\n     *     // - Other pointerdown listeners on this container\n     *     // - Any pointerdown listeners on parent containers\n     * });\n     * ```\n     * @remarks\n     * - Immediately stops all event propagation\n     * - Prevents other listeners on same target from being called\n     * - More aggressive than stopPropagation()\n     */\n    public stopImmediatePropagation(): void\n    {\n        this.propagationImmediatelyStopped = true;\n    }\n\n    /**\n     * Stop this event from propagating to the next target in the propagation path.\n     * The rest of the listeners on the current target will still be notified.\n     * @example\n     * ```ts\n     * child.on('pointermove', (event) => {\n     *     // Handle event on child\n     *     updateChild();\n     *\n     *     // Prevent parent handlers from being called\n     *     event.stopPropagation();\n     * });\n     *\n     * // This won't be called if child handles the event\n     * parent.on('pointermove', (event) => {\n     *     updateParent();\n     * });\n     * ```\n     * @remarks\n     * - Stops event bubbling to parent containers\n     * - Does not prevent other listeners on same target\n     * - Less aggressive than stopImmediatePropagation()\n     */\n    public stopPropagation(): void\n    {\n        this.propagationStopped = true;\n    }\n\n    /**\n     * The event propagation phase NONE that indicates that the event is not in any phase.\n     * @default 0\n     * @advanced\n     */\n    public readonly NONE = 0;\n    /**\n     * The event propagation phase CAPTURING_PHASE that indicates that the event is in the capturing phase.\n     * @default 1\n     * @advanced\n     */\n    public readonly CAPTURING_PHASE = 1;\n    /**\n     * The event propagation phase AT_TARGET that indicates that the event is at the target.\n     * @default 2\n     * @advanced\n     */\n    public readonly AT_TARGET = 2;\n    /**\n     * The event propagation phase BUBBLING_PHASE that indicates that the event is in the bubbling phase.\n     * @default 3\n     * @advanced\n     */\n    public readonly BUBBLING_PHASE = 3;\n}\n","import isMobileJs from 'ismobilejs';\n\n\"use strict\";\nconst isMobileCall = isMobileJs.default ?? isMobileJs;\nconst isMobile = isMobileCall(globalThis.navigator);\n\nexport { isMobile };\n//# sourceMappingURL=isMobile.mjs.map\n","import isMobileJs from 'ismobilejs';\n\n// ismobilejs have different import behavior for CJS and ESM, so here is the hack\ntype isMobileJsType = typeof isMobileJs & { default?: typeof isMobileJs };\nconst isMobileCall = (isMobileJs as isMobileJsType).default ?? isMobileJs;\n\n/**\n * The result of the mobile device detection system.\n * Provides detailed information about device type and platform.\n * @example\n * ```ts\n * // Type usage with isMobile\n * const deviceInfo: isMobileResult = isMobile;\n *\n * // Check device categories\n * if (deviceInfo.apple.device) {\n *     console.log('iOS Device Details:', {\n *         isPhone: deviceInfo.apple.phone,\n *         isTablet: deviceInfo.apple.tablet,\n *         isUniversal: deviceInfo.apple.universal\n *     });\n * }\n *\n * // Platform-specific checks\n * const platformInfo = {\n *     isApple: deviceInfo.apple.device,\n *     isAndroid: deviceInfo.android.device,\n *     isAmazon: deviceInfo.amazon.device,\n *     isWindows: deviceInfo.windows.device\n * };\n * ```\n * @category utils\n * @standard\n */\nexport type isMobileResult = {\n    /**\n     * Apple device detection information.\n     * Provides detailed iOS device categorization.\n     * @example\n     * ```ts\n     * // iOS device checks\n     * if (isMobile.apple.device) {\n     *     if (isMobile.apple.tablet) {\n     *         // iPad-specific code\n     *         useTabletLayout();\n     *     } else if (isMobile.apple.phone) {\n     *         // iPhone-specific code\n     *         usePhoneLayout();\n     *     }\n     * }\n     * ```\n     */\n    apple: {\n        /** Whether the device is an iPhone */\n        phone: boolean;\n        /** Whether the device is an iPod Touch */\n        ipod: boolean;\n        /** Whether the device is an iPad */\n        tablet: boolean;\n        /** Whether app is running in iOS universal mode */\n        universal: boolean;\n        /** Whether device is any Apple mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Amazon device detection information.\n     * Identifies Amazon Fire tablets and phones.\n     * @example\n     * ```ts\n     * // Amazon Fire tablet detection\n     * if (isMobile.amazon.tablet) {\n     *     // Fire tablet optimizations\n     *     optimizeForFireTablet();\n     * }\n     * ```\n     */\n    amazon: {\n        /** Whether device is a Fire Phone */\n        phone: boolean;\n        /** Whether device is a Fire Tablet */\n        tablet: boolean;\n        /** Whether device is any Amazon mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Android device detection information.\n     * Categorizes Android phones and tablets.\n     * @example\n     * ```ts\n     * // Android device handling\n     * if (isMobile.android.device) {\n     *     // Check specific type\n     *     const deviceType = isMobile.android.tablet ?\n     *         'tablet' : 'phone';\n     *     console.log(`Android ${deviceType} detected`);\n     * }\n     * ```\n     */\n    android: {\n        /** Whether device is an Android phone */\n        phone: boolean;\n        /** Whether device is an Android tablet */\n        tablet: boolean;\n        /** Whether device is any Android device */\n        device: boolean;\n    };\n\n    /**\n     * Windows device detection information.\n     * Identifies Windows phones and tablets.\n     * @example\n     * ```ts\n     * // Windows device checks\n     * if (isMobile.windows.tablet) {\n     *     // Surface tablet optimizations\n     *     enableTouchFeatures();\n     * }\n     * ```\n     */\n    windows: {\n        /** Whether device is a Windows Phone */\n        phone: boolean;\n        /** Whether device is a Windows tablet */\n        tablet: boolean;\n        /** Whether device is any Windows mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Other device detection information.\n     * Covers additional platforms and browsers.\n     * @example\n     * ```ts\n     * // Check other platforms\n     * if (isMobile.other.blackberry10) {\n     *     // BlackBerry 10 specific code\n     * } else if (isMobile.other.chrome) {\n     *     // Chrome mobile specific code\n     * }\n     * ```\n     */\n    other: {\n        /** Whether device is a BlackBerry */\n        blackberry: boolean;\n        /** Whether device is a BlackBerry 10 */\n        blackberry10: boolean;\n        /** Whether browser is Opera Mobile */\n        opera: boolean;\n        /** Whether browser is Firefox Mobile */\n        firefox: boolean;\n        /** Whether browser is Chrome Mobile */\n        chrome: boolean;\n        /** Whether device is any other mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Whether the device is any type of phone.\n     * Combines detection across all platforms.\n     * @example\n     * ```ts\n     * // Check if device is a phone\n     * if (isMobile.phone) {\n     *     console.log('Running on a mobile phone');\n     * }\n     * ```\n     */\n    phone: boolean;\n\n    /**\n     * Whether the device is any type of tablet.\n     * Combines detection across all platforms.\n     * @example\n     * ```ts\n     * // Check if device is a tablet\n     * if (isMobile.tablet) {\n     *     console.log('Running on a mobile tablet');\n     * }\n     * ```\n     */\n    tablet: boolean;\n\n    /**\n     * Whether the device is any type of mobile device.\n     * True if any mobile platform is detected.\n     * @example\n     * ```ts\n     * // Check if device is mobile\n     * if (isMobile.any) {\n     *     console.log('Running on a mobile device');\n     * }\n     * ```\n     */\n    any: boolean;\n};\n\n/**\n * Detects whether the device is mobile and what type of mobile device it is.\n * Provides a comprehensive detection system for mobile platforms and devices.\n * @example\n * ```ts\n * import { isMobile } from 'pixi.js';\n *\n * // Check specific device types\n * if (isMobile.apple.tablet) {\n *    console.log('Running on iPad');\n * }\n *\n * // Check platform categories\n * if (isMobile.android.any) {\n *    console.log('Running on Android');\n * }\n *\n * // Conditional rendering\n * if (isMobile.phone) {\n *    renderer.resolution = 2;\n *    view.style.width = '100vw';\n * }\n * ```\n * @remarks\n * - Detects all major mobile platforms\n * - Distinguishes between phones and tablets\n * - Updates when navigator changes\n * - Common in responsive design\n * @category utils\n * @standard\n * @see {@link isMobileResult} For full type definition\n */\nexport const isMobile: isMobileResult = isMobileCall(globalThis.navigator);\n","export * from './isMobile';\nexport { default } from './isMobile';\n","var appleIphone = /iPhone/i;\nvar appleIpod = /iPod/i;\nvar appleTablet = /iPad/i;\nvar appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nvar androidPhone = /\\bAndroid(?:.+)Mobile\\b/i;\nvar androidTablet = /Android/i;\nvar amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i;\nvar amazonTablet = /Silk/i;\nvar windowsPhone = /Windows Phone/i;\nvar windowsTablet = /\\bWindows(?:.+)ARM\\b/i;\nvar otherBlackBerry = /BlackBerry/i;\nvar otherBlackBerry10 = /BB10/i;\nvar otherOpera = /Opera Mini/i;\nvar otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nvar otherFirefox = /Mobile(?:.+)Firefox\\b/i;\nvar isAppleTabletOnIos13 = function (navigator) {\n    return (typeof navigator !== 'undefined' &&\n        navigator.platform === 'MacIntel' &&\n        typeof navigator.maxTouchPoints === 'number' &&\n        navigator.maxTouchPoints > 1 &&\n        typeof MSStream === 'undefined');\n};\nfunction createMatch(userAgent) {\n    return function (regex) { return regex.test(userAgent); };\n}\nexport default function isMobile(param) {\n    var nav = {\n        userAgent: '',\n        platform: '',\n        maxTouchPoints: 0\n    };\n    if (!param && typeof navigator !== 'undefined') {\n        nav = {\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            maxTouchPoints: navigator.maxTouchPoints || 0\n        };\n    }\n    else if (typeof param === 'string') {\n        nav.userAgent = param;\n    }\n    else if (param && param.userAgent) {\n        nav = {\n            userAgent: param.userAgent,\n            platform: param.platform,\n            maxTouchPoints: param.maxTouchPoints || 0\n        };\n    }\n    var userAgent = nav.userAgent;\n    var tmp = userAgent.split('[FBAN');\n    if (typeof tmp[1] !== 'undefined') {\n        userAgent = tmp[0];\n    }\n    tmp = userAgent.split('Twitter');\n    if (typeof tmp[1] !== 'undefined') {\n        userAgent = tmp[0];\n    }\n    var match = createMatch(userAgent);\n    var result = {\n        apple: {\n            phone: match(appleIphone) && !match(windowsPhone),\n            ipod: match(appleIpod),\n            tablet: !match(appleIphone) &&\n                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone),\n            universal: match(appleUniversal),\n            device: (match(appleIphone) ||\n                match(appleIpod) ||\n                match(appleTablet) ||\n                match(appleUniversal) ||\n                isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone)\n        },\n        amazon: {\n            phone: match(amazonPhone),\n            tablet: !match(amazonPhone) && match(amazonTablet),\n            device: match(amazonPhone) || match(amazonTablet)\n        },\n        android: {\n            phone: (!match(windowsPhone) && match(amazonPhone)) ||\n                (!match(windowsPhone) && match(androidPhone)),\n            tablet: !match(windowsPhone) &&\n                !match(amazonPhone) &&\n                !match(androidPhone) &&\n                (match(amazonTablet) || match(androidTablet)),\n            device: (!match(windowsPhone) &&\n                (match(amazonPhone) ||\n                    match(amazonTablet) ||\n                    match(androidPhone) ||\n                    match(androidTablet))) ||\n                match(/\\bokhttp\\b/i)\n        },\n        windows: {\n            phone: match(windowsPhone),\n            tablet: match(windowsTablet),\n            device: match(windowsPhone) || match(windowsTablet)\n        },\n        other: {\n            blackberry: match(otherBlackBerry),\n            blackberry10: match(otherBlackBerry10),\n            opera: match(otherOpera),\n            firefox: match(otherFirefox),\n            chrome: match(otherChrome),\n            device: match(otherBlackBerry) ||\n                match(otherBlackBerry10) ||\n                match(otherOpera) ||\n                match(otherFirefox) ||\n                match(otherChrome)\n        },\n        any: false,\n        phone: false,\n        tablet: false\n    };\n    result.any =\n        result.apple.device ||\n            result.android.device ||\n            result.windows.device ||\n            result.other.device;\n    result.phone =\n        result.apple.phone || result.android.phone || result.windows.phone;\n    result.tablet =\n        result.apple.tablet || result.android.tablet || result.windows.tablet;\n    return result;\n}\n//# sourceMappingURL=isMobile.js.map","const appleIphone = /iPhone/i;\nconst appleIpod = /iPod/i;\nconst appleTablet = /iPad/i;\nconst appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nconst androidPhone = /\\bAndroid(?:.+)Mobile\\b/i; // Match 'Android' AND 'Mobile'\nconst androidTablet = /Android/i;\nconst amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i; // Match 'Silk' AND 'Mobile'\nconst amazonTablet = /Silk/i;\nconst windowsPhone = /Windows Phone/i;\nconst windowsTablet = /\\bWindows(?:.+)ARM\\b/i; // Match 'Windows' AND 'ARM'\nconst otherBlackBerry = /BlackBerry/i;\nconst otherBlackBerry10 = /BB10/i;\nconst otherOpera = /Opera Mini/i;\nconst otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nconst otherFirefox = /Mobile(?:.+)Firefox\\b/i; // Match 'Mobile' AND 'Firefox'\n\nexport type UserAgent = string;\nexport type Navigator = {\n  userAgent: string;\n  platform: string;\n  maxTouchPoints?: number;\n};\n\nconst isAppleTabletOnIos13 = (navigator?: Navigator): boolean => {\n  return (\n    typeof navigator !== 'undefined' &&\n    navigator.platform === 'MacIntel' &&\n    typeof navigator.maxTouchPoints === 'number' &&\n    navigator.maxTouchPoints > 1 &&\n    typeof MSStream === 'undefined'\n  );\n};\n\nfunction createMatch(userAgent: UserAgent): (regex: RegExp) => boolean {\n  return (regex: RegExp): boolean => regex.test(userAgent);\n}\n\nexport type isMobileResult = {\n  apple: {\n    phone: boolean;\n    ipod: boolean;\n    tablet: boolean;\n    universal: boolean;\n    device: boolean;\n  };\n  amazon: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  android: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  windows: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  other: {\n    blackberry: boolean;\n    blackberry10: boolean;\n    opera: boolean;\n    firefox: boolean;\n    chrome: boolean;\n    device: boolean;\n  };\n  phone: boolean;\n  tablet: boolean;\n  any: boolean;\n};\n\nexport type IsMobileParameter = UserAgent | Navigator;\n\nexport default function isMobile(param?: IsMobileParameter): isMobileResult {\n  let nav: Navigator = {\n    userAgent: '',\n    platform: '',\n    maxTouchPoints: 0,\n  };\n\n  if (!param && typeof navigator !== 'undefined') {\n    nav = {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      maxTouchPoints: navigator.maxTouchPoints || 0,\n    };\n  } else if (typeof param === 'string') {\n    nav.userAgent = param;\n  } else if (param && param.userAgent) {\n    nav = {\n      userAgent: param.userAgent,\n      platform: param.platform,\n      maxTouchPoints: param.maxTouchPoints || 0,\n    };\n  }\n\n  let userAgent = nav.userAgent;\n\n  // Facebook mobile app's integrated browser adds a bunch of strings that\n  // match everything. Strip it out if it exists.\n  let tmp = userAgent.split('[FBAN');\n  if (typeof tmp[1] !== 'undefined') {\n    userAgent = tmp[0];\n  }\n\n  // Twitter mobile app's integrated browser on iPad adds a \"Twitter for\n  // iPhone\" string. Same probably happens on other tablet platforms.\n  // This will confuse detection so strip it out if it exists.\n  tmp = userAgent.split('Twitter');\n  if (typeof tmp[1] !== 'undefined') {\n    userAgent = tmp[0];\n  }\n\n  const match = createMatch(userAgent);\n\n  const result: isMobileResult = {\n    apple: {\n      phone: match(appleIphone) && !match(windowsPhone),\n      ipod: match(appleIpod),\n      tablet:\n        !match(appleIphone) &&\n        (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n        !match(windowsPhone),\n      universal: match(appleUniversal),\n      device:\n        (match(appleIphone) ||\n          match(appleIpod) ||\n          match(appleTablet) ||\n          match(appleUniversal) ||\n          isAppleTabletOnIos13(nav)) &&\n        !match(windowsPhone),\n    },\n    amazon: {\n      phone: match(amazonPhone),\n      tablet: !match(amazonPhone) && match(amazonTablet),\n      device: match(amazonPhone) || match(amazonTablet),\n    },\n    android: {\n      phone:\n        (!match(windowsPhone) && match(amazonPhone)) ||\n        (!match(windowsPhone) && match(androidPhone)),\n      tablet:\n        !match(windowsPhone) &&\n        !match(amazonPhone) &&\n        !match(androidPhone) &&\n        (match(amazonTablet) || match(androidTablet)),\n      device:\n        (!match(windowsPhone) &&\n          (match(amazonPhone) ||\n            match(amazonTablet) ||\n            match(androidPhone) ||\n            match(androidTablet))) ||\n        match(/\\bokhttp\\b/i),\n    },\n    windows: {\n      phone: match(windowsPhone),\n      tablet: match(windowsTablet),\n      device: match(windowsPhone) || match(windowsTablet),\n    },\n    other: {\n      blackberry: match(otherBlackBerry),\n      blackberry10: match(otherBlackBerry10),\n      opera: match(otherOpera),\n      firefox: match(otherFirefox),\n      chrome: match(otherChrome),\n      device:\n        match(otherBlackBerry) ||\n        match(otherBlackBerry10) ||\n        match(otherOpera) ||\n        match(otherFirefox) ||\n        match(otherChrome),\n    },\n    any: false,\n    phone: false,\n    tablet: false,\n  };\n\n  result.any =\n    result.apple.device ||\n    result.android.device ||\n    result.windows.device ||\n    result.other.device;\n  // excludes 'other' devices and ipods, targeting touchscreen phones\n  result.phone =\n    result.apple.phone || result.android.phone || result.windows.phone;\n  result.tablet =\n    result.apple.tablet || result.android.tablet || result.windows.tablet;\n\n  return result;\n}\n","\"use strict\";\nconst accessibilityTarget = {\n  accessible: false,\n  accessibleTitle: null,\n  accessibleHint: null,\n  tabIndex: 0,\n  accessibleType: \"button\",\n  accessibleText: null,\n  accessiblePointerEvents: \"auto\",\n  accessibleChildren: true,\n  _accessibleActive: false,\n  _accessibleDiv: null,\n  _renderId: -1\n};\n\nexport { accessibilityTarget };\n//# sourceMappingURL=accessibilityTarget.mjs.map\n","import type { Container } from '../scene/container/Container';\n\n/**\n * The type of the pointer event to listen for.\n * @category accessibility\n * @standard\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events\n */\nexport type PointerEvents = 'auto'\n| 'none'\n| 'visiblePainted'\n| 'visibleFill'\n| 'visibleStroke'\n| 'visible'\n| 'painted'\n| 'fill'\n| 'stroke'\n| 'all'\n| 'inherit';\n\n/**\n * When `accessible` is enabled on any display object, these properties will affect its accessibility.\n * @example\n * const container = new Container();\n * container.accessible = true;\n * container.accessibleTitle = 'My Container';\n * container.accessibleHint = 'This is a container';\n * container.tabIndex = 0;\n * @category accessibility\n * @standard\n */\nexport interface AccessibleOptions\n{\n    /**\n     * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n     * shadow div with attributes set\n     * @default false\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * ```\n     */\n    accessible: boolean;\n    /**\n     * Sets the title attribute of the shadow div\n     * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'\n     * @type {string}\n     * @default null\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleTitle = 'My Container';\n     * ```\n     */\n    accessibleTitle: string | null;\n    /**\n     * Sets the aria-label attribute of the shadow div\n     * @default null\n     * @advanced\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleHint = 'This is a container';\n     * ```\n     */\n    accessibleHint: string | null;\n    /**\n     * Sets the tabIndex of the shadow div. You can use this to set the order of the\n     * elements when using the tab key to navigate.\n     * @default 0\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.tabIndex = 0;\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.accessible = true;\n     * sprite.tabIndex = 1;\n     * ```\n     */\n    tabIndex: number;\n    /**\n     * Specify the type of div the accessible layer is. Screen readers treat the element differently\n     * depending on this type. Defaults to button.\n     * @default 'button'\n     * @type {string}\n     * @advanced\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleType = 'button'; // or 'link', 'checkbox', etc.\n     * ```\n     */\n    accessibleType: keyof HTMLElementTagNameMap;\n    /**\n     * Specify the pointer-events the accessible div will use\n     * Defaults to auto.\n     * @default 'auto'\n     * @type {PointerEvents}\n     * @advanced\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessiblePointerEvents = 'none'; // or 'auto', 'visiblePainted', etc.\n     * ```\n     */\n    accessiblePointerEvents: PointerEvents;\n\n    /**\n     * Sets the text content of the shadow\n     * @default null\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleText = 'This is a container';\n     * ```\n     */\n    accessibleText: string | null;\n\n    /**\n     * Setting to false will prevent any children inside this container to\n     * be accessible. Defaults to true.\n     * @default true\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleChildren = false; // This will prevent any children from being accessible\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.accessible = true; // This will not work since accessibleChildren is false\n     * ```\n     */\n    accessibleChildren: boolean;\n}\n\n/**\n * The Accessibility object is attached to the {@link Container}.\n * @private\n */\nexport interface AccessibleTarget extends AccessibleOptions\n{\n    /** @private */\n    _accessibleActive: boolean;\n    /** @private */\n    _accessibleDiv: AccessibleHTMLElement | null;\n    /** @private */\n    _renderId: number;\n}\n\n/** @internal */\nexport interface AccessibleHTMLElement extends HTMLElement\n{\n    type?: string;\n    container?: Container;\n}\n\n/**\n * Default property values of accessible objects\n * used by {@link AccessibilitySystem}.\n * @internal\n * @example\n * import { accessibleTarget } from 'pixi.js';\n *\n * function MyObject() {}\n * Object.assign(MyObject.prototype, accessibleTarget);\n */\nexport const accessibilityTarget: AccessibleTarget = {\n    accessible: false,\n    accessibleTitle: null,\n    accessibleHint: null,\n    tabIndex: 0,\n    accessibleType: 'button',\n    accessibleText: null,\n    accessiblePointerEvents: 'auto',\n    accessibleChildren: true,\n    _accessibleActive: false,\n    _accessibleDiv: null,\n    _renderId: -1,\n};\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { Container } from '../scene/container/Container.mjs';\nimport { EventSystem } from './EventSystem.mjs';\nimport { FederatedContainer } from './FederatedEventTarget.mjs';\n\n\"use strict\";\nextensions.add(EventSystem);\nextensions.mixin(Container, FederatedContainer);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { Container } from '../scene/container/Container';\nimport { EventSystem } from './EventSystem';\nimport { FederatedContainer } from './FederatedEventTarget';\n\nextensions.add(EventSystem);\nextensions.mixin(Container, FederatedContainer);\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { EventBoundary } from './EventBoundary.mjs';\nimport { EventsTicker } from './EventTicker.mjs';\nimport { FederatedPointerEvent } from './FederatedPointerEvent.mjs';\nimport { FederatedWheelEvent } from './FederatedWheelEvent.mjs';\n\n\"use strict\";\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER = {\n  touchstart: \"pointerdown\",\n  touchend: \"pointerup\",\n  touchendoutside: \"pointerupoutside\",\n  touchmove: \"pointermove\",\n  touchcancel: \"pointercancel\"\n};\nconst _EventSystem = class _EventSystem {\n  /**\n   * @param {Renderer} renderer\n   */\n  constructor(renderer) {\n    /**\n     * Indicates whether the current device supports touch events according to the W3C Touch Events spec.\n     * This is used to determine the appropriate event handling strategy.\n     * @see {@link https://www.w3.org/TR/touch-events/} W3C Touch Events Specification\n     * @readonly\n     * @default 'ontouchstart' in globalThis\n     */\n    this.supportsTouchEvents = \"ontouchstart\" in globalThis;\n    /**\n     * Indicates whether the current device supports pointer events according to the W3C Pointer Events spec.\n     * Used to optimize event handling and provide more consistent cross-device interaction.\n     * @see {@link https://www.w3.org/TR/pointerevents/} W3C Pointer Events Specification\n     * @readonly\n     * @default !!globalThis.PointerEvent\n     */\n    this.supportsPointerEvents = !!globalThis.PointerEvent;\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link Renderer#view view}.\n     */\n    this.domElement = null;\n    /** The resolution used to convert between the DOM client space into world space. */\n    this.resolution = 1;\n    this.renderer = renderer;\n    this.rootBoundary = new EventBoundary(null);\n    EventsTicker.init(this);\n    this.autoPreventDefault = true;\n    this._eventsAdded = false;\n    this._rootPointerEvent = new FederatedPointerEvent(null);\n    this._rootWheelEvent = new FederatedWheelEvent(null);\n    this.cursorStyles = {\n      default: \"inherit\",\n      pointer: \"pointer\"\n    };\n    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {\n      set: (target, key, value) => {\n        if (key === \"globalMove\") {\n          this.rootBoundary.enableGlobalMoveEvents = value;\n        }\n        target[key] = value;\n        return true;\n      }\n    });\n    this._onPointerDown = this._onPointerDown.bind(this);\n    this._onPointerMove = this._onPointerMove.bind(this);\n    this._onPointerUp = this._onPointerUp.bind(this);\n    this._onPointerOverOut = this._onPointerOverOut.bind(this);\n    this.onWheel = this.onWheel.bind(this);\n  }\n  /**\n   * The default interaction mode for all display objects.\n   * @see Container.eventMode\n   * @type {EventMode}\n   * @readonly\n   * @since 7.2.0\n   */\n  static get defaultEventMode() {\n    return this._defaultEventMode;\n  }\n  /**\n   * Runner init called, view is available at this point.\n   * @ignore\n   */\n  init(options) {\n    const { canvas, resolution } = this.renderer;\n    this.setTargetElement(canvas);\n    this.resolution = resolution;\n    _EventSystem._defaultEventMode = options.eventMode ?? \"passive\";\n    Object.assign(this.features, options.eventFeatures ?? {});\n    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n  }\n  /**\n   * Handle changing resolution.\n   * @ignore\n   */\n  resolutionChange(resolution) {\n    this.resolution = resolution;\n  }\n  /** Destroys all event listeners and detaches the renderer. */\n  destroy() {\n    this.setTargetElement(null);\n    this.renderer = null;\n    this._currentCursor = null;\n  }\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.\n   * @param mode - Cursor mode to set. Can be:\n   * - A CSS cursor string (e.g., 'pointer', 'grab')\n   * - A key from the cursorStyles dictionary\n   * - null/undefined to reset to default\n   * @example\n   * ```ts\n   * // Using predefined cursor styles\n   * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor\n   * app.renderer.events.setCursor('grab');       // Set grab cursor\n   * app.renderer.events.setCursor(null);         // Reset to default\n   *\n   * // Using custom cursor styles\n   * app.renderer.events.cursorStyles.custom = 'url(\"cursor.png\"), auto';\n   * app.renderer.events.setCursor('custom');     // Apply custom cursor\n   *\n   * // Using callback-based cursor\n   * app.renderer.events.cursorStyles.dynamic = (mode) => {\n   *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';\n   * };\n   * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback\n   * ```\n   * @remarks\n   * - Has no effect on OffscreenCanvas except for callback-based cursors\n   * - Caches current cursor to avoid unnecessary DOM updates\n   * - Supports CSS cursor values, style objects, and callback functions\n   * @see {@link EventSystem.cursorStyles} For defining custom cursor styles\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference\n   */\n  setCursor(mode) {\n    mode || (mode = \"default\");\n    let applyStyles = true;\n    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {\n      applyStyles = false;\n    }\n    if (this._currentCursor === mode) {\n      return;\n    }\n    this._currentCursor = mode;\n    const style = this.cursorStyles[mode];\n    if (style) {\n      switch (typeof style) {\n        case \"string\":\n          if (applyStyles) {\n            this.domElement.style.cursor = style;\n          }\n          break;\n        case \"function\":\n          style(mode);\n          break;\n        case \"object\":\n          if (applyStyles) {\n            Object.assign(this.domElement.style, style);\n          }\n          break;\n      }\n    } else if (applyStyles && typeof mode === \"string\" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      this.domElement.style.cursor = mode;\n    }\n  }\n  /**\n   * The global pointer event instance containing the most recent pointer state.\n   * This is useful for accessing pointer information without listening to events.\n   * @example\n   * ```ts\n   * // Access current pointer position at any time\n   * const eventSystem = app.renderer.events;\n   * const pointer = eventSystem.pointer;\n   *\n   * // Get global coordinates\n   * console.log('Position:', pointer.global.x, pointer.global.y);\n   *\n   * // Check button state\n   * console.log('Buttons pressed:', pointer.buttons);\n   *\n   * // Get pointer type and pressure\n   * console.log('Type:', pointer.pointerType);\n   * console.log('Pressure:', pointer.pressure);\n   * ```\n   * @readonly\n   * @since 7.2.0\n   * @see {@link FederatedPointerEvent} For all available pointer properties\n   */\n  get pointer() {\n    return this._rootPointerEvent;\n  }\n  /**\n   * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerDown(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    const events = this._normalizeToPointerData(nativeEvent);\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      const cancelable = nativeEvent.cancelable || !(\"cancelable\" in nativeEvent);\n      if (cancelable) {\n        nativeEvent.preventDefault();\n      }\n    }\n    for (let i = 0, j = events.length; i < j; i++) {\n      const nativeEvent2 = events[i];\n      const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);\n      this.rootBoundary.mapEvent(federatedEvent);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch events.\n   */\n  _onPointerMove(nativeEvent) {\n    if (!this.features.move)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    EventsTicker.pointerMoved();\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerUp(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    let target = nativeEvent.target;\n    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {\n      target = nativeEvent.composedPath()[0];\n    }\n    const outside = target !== this.domElement ? \"outside\" : \"\";\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      event.type += outside;\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n   * @param nativeEvent - The native mouse/pointer/touch event.\n   */\n  _onPointerOverOut(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  /**\n   * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n   * @param nativeEvent - The native wheel event.\n   */\n  onWheel(nativeEvent) {\n    if (!this.features.wheel)\n      return;\n    const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    this.rootBoundary.mapEvent(wheelEvent);\n  }\n  /**\n   * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n   * This method manages the DOM event bindings for the event system, allowing you to\n   * change or remove the target element that receives input events.\n   * > [!IMPORTANT] This will default to the canvas element of the renderer, so you\n   * > should not need to call this unless you are using a custom element.\n   * @param element - The new DOM element to bind events to, or null to remove all event bindings\n   * @example\n   * ```ts\n   * // Set a new canvas element as the target\n   * const canvas = document.createElement('canvas');\n   * app.renderer.events.setTargetElement(canvas);\n   *\n   * // Remove all event bindings\n   * app.renderer.events.setTargetElement(null);\n   *\n   * // Switch to a different canvas\n   * const newCanvas = document.querySelector('#game-canvas');\n   * app.renderer.events.setTargetElement(newCanvas);\n   * ```\n   * @remarks\n   * - Automatically removes event listeners from previous element\n   * - Required for the event system to function\n   * - Safe to call multiple times\n   * @see {@link EventSystem#domElement} The current DOM element\n   * @see {@link EventsTicker} For the ticker system that tracks pointer movement\n   */\n  setTargetElement(element) {\n    this._removeEvents();\n    this.domElement = element;\n    EventsTicker.domElement = element;\n    this._addEvents();\n  }\n  /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n  _addEvents() {\n    if (this._eventsAdded || !this.domElement) {\n      return;\n    }\n    EventsTicker.addTickerListener();\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = \"none\";\n        style.msTouchAction = \"none\";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = \"none\";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.addEventListener(\"pointermove\", this._onPointerMove, true);\n      this.domElement.addEventListener(\"pointerdown\", this._onPointerDown, true);\n      this.domElement.addEventListener(\"pointerleave\", this._onPointerOverOut, true);\n      this.domElement.addEventListener(\"pointerover\", this._onPointerOverOut, true);\n      globalThis.addEventListener(\"pointerup\", this._onPointerUp, true);\n    } else {\n      globalThis.document.addEventListener(\"mousemove\", this._onPointerMove, true);\n      this.domElement.addEventListener(\"mousedown\", this._onPointerDown, true);\n      this.domElement.addEventListener(\"mouseout\", this._onPointerOverOut, true);\n      this.domElement.addEventListener(\"mouseover\", this._onPointerOverOut, true);\n      globalThis.addEventListener(\"mouseup\", this._onPointerUp, true);\n      if (this.supportsTouchEvents) {\n        this.domElement.addEventListener(\"touchstart\", this._onPointerDown, true);\n        this.domElement.addEventListener(\"touchend\", this._onPointerUp, true);\n        this.domElement.addEventListener(\"touchmove\", this._onPointerMove, true);\n      }\n    }\n    this.domElement.addEventListener(\"wheel\", this.onWheel, {\n      passive: true,\n      capture: true\n    });\n    this._eventsAdded = true;\n  }\n  /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n  _removeEvents() {\n    if (!this._eventsAdded || !this.domElement) {\n      return;\n    }\n    EventsTicker.removeTickerListener();\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = \"\";\n        style.msTouchAction = \"\";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = \"\";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.removeEventListener(\"pointermove\", this._onPointerMove, true);\n      this.domElement.removeEventListener(\"pointerdown\", this._onPointerDown, true);\n      this.domElement.removeEventListener(\"pointerleave\", this._onPointerOverOut, true);\n      this.domElement.removeEventListener(\"pointerover\", this._onPointerOverOut, true);\n      globalThis.removeEventListener(\"pointerup\", this._onPointerUp, true);\n    } else {\n      globalThis.document.removeEventListener(\"mousemove\", this._onPointerMove, true);\n      this.domElement.removeEventListener(\"mousedown\", this._onPointerDown, true);\n      this.domElement.removeEventListener(\"mouseout\", this._onPointerOverOut, true);\n      this.domElement.removeEventListener(\"mouseover\", this._onPointerOverOut, true);\n      globalThis.removeEventListener(\"mouseup\", this._onPointerUp, true);\n      if (this.supportsTouchEvents) {\n        this.domElement.removeEventListener(\"touchstart\", this._onPointerDown, true);\n        this.domElement.removeEventListener(\"touchend\", this._onPointerUp, true);\n        this.domElement.removeEventListener(\"touchmove\", this._onPointerMove, true);\n      }\n    }\n    this.domElement.removeEventListener(\"wheel\", this.onWheel, true);\n    this.domElement = null;\n    this._eventsAdded = false;\n  }\n  /**\n   * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.\n   * This takes into account the current scale, position, and resolution of the DOM element.\n   * @param point - The point to store the mapped coordinates in\n   * @param x - The x coordinate in DOM/client space\n   * @param y - The y coordinate in DOM/client space\n   * @example\n   * ```ts\n   * // Map mouse coordinates to PixiJS space\n   * const point = new Point();\n   * app.renderer.events.mapPositionToPoint(\n   *     point,\n   *     event.clientX,\n   *     event.clientY\n   * );\n   * console.log('Mapped position:', point.x, point.y);\n   *\n   * // Using with pointer events\n   * sprite.on('pointermove', (event) => {\n   *     // event.global already contains mapped coordinates\n   *     console.log('Global:', event.global.x, event.global.y);\n   *\n   *     // Map to local coordinates\n   *     const local = event.getLocalPosition(sprite);\n   *     console.log('Local:', local.x, local.y);\n   * });\n   * ```\n   * @remarks\n   * - Accounts for element scaling and positioning\n   * - Adjusts for device pixel ratio/resolution\n   */\n  mapPositionToPoint(point, x, y) {\n    const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {\n      x: 0,\n      y: 0,\n      width: this.domElement.width,\n      height: this.domElement.height,\n      left: 0,\n      top: 0\n    };\n    const resolutionMultiplier = 1 / this.resolution;\n    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;\n    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;\n  }\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   * @param event - The original event data from a touch or mouse event\n   * @returns An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  _normalizeToPointerData(event) {\n    const normalizedEvents = [];\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n        if (typeof touch.button === \"undefined\")\n          touch.button = 0;\n        if (typeof touch.buttons === \"undefined\")\n          touch.buttons = 1;\n        if (typeof touch.isPrimary === \"undefined\") {\n          touch.isPrimary = event.touches.length === 1 && event.type === \"touchstart\";\n        }\n        if (typeof touch.width === \"undefined\")\n          touch.width = touch.radiusX || 1;\n        if (typeof touch.height === \"undefined\")\n          touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === \"undefined\")\n          touch.tiltX = 0;\n        if (typeof touch.tiltY === \"undefined\")\n          touch.tiltY = 0;\n        if (typeof touch.pointerType === \"undefined\")\n          touch.pointerType = \"touch\";\n        if (typeof touch.pointerId === \"undefined\")\n          touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === \"undefined\")\n          touch.pressure = touch.force || 0.5;\n        if (typeof touch.twist === \"undefined\")\n          touch.twist = 0;\n        if (typeof touch.tangentialPressure === \"undefined\")\n          touch.tangentialPressure = 0;\n        if (typeof touch.layerX === \"undefined\")\n          touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === \"undefined\")\n          touch.layerY = touch.offsetY = touch.clientY;\n        touch.isNormalized = true;\n        touch.type = event.type;\n        normalizedEvents.push(touch);\n      }\n    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n      const tempEvent = event;\n      if (typeof tempEvent.isPrimary === \"undefined\")\n        tempEvent.isPrimary = true;\n      if (typeof tempEvent.width === \"undefined\")\n        tempEvent.width = 1;\n      if (typeof tempEvent.height === \"undefined\")\n        tempEvent.height = 1;\n      if (typeof tempEvent.tiltX === \"undefined\")\n        tempEvent.tiltX = 0;\n      if (typeof tempEvent.tiltY === \"undefined\")\n        tempEvent.tiltY = 0;\n      if (typeof tempEvent.pointerType === \"undefined\")\n        tempEvent.pointerType = \"mouse\";\n      if (typeof tempEvent.pointerId === \"undefined\")\n        tempEvent.pointerId = MOUSE_POINTER_ID;\n      if (typeof tempEvent.pressure === \"undefined\")\n        tempEvent.pressure = 0.5;\n      if (typeof tempEvent.twist === \"undefined\")\n        tempEvent.twist = 0;\n      if (typeof tempEvent.tangentialPressure === \"undefined\")\n        tempEvent.tangentialPressure = 0;\n      tempEvent.isNormalized = true;\n      normalizedEvents.push(tempEvent);\n    } else {\n      normalizedEvents.push(event);\n    }\n    return normalizedEvents;\n  }\n  /**\n   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n   *\n   * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n   * multiple native wheel events.\n   * @param nativeEvent - The native wheel event that occurred on the canvas.\n   * @returns A federated wheel event.\n   */\n  normalizeWheelEvent(nativeEvent) {\n    const event = this._rootWheelEvent;\n    this._transferMouseData(event, nativeEvent);\n    event.deltaX = nativeEvent.deltaX;\n    event.deltaY = nativeEvent.deltaY;\n    event.deltaZ = nativeEvent.deltaZ;\n    event.deltaMode = nativeEvent.deltaMode;\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.nativeEvent = nativeEvent;\n    event.type = nativeEvent.type;\n    return event;\n  }\n  /**\n   * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n   * @param event\n   * @param nativeEvent\n   */\n  _bootstrapEvent(event, nativeEvent) {\n    event.originalEvent = null;\n    event.nativeEvent = nativeEvent;\n    event.pointerId = nativeEvent.pointerId;\n    event.width = nativeEvent.width;\n    event.height = nativeEvent.height;\n    event.isPrimary = nativeEvent.isPrimary;\n    event.pointerType = nativeEvent.pointerType;\n    event.pressure = nativeEvent.pressure;\n    event.tangentialPressure = nativeEvent.tangentialPressure;\n    event.tiltX = nativeEvent.tiltX;\n    event.tiltY = nativeEvent.tiltY;\n    event.twist = nativeEvent.twist;\n    this._transferMouseData(event, nativeEvent);\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.isTrusted = nativeEvent.isTrusted;\n    if (event.type === \"pointerleave\") {\n      event.type = \"pointerout\";\n    }\n    if (event.type.startsWith(\"mouse\")) {\n      event.type = event.type.replace(\"mouse\", \"pointer\");\n    }\n    if (event.type.startsWith(\"touch\")) {\n      event.type = TOUCH_TO_POINTER[event.type] || event.type;\n    }\n    return event;\n  }\n  /**\n   * Transfers base & mouse event data from the `nativeEvent` to the federated event.\n   * @param event\n   * @param nativeEvent\n   */\n  _transferMouseData(event, nativeEvent) {\n    event.isTrusted = nativeEvent.isTrusted;\n    event.srcElement = nativeEvent.srcElement;\n    event.timeStamp = performance.now();\n    event.type = nativeEvent.type;\n    event.altKey = nativeEvent.altKey;\n    event.button = nativeEvent.button;\n    event.buttons = nativeEvent.buttons;\n    event.client.x = nativeEvent.clientX;\n    event.client.y = nativeEvent.clientY;\n    event.ctrlKey = nativeEvent.ctrlKey;\n    event.metaKey = nativeEvent.metaKey;\n    event.movement.x = nativeEvent.movementX;\n    event.movement.y = nativeEvent.movementY;\n    event.page.x = nativeEvent.pageX;\n    event.page.y = nativeEvent.pageY;\n    event.relatedTarget = null;\n    event.shiftKey = nativeEvent.shiftKey;\n  }\n};\n/** @ignore */\n_EventSystem.extension = {\n  name: \"events\",\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.CanvasSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  priority: -1\n};\n/**\n * The event features that are enabled by the EventSystem\n * @since 7.2.0\n * @example\n * ```ts\n * import { EventSystem, EventSystemFeatures } from 'pixi.js';\n * // Access the default event features\n * EventSystem.defaultEventFeatures = {\n *     // Enable pointer movement events\n *     move: true,\n *     // Enable global pointer move events\n *     globalMove: true,\n *     // Enable click events\n *     click: true,\n *     // Enable wheel events\n *     wheel: true,\n * };\n * ```\n */\n_EventSystem.defaultEventFeatures = {\n  /** Enables pointer events associated with pointer movement. */\n  move: true,\n  /** Enables global pointer move events. */\n  globalMove: true,\n  /** Enables pointer events associated with clicking. */\n  click: true,\n  /** Enables wheel events. */\n  wheel: true\n};\nlet EventSystem = _EventSystem;\n\nexport { EventSystem };\n//# sourceMappingURL=EventSystem.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\nimport { EventBoundary } from './EventBoundary';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { PointData } from '../maths/point/PointData';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { PixiTouch } from './FederatedEvent';\nimport type { EventMode } from './FederatedEventTarget';\nimport type { FederatedMouseEvent } from './FederatedMouseEvent';\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER: Record<string, string> = {\n    touchstart: 'pointerdown',\n    touchend: 'pointerup',\n    touchendoutside: 'pointerupoutside',\n    touchmove: 'pointermove',\n    touchcancel: 'pointercancel',\n};\n\n/**\n * Options for configuring the PixiJS event system. These options control how the event system\n * handles different types of interactions and event propagation.\n * @example\n * ```ts\n * // Basic event system configuration\n * const app = new Application();\n * await app.init({\n *     // Configure default interaction mode\n *     eventMode: 'static',\n *\n *     // Configure event features\n *     eventFeatures: {\n *         move: true,           // Enable pointer movement events\n *         globalMove: false,    // Disable global move events\n *         click: true,          // Enable click events\n *         wheel: true          // Enable wheel/scroll events\n *     }\n * });\n *\n * // Access event system after initialization\n * const eventSystem = app.renderer.events;\n * console.log(eventSystem.features); // Check enabled features\n * ```\n * @see {@link EventSystem} For the main event system implementation\n * @see {@link EventMode} For interaction mode details\n * @see {@link EventSystemFeatures} For all available feature options\n * @advanced\n * @category events\n */\nexport interface EventSystemOptions\n{\n    /**\n     * The default event mode for all display objects.\n     * Controls how objects respond to interaction events.\n     *\n     * Possible values:\n     * - `'none'`: No interaction events\n     * - `'passive'`: Only container's children receive events (default)\n     * - `'auto'`: Receives events when parent is interactive\n     * - `'static'`: Standard interaction events\n     * - `'dynamic'`: Like static but with additional synthetic events\n     * @default 'passive'\n     */\n    eventMode?: EventMode;\n\n    /**\n     * Configuration for enabling/disabling specific event features.\n     * Use this to optimize performance by turning off unused functionality.\n     * @example\n     * ```ts\n     * const app = new Application();\n     * await app.init({\n     *     eventFeatures: {\n     *         // Core interaction events\n     *         move: true,        // Pointer/mouse/touch movement\n     *         click: true,       // Click/tap events\n     *         wheel: true,       // Mouse wheel/scroll events\n     *         // Global tracking\n     *         globalMove: false  // Global pointer movement\n     *     }\n     * });\n     * ```\n     */\n    eventFeatures?: Partial<EventSystemFeatures>;\n}\n\n/**\n * The event features that are enabled by the EventSystem. These features control\n * different types of interaction events in your PixiJS application.\n * @example\n * ```ts\n * // Configure features during application initialization\n * const app = new Application();\n * await app.init({\n *     eventFeatures: {\n *         // Basic interaction events\n *         move: true,        // Enable pointer movement tracking\n *         click: true,       // Enable click/tap events\n *         wheel: true,       // Enable mouse wheel/scroll events\n *         // Advanced features\n *         globalMove: false  // Disable global move tracking for performance\n *     }\n * });\n *\n * // Or configure after initialization\n * app.renderer.events.features.move = false;      // Disable movement events\n * app.renderer.events.features.globalMove = true; // Enable global tracking\n * ```\n * @since 7.2.0\n * @category events\n * @advanced\n */\nexport interface EventSystemFeatures\n{\n    /**\n     * Enables pointer events associated with pointer movement.\n     *\n     * When enabled, these events will fire:\n     * - `pointermove` / `mousemove` / `touchmove`\n     * - `pointerout` / `mouseout`\n     * - `pointerover` / `mouseover`\n     * @example\n     * ```ts\n     * // Enable movement events\n     * app.renderer.events.features.move = true;\n     *\n     * // Listen for movement\n     * sprite.on('pointermove', (event) => {\n     *     console.log('Pointer position:', event.global.x, event.global.y);\n     * });\n     * ```\n     * @default true\n     */\n    move: boolean;\n\n    /**\n     * Enables global pointer move events that fire regardless of target.\n     *\n     * When enabled, these events will fire:\n     * - `globalpointermove`\n     * - `globalmousemove`\n     * - `globaltouchmove`\n     * @example\n     * ```ts\n     * // Enable global tracking\n     * app.renderer.events.features.globalMove = true;\n     *\n     * // Track pointer globally\n     * sprite.on('globalpointermove', (event) => {\n     *     // Fires even when pointer is not over sprite\n     *     console.log('Global position:', event.global.x, event.global.y);\n     * });\n     * ```\n     * @default true\n     */\n    globalMove: boolean;\n    /**\n     * Enables pointer events associated with clicking/tapping.\n     *\n     * When enabled, these events will fire:\n     * - `pointerdown` / `mousedown` / `touchstart` / `rightdown`\n     * - `pointerup` / `mouseup` / `touchend` / `rightup`\n     * - `pointerupoutside` / `mouseupoutside` / `touchendoutside` / `rightupoutside`\n     * - `click` / `tap`\n     * @example\n     * ```ts\n     * // Enable click events\n     * app.renderer.events.features.click = true;\n     *\n     * // Handle clicks\n     * sprite.on('click', (event) => {\n     *     console.log('Clicked at:', event.global.x, event.global.y);\n     * });\n     * ```\n     * @default true\n     */\n    click: boolean;\n    /**\n     * Enables mouse wheel/scroll events.\n     * @example\n     * ```ts\n     * // Enable wheel events\n     * app.renderer.events.features.wheel = true;\n     *\n     * // Handle scrolling\n     * sprite.on('wheel', (event) => {\n     *     // Zoom based on scroll direction\n     *     const scale = 1 + (event.deltaY / 1000);\n     *     sprite.scale.set(sprite.scale.x * scale);\n     * });\n     * ```\n     * @default true\n     */\n    wheel: boolean;\n}\n\n/**\n * The system for handling UI events in PixiJS applications. This class manages mouse, touch, and pointer events,\n * normalizing them into a consistent event model.\n * @example\n * ```ts\n * // Access event system through renderer\n * const eventSystem = app.renderer.events;\n *\n * // Configure event features\n * eventSystem.features.globalMove = false;  // Disable global move events\n * eventSystem.features.click = true;        // Enable click events\n *\n * // Set custom cursor styles\n * eventSystem.cursorStyles.default = 'pointer';\n * eventSystem.cursorStyles.grab = 'grab';\n *\n * // Get current pointer position\n * const pointer = eventSystem.pointer;\n * console.log(pointer.global.x, pointer.global.y);\n * ```\n *\n * Features:\n * - Normalizes browser events into consistent format\n * - Supports mouse, touch, and pointer events\n * - Handles event delegation and bubbling\n * - Provides cursor management\n * - Configurable event features\n * @see {@link EventBoundary} For event propagation and handling\n * @see {@link FederatedEvent} For the base event class\n * @see {@link EventMode} For interaction modes\n * @category events\n * @standard\n */\nexport class EventSystem implements System<EventSystemOptions>\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'events',\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.CanvasSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        priority: -1,\n    };\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * @since 7.2.0\n     * @example\n     * ```ts\n     * import { EventSystem, EventSystemFeatures } from 'pixi.js';\n     * // Access the default event features\n     * EventSystem.defaultEventFeatures = {\n     *     // Enable pointer movement events\n     *     move: true,\n     *     // Enable global pointer move events\n     *     globalMove: true,\n     *     // Enable click events\n     *     click: true,\n     *     // Enable wheel events\n     *     wheel: true,\n     * };\n     * ```\n     */\n    public static defaultEventFeatures: EventSystemFeatures = {\n        /** Enables pointer events associated with pointer movement. */\n        move: true,\n        /** Enables global pointer move events. */\n        globalMove: true,\n        /** Enables pointer events associated with clicking. */\n        click: true,\n        /** Enables wheel events. */\n        wheel: true,\n    };\n\n    private static _defaultEventMode: EventMode;\n\n    /**\n     * The default interaction mode for all display objects.\n     * @see Container.eventMode\n     * @type {EventMode}\n     * @readonly\n     * @since 7.2.0\n     */\n    public static get defaultEventMode()\n    {\n        return this._defaultEventMode;\n    }\n\n    /**\n     * The {@link EventBoundary} for the stage.\n     *\n     * The {@link EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to\n     * the last rendered object before any event processing is initiated. This means the main scene\n     * needs to be rendered atleast once before UI events will start propagating.\n     *\n     * The root boundary should only be changed during initialization. Otherwise, any state held by the\n     * event boundary may be lost (like hovered & pressed Containers).\n     * @advanced\n     */\n    public readonly rootBoundary: EventBoundary;\n\n    /**\n     * Indicates whether the current device supports touch events according to the W3C Touch Events spec.\n     * This is used to determine the appropriate event handling strategy.\n     * @see {@link https://www.w3.org/TR/touch-events/} W3C Touch Events Specification\n     * @readonly\n     * @default 'ontouchstart' in globalThis\n     */\n    public readonly supportsTouchEvents = 'ontouchstart' in globalThis;\n\n    /**\n     * Indicates whether the current device supports pointer events according to the W3C Pointer Events spec.\n     * Used to optimize event handling and provide more consistent cross-device interaction.\n     * @see {@link https://www.w3.org/TR/pointerevents/} W3C Pointer Events Specification\n     * @readonly\n     * @default !!globalThis.PointerEvent\n     */\n    public readonly supportsPointerEvents = !!globalThis.PointerEvent;\n\n    /**\n     * Controls whether default browser actions are automatically prevented on pointer events.\n     * When true, prevents default browser actions from occurring on pointer events.\n     * @remarks\n     * - Does not apply to pointer events for backwards compatibility\n     * - preventDefault on pointer events stops mouse events from firing\n     * - For every pointer event, there will always be either a mouse or touch event alongside it\n     * - Setting this to false allows default browser actions (text selection, dragging images, etc.)\n     * @example\n     * ```ts\n     * // Allow default browser actions\n     * app.renderer.events.autoPreventDefault = false;\n     *\n     * // Block default actions (default)\n     * app.renderer.events.autoPreventDefault = true;\n     *\n     * // Example with text selection\n     * const text = new Text('Selectable text');\n     * text.eventMode = 'static';\n     * app.renderer.events.autoPreventDefault = false; // Allow text selection\n     * ```\n     * @default true\n     */\n    public autoPreventDefault: boolean;\n\n    /**\n     * Dictionary of custom cursor styles that can be used across the application.\n     * Used to define how different cursor modes are handled when interacting with display objects.\n     * @example\n     * ```ts\n     * // Access event system through renderer\n     * const eventSystem = app.renderer.events;\n     *\n     * // Set string-based cursor styles\n     * eventSystem.cursorStyles.default = 'pointer';\n     * eventSystem.cursorStyles.hover = 'grab';\n     * eventSystem.cursorStyles.drag = 'grabbing';\n     *\n     * // Use CSS object for complex styling\n     * eventSystem.cursorStyles.custom = {\n     *     cursor: 'url(\"custom.png\") 2 2, auto',\n     *     userSelect: 'none'\n     * };\n     *\n     * // Use a url for custom cursors\n     * const defaultIcon = 'url(\\'https://pixijs.com/assets/bunny.png\\'),auto';\n     * eventSystem.cursorStyles.icon = defaultIcon;\n     *\n     * // Use callback function for dynamic cursors\n     * eventSystem.cursorStyles.dynamic = (mode) => {\n     *     // Update cursor based on mode\n     *     document.body.style.cursor = mode === 'hover'\n     *         ? 'pointer'\n     *         : 'default';\n     * };\n     *\n     * // Apply cursor style to a sprite\n     * sprite.cursor = 'hover'; // Will use the hover style defined above\n     * sprite.cursor = 'icon'; // Will apply the icon cursor\n     * sprite.cursor = 'custom'; // Will apply the custom CSS styles\n     * sprite.cursor = 'drag'; // Will apply the grabbing cursor\n     * sprite.cursor = 'default'; // Will apply the default pointer cursor\n     * sprite.cursor = 'dynamic'; // Will call the dynamic function\n     * ```\n     * @remarks\n     * - Strings are treated as CSS cursor values\n     * - Objects are applied as CSS styles to the DOM element\n     * - Functions are called directly for custom cursor handling\n     * - Default styles for 'default' and 'pointer' are provided\n     * @default\n     * ```ts\n     * {\n     *     default: 'inherit',\n     *     pointer: 'pointer' // Default cursor styles\n     * }\n     * ```\n     */\n    public cursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link Renderer#view view}.\n     */\n    public domElement: HTMLElement = null;\n\n    /** The resolution used to convert between the DOM client space into world space. */\n    public resolution = 1;\n\n    /** The renderer managing this {@link EventSystem}. */\n    public renderer: Renderer;\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * @since 7.2.0\n     * @example\n     * const app = new Application()\n     * app.renderer.events.features.globalMove = false\n     *\n     * // to override all features use Object.assign\n     * Object.assign(app.renderer.events.features, {\n     *  move: false,\n     *  globalMove: false,\n     *  click: false,\n     *  wheel: false,\n     * })\n     */\n    public readonly features: EventSystemFeatures;\n\n    private _currentCursor: string;\n    private readonly _rootPointerEvent: FederatedPointerEvent;\n    private readonly _rootWheelEvent: FederatedWheelEvent;\n    private _eventsAdded: boolean;\n\n    /**\n     * @param {Renderer} renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.rootBoundary = new EventBoundary(null);\n        EventsTicker.init(this);\n\n        this.autoPreventDefault = true;\n        this._eventsAdded = false;\n\n        this._rootPointerEvent = new FederatedPointerEvent(null);\n        this._rootWheelEvent = new FederatedWheelEvent(null);\n\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n\n        this.features = new Proxy({ ...EventSystem.defaultEventFeatures }, {\n            set: (target, key, value) =>\n            {\n                if (key === 'globalMove')\n                {\n                    this.rootBoundary.enableGlobalMoveEvents = value;\n                }\n                target[key as keyof EventSystemFeatures] = value;\n\n                return true;\n            }\n        });\n\n        this._onPointerDown = this._onPointerDown.bind(this);\n        this._onPointerMove = this._onPointerMove.bind(this);\n        this._onPointerUp = this._onPointerUp.bind(this);\n        this._onPointerOverOut = this._onPointerOverOut.bind(this);\n        this.onWheel = this.onWheel.bind(this);\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options: EventSystemOptions): void\n    {\n        const { canvas, resolution } = this.renderer;\n\n        this.setTargetElement(canvas as HTMLCanvasElement);\n        this.resolution = resolution;\n        EventSystem._defaultEventMode = options.eventMode ?? 'passive';\n        Object.assign(this.features, options.eventFeatures ?? {});\n        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n    }\n\n    /**\n     * Handle changing resolution.\n     * @ignore\n     */\n    public resolutionChange(resolution: number): void\n    {\n        this.resolution = resolution;\n    }\n\n    /** Destroys all event listeners and detaches the renderer. */\n    public destroy(): void\n    {\n        this.setTargetElement(null);\n        this.renderer = null;\n        this._currentCursor = null;\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.\n     * @param mode - Cursor mode to set. Can be:\n     * - A CSS cursor string (e.g., 'pointer', 'grab')\n     * - A key from the cursorStyles dictionary\n     * - null/undefined to reset to default\n     * @example\n     * ```ts\n     * // Using predefined cursor styles\n     * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor\n     * app.renderer.events.setCursor('grab');       // Set grab cursor\n     * app.renderer.events.setCursor(null);         // Reset to default\n     *\n     * // Using custom cursor styles\n     * app.renderer.events.cursorStyles.custom = 'url(\"cursor.png\"), auto';\n     * app.renderer.events.setCursor('custom');     // Apply custom cursor\n     *\n     * // Using callback-based cursor\n     * app.renderer.events.cursorStyles.dynamic = (mode) => {\n     *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';\n     * };\n     * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback\n     * ```\n     * @remarks\n     * - Has no effect on OffscreenCanvas except for callback-based cursors\n     * - Caches current cursor to avoid unnecessary DOM updates\n     * - Supports CSS cursor values, style objects, and callback functions\n     * @see {@link EventSystem.cursorStyles} For defining custom cursor styles\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference\n     */\n    public setCursor(mode: string): void\n    {\n        mode ||= 'default';\n        let applyStyles = true;\n\n        // offscreen canvas does not support setting styles, but cursor modes can be functions,\n        // in order to handle pixi rendered cursors, so we can't bail\n        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas)\n        {\n            applyStyles = false;\n        }\n        // if the mode didn't actually change, bail early\n        if (this._currentCursor === mode)\n        {\n            return;\n        }\n        this._currentCursor = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    if (applyStyles)\n                    {\n                        this.domElement.style.cursor = style;\n                    }\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    if (applyStyles)\n                    {\n                        Object.assign(this.domElement.style, style);\n                    }\n                    break;\n            }\n        }\n        else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.domElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * The global pointer event instance containing the most recent pointer state.\n     * This is useful for accessing pointer information without listening to events.\n     * @example\n     * ```ts\n     * // Access current pointer position at any time\n     * const eventSystem = app.renderer.events;\n     * const pointer = eventSystem.pointer;\n     *\n     * // Get global coordinates\n     * console.log('Position:', pointer.global.x, pointer.global.y);\n     *\n     * // Check button state\n     * console.log('Buttons pressed:', pointer.buttons);\n     *\n     * // Get pointer type and pressure\n     * console.log('Type:', pointer.pointerType);\n     * console.log('Pressure:', pointer.pressure);\n     * ```\n     * @readonly\n     * @since 7.2.0\n     * @see {@link FederatedPointerEvent} For all available pointer properties\n     */\n    public get pointer(): Readonly<FederatedPointerEvent>\n    {\n        return this._rootPointerEvent;\n    }\n\n    /**\n     * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerDown(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const events = this._normalizeToPointerData(nativeEvent);\n\n        /*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && (events[0] as any).isNormalized)\n        {\n            const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);\n\n            if (cancelable)\n            {\n                nativeEvent.preventDefault();\n            }\n        }\n\n        for (let i = 0, j = events.length; i < j; i++)\n        {\n            const nativeEvent = events[i];\n            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent);\n\n            this.rootBoundary.mapEvent(federatedEvent);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch events.\n     */\n    private _onPointerMove(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.move) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        EventsTicker.pointerMoved();\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerUp(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        let target = nativeEvent.target;\n\n        // if in shadow DOM use composedPath to access target\n        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0)\n        {\n            target = nativeEvent.composedPath()[0];\n        }\n\n        const outside = target !== this.domElement ? 'outside' : '';\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            event.type += outside;\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerOverOut(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n     * @param nativeEvent - The native wheel event.\n     */\n    protected onWheel(nativeEvent: WheelEvent): void\n    {\n        if (!this.features.wheel) return;\n        const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        this.rootBoundary.mapEvent(wheelEvent);\n    }\n\n    /**\n     * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n     * This method manages the DOM event bindings for the event system, allowing you to\n     * change or remove the target element that receives input events.\n     * > [!IMPORTANT] This will default to the canvas element of the renderer, so you\n     * > should not need to call this unless you are using a custom element.\n     * @param element - The new DOM element to bind events to, or null to remove all event bindings\n     * @example\n     * ```ts\n     * // Set a new canvas element as the target\n     * const canvas = document.createElement('canvas');\n     * app.renderer.events.setTargetElement(canvas);\n     *\n     * // Remove all event bindings\n     * app.renderer.events.setTargetElement(null);\n     *\n     * // Switch to a different canvas\n     * const newCanvas = document.querySelector('#game-canvas');\n     * app.renderer.events.setTargetElement(newCanvas);\n     * ```\n     * @remarks\n     * - Automatically removes event listeners from previous element\n     * - Required for the event system to function\n     * - Safe to call multiple times\n     * @see {@link EventSystem#domElement} The current DOM element\n     * @see {@link EventsTicker} For the ticker system that tracks pointer movement\n     */\n    public setTargetElement(element: HTMLElement): void\n    {\n        this._removeEvents();\n        this.domElement = element;\n        EventsTicker.domElement = element;\n        this._addEvents();\n    }\n\n    /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n    private _addEvents(): void\n    {\n        if (this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.addTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = 'none';\n                style.msTouchAction = 'none';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = 'none';\n            }\n        }\n\n        /*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.addEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.addEventListener('pointerdown', this._onPointerDown, true);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.domElement.addEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.addEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.addEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.addEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.addEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.addEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.addEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.addEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.addEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.addEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.addEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.addEventListener('touchend', this._onPointerUp, true);\n                this.domElement.addEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.addEventListener('wheel', this.onWheel, {\n            passive: true,\n            capture: true,\n        });\n\n        this._eventsAdded = true;\n    }\n\n    /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n    private _removeEvents(): void\n    {\n        if (!this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.removeTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        // offscreen canvas does not have style, so check first\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = '';\n                style.msTouchAction = '';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = '';\n            }\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.removeEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.removeEventListener('pointerdown', this._onPointerDown, true);\n            this.domElement.removeEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.removeEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.removeEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.removeEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.removeEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.removeEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.removeEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.removeEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.removeEventListener('touchend', this._onPointerUp, true);\n                this.domElement.removeEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.removeEventListener('wheel', this.onWheel, true);\n\n        this.domElement = null;\n        this._eventsAdded = false;\n    }\n\n    /**\n     * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.\n     * This takes into account the current scale, position, and resolution of the DOM element.\n     * @param point - The point to store the mapped coordinates in\n     * @param x - The x coordinate in DOM/client space\n     * @param y - The y coordinate in DOM/client space\n     * @example\n     * ```ts\n     * // Map mouse coordinates to PixiJS space\n     * const point = new Point();\n     * app.renderer.events.mapPositionToPoint(\n     *     point,\n     *     event.clientX,\n     *     event.clientY\n     * );\n     * console.log('Mapped position:', point.x, point.y);\n     *\n     * // Using with pointer events\n     * sprite.on('pointermove', (event) => {\n     *     // event.global already contains mapped coordinates\n     *     console.log('Global:', event.global.x, event.global.y);\n     *\n     *     // Map to local coordinates\n     *     const local = event.getLocalPosition(sprite);\n     *     console.log('Local:', local.x, local.y);\n     * });\n     * ```\n     * @remarks\n     * - Accounts for element scaling and positioning\n     * - Adjusts for device pixel ratio/resolution\n     */\n    public mapPositionToPoint(point: PointData, x: number, y: number): void\n    {\n        const rect = this.domElement.isConnected\n            ? this.domElement.getBoundingClientRect()\n            : {\n                x: 0,\n                y: 0,\n                width: (this.domElement as any).width,\n                height: (this.domElement as any).height,\n                left: 0,\n                top: 0\n            };\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * ((this.domElement as any).width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * ((this.domElement as any).height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     * @param event - The original event data from a touch or mouse event\n     * @returns An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    private _normalizeToPointerData(event: TouchEvent | MouseEvent | PointerEvent): PointerEvent[]\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i] as PixiTouch;\n\n                if (typeof touch.button === 'undefined') touch.button = 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = 1;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n                touch.type = event.type;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (!globalThis.MouseEvent\n            || (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))))\n        {\n            const tempEvent = event as PixiPointerEvent;\n\n            if (typeof tempEvent.isPrimary === 'undefined') tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === 'undefined') tempEvent.width = 1;\n            if (typeof tempEvent.height === 'undefined') tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === 'undefined') tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === 'undefined') tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === 'undefined') tempEvent.pointerType = 'mouse';\n            if (typeof tempEvent.pointerId === 'undefined') tempEvent.pointerId = MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === 'undefined') tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === 'undefined') tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === 'undefined') tempEvent.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            tempEvent.isNormalized = true;\n\n            normalizedEvents.push(tempEvent);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents as PointerEvent[];\n    }\n\n    /**\n     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n     *\n     * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n     * multiple native wheel events.\n     * @param nativeEvent - The native wheel event that occurred on the canvas.\n     * @returns A federated wheel event.\n     */\n    protected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent\n    {\n        const event = this._rootWheelEvent;\n\n        this._transferMouseData(event, nativeEvent);\n\n        // When WheelEvent is triggered by scrolling with mouse wheel, reading WheelEvent.deltaMode\n        // before deltaX/deltaY/deltaZ on Firefox will result in WheelEvent.DOM_DELTA_LINE (1),\n        // while reading WheelEvent.deltaMode after deltaX/deltaY/deltaZ on Firefox or reading\n        // in any order on other browsers will result in WheelEvent.DOM_DELTA_PIXEL (0).\n        // Therefore, we need to read WheelEvent.deltaMode after deltaX/deltaY/deltaZ in order to\n        // make its behavior more consistent across browsers.\n        // @see https://github.com/pixijs/pixijs/issues/8970\n        event.deltaX = nativeEvent.deltaX;\n        event.deltaY = nativeEvent.deltaY;\n        event.deltaZ = nativeEvent.deltaZ;\n        event.deltaMode = nativeEvent.deltaMode;\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n\n        event.nativeEvent = nativeEvent;\n        event.type = nativeEvent.type;\n\n        return event;\n    }\n\n    /**\n     * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n     * @param event\n     * @param nativeEvent\n     */\n    private _bootstrapEvent(event: FederatedPointerEvent, nativeEvent: PointerEvent): FederatedPointerEvent\n    {\n        event.originalEvent = null;\n        event.nativeEvent = nativeEvent;\n\n        event.pointerId = nativeEvent.pointerId;\n        event.width = nativeEvent.width;\n        event.height = nativeEvent.height;\n        event.isPrimary = nativeEvent.isPrimary;\n        event.pointerType = nativeEvent.pointerType;\n        event.pressure = nativeEvent.pressure;\n        event.tangentialPressure = nativeEvent.tangentialPressure;\n        event.tiltX = nativeEvent.tiltX;\n        event.tiltY = nativeEvent.tiltY;\n        event.twist = nativeEvent.twist;\n        this._transferMouseData(event, nativeEvent);\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);// global = screen for top-level\n        event.offset.copyFrom(event.screen);// EventBoundary recalculates using its rootTarget\n\n        event.isTrusted = nativeEvent.isTrusted;\n        if (event.type === 'pointerleave')\n        {\n            event.type = 'pointerout';\n        }\n        if (event.type.startsWith('mouse'))\n        {\n            event.type = event.type.replace('mouse', 'pointer');\n        }\n        if (event.type.startsWith('touch'))\n        {\n            event.type = TOUCH_TO_POINTER[event.type] || event.type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Transfers base & mouse event data from the `nativeEvent` to the federated event.\n     * @param event\n     * @param nativeEvent\n     */\n    private _transferMouseData(event: FederatedMouseEvent, nativeEvent: MouseEvent): void\n    {\n        event.isTrusted = nativeEvent.isTrusted;\n        event.srcElement = nativeEvent.srcElement;\n        event.timeStamp = performance.now();\n        event.type = nativeEvent.type;\n\n        event.altKey = nativeEvent.altKey;\n        event.button = nativeEvent.button;\n        event.buttons = nativeEvent.buttons;\n        event.client.x = nativeEvent.clientX;\n        event.client.y = nativeEvent.clientY;\n        event.ctrlKey = nativeEvent.ctrlKey;\n        event.metaKey = nativeEvent.metaKey;\n        event.movement.x = nativeEvent.movementX;\n        event.movement.y = nativeEvent.movementY;\n        event.page.x = nativeEvent.pageX;\n        event.page.y = nativeEvent.pageY;\n        event.relatedTarget = null;\n        event.shiftKey = nativeEvent.shiftKey;\n    }\n}\n\ninterface CrossCSSStyleDeclaration extends CSSStyleDeclaration\n{\n    msContentZooming: string;\n    msTouchAction: string;\n}\n\ninterface PixiPointerEvent extends PointerEvent\n{\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    isNormalized: boolean;\n    type: string;\n}\n","import EventEmitter from 'eventemitter3';\nimport { Point } from '../maths/point/Point.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\nimport { EventsTicker } from './EventTicker.mjs';\nimport { FederatedMouseEvent } from './FederatedMouseEvent.mjs';\nimport { FederatedPointerEvent } from './FederatedPointerEvent.mjs';\nimport { FederatedWheelEvent } from './FederatedWheelEvent.mjs';\n\n\"use strict\";\nconst PROPAGATION_LIMIT = 2048;\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\nclass EventBoundary {\n  /**\n   * @param rootTarget - The holder of the event boundary.\n   */\n  constructor(rootTarget) {\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    this.dispatch = new EventEmitter();\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    this.moveOnAll = false;\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    this.enableGlobalMoveEvents = true;\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    this.mappingState = {\n      trackingData: {}\n    };\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    this.eventPool = /* @__PURE__ */ new Map();\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    this._allInteractiveElements = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    this._hitElements = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    this._isPointerMoveEvent = false;\n    this.rootTarget = rootTarget;\n    this.hitPruneFn = this.hitPruneFn.bind(this);\n    this.hitTestFn = this.hitTestFn.bind(this);\n    this.mapPointerDown = this.mapPointerDown.bind(this);\n    this.mapPointerMove = this.mapPointerMove.bind(this);\n    this.mapPointerOut = this.mapPointerOut.bind(this);\n    this.mapPointerOver = this.mapPointerOver.bind(this);\n    this.mapPointerUp = this.mapPointerUp.bind(this);\n    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n    this.mapWheel = this.mapWheel.bind(this);\n    this.mappingTable = {};\n    this.addEventMapping(\"pointerdown\", this.mapPointerDown);\n    this.addEventMapping(\"pointermove\", this.mapPointerMove);\n    this.addEventMapping(\"pointerout\", this.mapPointerOut);\n    this.addEventMapping(\"pointerleave\", this.mapPointerOut);\n    this.addEventMapping(\"pointerover\", this.mapPointerOver);\n    this.addEventMapping(\"pointerup\", this.mapPointerUp);\n    this.addEventMapping(\"pointerupoutside\", this.mapPointerUpOutside);\n    this.addEventMapping(\"wheel\", this.mapWheel);\n  }\n  /**\n   * Adds an event mapping for the event `type` handled by `fn`.\n   *\n   * Event mappings can be used to implement additional or custom events. They take an event\n   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n   *\n   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n   * instead.\n   * @param type - The type of upstream event to map.\n   * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n   */\n  addEventMapping(type, fn) {\n    if (!this.mappingTable[type]) {\n      this.mappingTable[type] = [];\n    }\n    this.mappingTable[type].push({\n      fn,\n      priority: 0\n    });\n    this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Dispatches the given event\n   * @param e - The event to dispatch.\n   * @param type - The type of event to dispatch. Defaults to `e.type`.\n   */\n  dispatchEvent(e, type) {\n    e.propagationStopped = false;\n    e.propagationImmediatelyStopped = false;\n    this.propagate(e, type);\n    this.dispatch.emit(type || e.type, e);\n  }\n  /**\n   * Maps the given upstream event through the event boundary and propagates it downstream.\n   * @param e - The event to map.\n   */\n  mapEvent(e) {\n    if (!this.rootTarget) {\n      return;\n    }\n    const mappers = this.mappingTable[e.type];\n    if (mappers) {\n      for (let i = 0, j = mappers.length; i < j; i++) {\n        mappers[i].fn(e);\n      }\n    } else {\n      warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n    }\n  }\n  /**\n   * Finds the Container that is the target of a event at the given coordinates.\n   *\n   * The passed (x,y) coordinates are in the world space above this event boundary.\n   * @param x - The x coordinate of the event.\n   * @param y - The y coordinate of the event.\n   */\n  hitTest(x, y) {\n    EventsTicker.pauseUpdate = true;\n    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n    const fn = useMove ? \"hitTestMoveRecursive\" : \"hitTestRecursive\";\n    const invertedPath = this[fn](\n      this.rootTarget,\n      this.rootTarget.eventMode,\n      tempHitLocation.set(x, y),\n      this.hitTestFn,\n      this.hitPruneFn\n    );\n    return invertedPath && invertedPath[0];\n  }\n  /**\n   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n   * target `e.target`.\n   * @param e - The event to propagate.\n   * @param type - The type of event to propagate. Defaults to `e.type`.\n   */\n  propagate(e, type) {\n    if (!e.target) {\n      return;\n    }\n    const composedPath = e.composedPath();\n    e.eventPhase = e.CAPTURING_PHASE;\n    for (let i = 0, j = composedPath.length - 1; i < j; i++) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n    e.eventPhase = e.AT_TARGET;\n    e.currentTarget = e.target;\n    this.notifyTarget(e, type);\n    if (e.propagationStopped || e.propagationImmediatelyStopped)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    for (let i = composedPath.length - 2; i >= 0; i--) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n  }\n  /**\n   * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.\n   *\n   * This is used in the `globalpointermove` event.\n   * @param e - The emitted event.\n   * @param type - The listeners to notify.\n   * @param targets - The targets to notify.\n   */\n  all(e, type, targets = this._allInteractiveElements) {\n    if (targets.length === 0)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    const events = Array.isArray(type) ? type : [type];\n    for (let i = targets.length - 1; i >= 0; i--) {\n      events.forEach((event) => {\n        e.currentTarget = targets[i];\n        this.notifyTarget(e, event);\n      });\n    }\n  }\n  /**\n   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n   * `target`. The last element in the path is `target`.\n   * @param target - The target to find the propagation path to.\n   */\n  propagationPath(target) {\n    const propagationPath = [target];\n    for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++) {\n      if (!target.parent) {\n        throw new Error(\"Cannot find propagation path to disconnected target\");\n      }\n      propagationPath.push(target.parent);\n      target = target.parent;\n    }\n    propagationPath.reverse();\n    return propagationPath;\n  }\n  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {\n    let shouldReturn = false;\n    if (this._interactivePrune(currentTarget))\n      return null;\n    if (currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestMoveRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          location,\n          testFn,\n          pruneFn,\n          ignore || pruneFn(currentTarget, location)\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive) {\n            if (isInteractive)\n              this._allInteractiveElements.push(currentTarget);\n            nestedHit.push(currentTarget);\n          }\n          if (this._hitElements.length === 0)\n            this._hitElements = nestedHit;\n          shouldReturn = true;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveTarget && isInteractiveTarget)\n      this._allInteractiveElements.push(currentTarget);\n    if (ignore || this._hitElements.length > 0)\n      return null;\n    if (shouldReturn)\n      return this._hitElements;\n    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  /**\n   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n   * @param currentTarget - The Container that is to be hit tested.\n   * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n   * @param location - The location that is being tested for overlap.\n   * @param testFn - Callback that determines whether the target passes hit testing. This callback\n   *  can assume that `pruneFn` failed to prune the container.\n   * @param pruneFn - Callback that determiness whether the target and all of its children\n   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n   *  of the scene graph.\n   * @returns An array holding the hit testing target and all its ancestors in order. The first element\n   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n   */\n  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {\n      return null;\n    }\n    if (currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      const relativeLocation = location;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          relativeLocation,\n          testFn,\n          pruneFn\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive)\n            nestedHit.push(currentTarget);\n          return nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveMode && testFn(currentTarget, location)) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  _isInteractive(int) {\n    return int === \"static\" || int === \"dynamic\";\n  }\n  _interactivePrune(container) {\n    if (!container || !container.visible || !container.renderable || !container.measurable) {\n      return true;\n    }\n    if (container.eventMode === \"none\") {\n      return true;\n    }\n    if (container.eventMode === \"passive\" && !container.interactiveChildren) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container or any of its children cannot pass the hit test at all.\n   *\n   * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n   * and {@link Container._maskEffect} for pruning.\n   * @param container - The container to prune.\n   * @param location - The location to test for overlap.\n   */\n  hitPruneFn(container, location) {\n    if (container.hitArea) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {\n        return true;\n      }\n    }\n    if (container.effects && container.effects.length) {\n      for (let i = 0; i < container.effects.length; i++) {\n        const effect = container.effects[i];\n        if (effect.containsPoint) {\n          const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n          if (!effectContainsPoint) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container passes hit testing for the given location.\n   * @param container - The container to test.\n   * @param location - The location to test for overlap.\n   * @returns - Whether `container` passes hit testing for `location`.\n   */\n  hitTestFn(container, location) {\n    if (container.hitArea) {\n      return true;\n    }\n    if (container?.containsPoint) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      return container.containsPoint(tempLocalMapping);\n    }\n    return false;\n  }\n  /**\n   * Notify all the listeners to the event's `currentTarget`.\n   *\n   * If the `currentTarget` contains the property `on<type>`, then it is called here,\n   * simulating the behavior from version 6.x and prior.\n   * @param e - The event passed to the target.\n   * @param type - The type of event to notify. Defaults to `e.type`.\n   */\n  notifyTarget(e, type) {\n    if (!e.currentTarget.isInteractive()) {\n      return;\n    }\n    type ?? (type = e.type);\n    const handlerKey = `on${type}`;\n    e.currentTarget[handlerKey]?.(e);\n    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n    this._notifyListeners(e, key);\n    if (e.eventPhase === e.AT_TARGET) {\n      this._notifyListeners(e, type);\n    }\n  }\n  /**\n   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n   *\n   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n   * @param from - The upstream `pointerdown` event.\n   */\n  mapPointerDown(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, \"pointerdown\");\n    if (e.pointerType === \"touch\") {\n      this.dispatchEvent(e, \"touchstart\");\n    } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightdown\" : \"mousedown\");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    trackingData.pressTargetsByButton[from.button] = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n   *\n   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n   * @param from - The upstream `pointermove` event.\n   */\n  mapPointerMove(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    this._isPointerMoveEvent = true;\n    const e = this.createPointerEvent(from);\n    this._isPointerMoveEvent = false;\n    const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n    const trackingData = this.trackingData(from.pointerId);\n    const outTarget = this.findMountedTarget(trackingData.overTargets);\n    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {\n      const outType = from.type === \"mousemove\" ? \"mouseout\" : \"pointerout\";\n      const outEvent = this.createPointerEvent(from, outType, outTarget);\n      this.dispatchEvent(outEvent, \"pointerout\");\n      if (isMouse)\n        this.dispatchEvent(outEvent, \"mouseout\");\n      if (!e.composedPath().includes(outTarget)) {\n        const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n        leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {\n          leaveEvent.currentTarget = leaveEvent.target;\n          this.notifyTarget(leaveEvent);\n          if (isMouse)\n            this.notifyTarget(leaveEvent, \"mouseleave\");\n          leaveEvent.target = leaveEvent.target.parent;\n        }\n        this.freeEvent(leaveEvent);\n      }\n      this.freeEvent(outEvent);\n    }\n    if (outTarget !== e.target) {\n      const overType = from.type === \"mousemove\" ? \"mouseover\" : \"pointerover\";\n      const overEvent = this.clonePointerEvent(e, overType);\n      this.dispatchEvent(overEvent, \"pointerover\");\n      if (isMouse)\n        this.dispatchEvent(overEvent, \"mouseover\");\n      let overTargetAncestor = outTarget?.parent;\n      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {\n        if (overTargetAncestor === e.target)\n          break;\n        overTargetAncestor = overTargetAncestor.parent;\n      }\n      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n      if (didPointerEnter) {\n        const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {\n          enterEvent.currentTarget = enterEvent.target;\n          this.notifyTarget(enterEvent);\n          if (isMouse)\n            this.notifyTarget(enterEvent, \"mouseenter\");\n          enterEvent.target = enterEvent.target.parent;\n        }\n        this.freeEvent(enterEvent);\n      }\n      this.freeEvent(overEvent);\n    }\n    const allMethods = [];\n    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n    this.moveOnAll ? allMethods.push(\"pointermove\") : this.dispatchEvent(e, \"pointermove\");\n    allowGlobalPointerEvents && allMethods.push(\"globalpointermove\");\n    if (e.pointerType === \"touch\") {\n      this.moveOnAll ? allMethods.splice(1, 0, \"touchmove\") : this.dispatchEvent(e, \"touchmove\");\n      allowGlobalPointerEvents && allMethods.push(\"globaltouchmove\");\n    }\n    if (isMouse) {\n      this.moveOnAll ? allMethods.splice(1, 0, \"mousemove\") : this.dispatchEvent(e, \"mousemove\");\n      allowGlobalPointerEvents && allMethods.push(\"globalmousemove\");\n      this.cursor = e.target?.cursor;\n    }\n    if (allMethods.length > 0) {\n      this.all(e, allMethods);\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n   *\n   * The tracking data for the specific pointer gets a new `overTarget`.\n   * @param from - The upstream `pointerover` event.\n   */\n  mapPointerOver(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const e = this.createPointerEvent(from);\n    const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n    this.dispatchEvent(e, \"pointerover\");\n    if (isMouse)\n      this.dispatchEvent(e, \"mouseover\");\n    if (e.pointerType === \"mouse\")\n      this.cursor = e.target?.cursor;\n    const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n    enterEvent.eventPhase = enterEvent.AT_TARGET;\n    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {\n      enterEvent.currentTarget = enterEvent.target;\n      this.notifyTarget(enterEvent);\n      if (isMouse)\n        this.notifyTarget(enterEvent, \"mouseenter\");\n      enterEvent.target = enterEvent.target.parent;\n    }\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n    this.freeEvent(enterEvent);\n  }\n  /**\n   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n   *\n   * The tracking data for the specific pointer is cleared of a `overTarget`.\n   * @param from - The upstream `pointerout` event.\n   */\n  mapPointerOut(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    if (trackingData.overTargets) {\n      const isMouse = from.pointerType === \"mouse\" || from.pointerType === \"pen\";\n      const outTarget = this.findMountedTarget(trackingData.overTargets);\n      const outEvent = this.createPointerEvent(from, \"pointerout\", outTarget);\n      this.dispatchEvent(outEvent);\n      if (isMouse)\n        this.dispatchEvent(outEvent, \"mouseout\");\n      const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n      leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {\n        leaveEvent.currentTarget = leaveEvent.target;\n        this.notifyTarget(leaveEvent);\n        if (isMouse)\n          this.notifyTarget(leaveEvent, \"mouseleave\");\n        leaveEvent.target = leaveEvent.target.parent;\n      }\n      trackingData.overTargets = null;\n      this.freeEvent(outEvent);\n      this.freeEvent(leaveEvent);\n    }\n    this.cursor = null;\n  }\n  /**\n   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n   * and `click`/`rightclick`/`pointertap` events, in that order.\n   *\n   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n   * specific pointer types.\n   * @param from - The upstream `pointerup` event.\n   */\n  mapPointerUp(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const now = performance.now();\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, \"pointerup\");\n    if (e.pointerType === \"touch\") {\n      this.dispatchEvent(e, \"touchend\");\n    } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightup\" : \"mouseup\");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    let clickTarget = pressTarget;\n    if (pressTarget && !e.composedPath().includes(pressTarget)) {\n      let currentTarget = pressTarget;\n      while (currentTarget && !e.composedPath().includes(currentTarget)) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, \"pointerupoutside\");\n        if (e.pointerType === \"touch\") {\n          this.notifyTarget(e, \"touchendoutside\");\n        } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n          const isRightButton = e.button === 2;\n          this.notifyTarget(e, isRightButton ? \"rightupoutside\" : \"mouseupoutside\");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n      clickTarget = currentTarget;\n    }\n    if (clickTarget) {\n      const clickEvent = this.clonePointerEvent(e, \"click\");\n      clickEvent.target = clickTarget;\n      clickEvent.path = null;\n      if (!trackingData.clicksByButton[from.button]) {\n        trackingData.clicksByButton[from.button] = {\n          clickCount: 0,\n          target: clickEvent.target,\n          timeStamp: now\n        };\n      }\n      const clickHistory = trackingData.clicksByButton[from.button];\n      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {\n        ++clickHistory.clickCount;\n      } else {\n        clickHistory.clickCount = 1;\n      }\n      clickHistory.target = clickEvent.target;\n      clickHistory.timeStamp = now;\n      clickEvent.detail = clickHistory.clickCount;\n      if (clickEvent.pointerType === \"mouse\") {\n        const isRightButton = clickEvent.button === 2;\n        this.dispatchEvent(clickEvent, isRightButton ? \"rightclick\" : \"click\");\n      } else if (clickEvent.pointerType === \"touch\") {\n        this.dispatchEvent(clickEvent, \"tap\");\n      }\n      this.dispatchEvent(clickEvent, \"pointertap\");\n      this.freeEvent(clickEvent);\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n   * `pointerdown` target to `rootTarget`.\n   *\n   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n   * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n   *\n   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n   * @param from - The upstream `pointerupoutside` event.\n   */\n  mapPointerUpOutside(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    const e = this.createPointerEvent(from);\n    if (pressTarget) {\n      let currentTarget = pressTarget;\n      while (currentTarget) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, \"pointerupoutside\");\n        if (e.pointerType === \"touch\") {\n          this.notifyTarget(e, \"touchendoutside\");\n        } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n          this.notifyTarget(e, e.button === 2 ? \"rightupoutside\" : \"mouseupoutside\");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `wheel` event to a downstream `wheel` event.\n   * @param from - The upstream `wheel` event.\n   */\n  mapWheel(from) {\n    if (!(from instanceof FederatedWheelEvent)) {\n      warn(\"EventBoundary cannot map a non-wheel event as a wheel event\");\n      return;\n    }\n    const wheelEvent = this.createWheelEvent(from);\n    this.dispatchEvent(wheelEvent);\n    this.freeEvent(wheelEvent);\n  }\n  /**\n   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n   *\n   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n   * or `pointerover` target was unmounted from the scene graph.\n   * @param propagationPath - The propagation path was valid in the past.\n   * @returns - The most specific event-target still mounted at the same location in the scene graph.\n   */\n  findMountedTarget(propagationPath) {\n    if (!propagationPath) {\n      return null;\n    }\n    let currentTarget = propagationPath[0];\n    for (let i = 1; i < propagationPath.length; i++) {\n      if (propagationPath[i].parent === currentTarget) {\n        currentTarget = propagationPath[i];\n      } else {\n        break;\n      }\n    }\n    return currentTarget;\n  }\n  /**\n   * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The `originalEvent` for the returned event.\n   * @param [type=from.type] - The type of the returned event.\n   * @param target - The target of the returned event.\n   */\n  createPointerEvent(from, type, target) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];\n    if (typeof type === \"string\") {\n      event.type = type;\n    }\n    return event;\n  }\n  /**\n   * Creates a wheel event whose `originalEvent` is `from`.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The upstream wheel event.\n   */\n  createWheelEvent(from) {\n    const event = this.allocateEvent(FederatedWheelEvent);\n    this.copyWheelData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = this.hitTest(event.global.x, event.global.y);\n    return event;\n  }\n  /**\n   * Clones the event `from`, with an optional `type` override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The event to clone.\n   * @param [type=from.type] - The type of the returned event.\n   */\n  clonePointerEvent(from, type) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from.originalEvent;\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.target = from.target;\n    event.path = from.composedPath().slice();\n    event.type = type ?? event.type;\n    return event;\n  }\n  /**\n   * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.\n   *\n   * The following properties are copied:\n   * + deltaMode\n   * + deltaX\n   * + deltaY\n   * + deltaZ\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyWheelData(from, to) {\n    to.deltaMode = from.deltaMode;\n    to.deltaX = from.deltaX;\n    to.deltaY = from.deltaY;\n    to.deltaZ = from.deltaZ;\n  }\n  /**\n   * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.\n   *\n   * The following properties are copied:\n   * + pointerId\n   * + width\n   * + height\n   * + isPrimary\n   * + pointerType\n   * + pressure\n   * + tangentialPressure\n   * + tiltX\n   * + tiltY\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyPointerData(from, to) {\n    if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))\n      return;\n    to.pointerId = from.pointerId;\n    to.width = from.width;\n    to.height = from.height;\n    to.isPrimary = from.isPrimary;\n    to.pointerType = from.pointerType;\n    to.pressure = from.pressure;\n    to.tangentialPressure = from.tangentialPressure;\n    to.tiltX = from.tiltX;\n    to.tiltY = from.tiltY;\n    to.twist = from.twist;\n  }\n  /**\n   * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.\n   *\n   * The following properties are copied:\n   * + altKey\n   * + button\n   * + buttons\n   * + clientX\n   * + clientY\n   * + metaKey\n   * + movementX\n   * + movementY\n   * + pageX\n   * + pageY\n   * + x\n   * + y\n   * + screen\n   * + shiftKey\n   * + global\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyMouseData(from, to) {\n    if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))\n      return;\n    to.altKey = from.altKey;\n    to.button = from.button;\n    to.buttons = from.buttons;\n    to.client.copyFrom(from.client);\n    to.ctrlKey = from.ctrlKey;\n    to.metaKey = from.metaKey;\n    to.movement.copyFrom(from.movement);\n    to.screen.copyFrom(from.screen);\n    to.shiftKey = from.shiftKey;\n    to.global.copyFrom(from.global);\n  }\n  /**\n   * Copies base {@link FederatedEvent} data from `from` into `to`.\n   *\n   * The following properties are copied:\n   * + isTrusted\n   * + srcElement\n   * + timeStamp\n   * + type\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyData(from, to) {\n    to.isTrusted = from.isTrusted;\n    to.srcElement = from.srcElement;\n    to.timeStamp = performance.now();\n    to.type = from.type;\n    to.detail = from.detail;\n    to.view = from.view;\n    to.which = from.which;\n    to.layer.copyFrom(from.layer);\n    to.page.copyFrom(from.page);\n  }\n  /**\n   * @param id - The pointer ID.\n   * @returns The tracking data stored for the given pointer. If no data exists, a blank\n   *  state will be created.\n   */\n  trackingData(id) {\n    if (!this.mappingState.trackingData[id]) {\n      this.mappingState.trackingData[id] = {\n        pressTargetsByButton: {},\n        clicksByButton: {},\n        overTarget: null\n      };\n    }\n    return this.mappingState.trackingData[id];\n  }\n  /**\n   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n   *\n   * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n   * boundary.\n   * @param constructor - The event's constructor.\n   */\n  allocateEvent(constructor) {\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    const event = this.eventPool.get(constructor).pop() || new constructor(this);\n    event.eventPhase = event.NONE;\n    event.currentTarget = null;\n    event.defaultPrevented = false;\n    event.path = null;\n    event.target = null;\n    return event;\n  }\n  /**\n   * Frees the event and puts it back into the event pool.\n   *\n   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n   *\n   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n   * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n   * it to be allocated twice & result in overwriting.\n   * @param event - The event to be freed.\n   * @throws Error if the event is managed by another event boundary.\n   */\n  freeEvent(event) {\n    if (event.manager !== this)\n      throw new Error(\"It is illegal to free an event not managed by this EventBoundary!\");\n    const constructor = event.constructor;\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    this.eventPool.get(constructor).push(event);\n  }\n  /**\n   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n   * is set on the event.\n   * @param e - The event to call each listener with.\n   * @param type - The event key.\n   */\n  _notifyListeners(e, type) {\n    const listeners = e.currentTarget._events[type];\n    if (!listeners)\n      return;\n    if (\"fn\" in listeners) {\n      if (listeners.once)\n        e.currentTarget.removeListener(type, listeners.fn, void 0, true);\n      listeners.fn.call(listeners.context, e);\n    } else {\n      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {\n        if (listeners[i].once)\n          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);\n        listeners[i].fn.call(listeners[i].context, e);\n      }\n    }\n  }\n}\n\nexport { EventBoundary };\n//# sourceMappingURL=EventBoundary.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Point } from '../maths/point/Point';\nimport { warn } from '../utils/logging/warn';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { Container } from '../scene/container/Container';\nimport type { EmitterListeners, TrackingData } from './EventBoundaryTypes';\nimport type { FederatedEvent } from './FederatedEvent';\nimport type {\n    Cursor, EventMode, FederatedEventHandler,\n} from './FederatedEventTarget';\n\n// The maximum iterations used in propagation. This prevent infinite loops.\nconst PROPAGATION_LIMIT = 2048;\n\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\n\n/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from 'pixi.js';\n * import { EventBoundary } from 'pixi.js';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends Container\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n * @category events\n * @advanced\n */\nexport class EventBoundary\n{\n    /**\n     * The root event-target residing below the event boundary.\n     * All events are dispatched trickling down and bubbling up to this `rootTarget`.\n     */\n    public rootTarget: Container;\n\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    public dispatch: EventEmitter = new EventEmitter();\n\n    /** The cursor preferred by the event targets underneath this boundary. */\n    public cursor: Cursor | (string & {});\n\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    public moveOnAll = false;\n\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    public enableGlobalMoveEvents = true;\n\n    /**\n     * Maps event types to forwarding handles for them.\n     *\n     * {@link EventBoundary EventBoundary} provides mapping for \"pointerdown\", \"pointermove\",\n     * \"pointerout\", \"pointerleave\", \"pointerover\", \"pointerup\", and \"pointerupoutside\" by default.\n     * @see EventBoundary#addEventMapping\n     */\n    protected mappingTable: Record<string, Array<{\n        fn: (e: FederatedEvent) => void,\n        priority: number\n    }>>;\n\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    protected mappingState: Record<string, any> = {\n        trackingData: {}\n    };\n\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    protected eventPool: Map<typeof FederatedEvent, FederatedEvent[]> = new Map();\n\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    private readonly _allInteractiveElements: Container[] = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    private _hitElements: Container[] = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    private _isPointerMoveEvent = false;\n\n    /**\n     * @param rootTarget - The holder of the event boundary.\n     */\n    constructor(rootTarget?: Container)\n    {\n        this.rootTarget = rootTarget;\n\n        this.hitPruneFn = this.hitPruneFn.bind(this);\n        this.hitTestFn = this.hitTestFn.bind(this);\n        this.mapPointerDown = this.mapPointerDown.bind(this);\n        this.mapPointerMove = this.mapPointerMove.bind(this);\n        this.mapPointerOut = this.mapPointerOut.bind(this);\n        this.mapPointerOver = this.mapPointerOver.bind(this);\n        this.mapPointerUp = this.mapPointerUp.bind(this);\n        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n        this.mapWheel = this.mapWheel.bind(this);\n\n        this.mappingTable = {};\n        this.addEventMapping('pointerdown', this.mapPointerDown);\n        this.addEventMapping('pointermove', this.mapPointerMove);\n        this.addEventMapping('pointerout', this.mapPointerOut);\n        this.addEventMapping('pointerleave', this.mapPointerOut);\n        this.addEventMapping('pointerover', this.mapPointerOver);\n        this.addEventMapping('pointerup', this.mapPointerUp);\n        this.addEventMapping('pointerupoutside', this.mapPointerUpOutside);\n        this.addEventMapping('wheel', this.mapWheel);\n    }\n\n    /**\n     * Adds an event mapping for the event `type` handled by `fn`.\n     *\n     * Event mappings can be used to implement additional or custom events. They take an event\n     * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n     * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n     *\n     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n     * instead.\n     * @param type - The type of upstream event to map.\n     * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n     */\n    public addEventMapping(type: string, fn: (e: FederatedEvent) => void): void\n    {\n        if (!this.mappingTable[type])\n        {\n            this.mappingTable[type] = [];\n        }\n\n        this.mappingTable[type].push({\n            fn,\n            priority: 0,\n        });\n        this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Dispatches the given event\n     * @param e - The event to dispatch.\n     * @param type - The type of event to dispatch. Defaults to `e.type`.\n     */\n    public dispatchEvent(e: FederatedEvent, type?: string): void\n    {\n        e.propagationStopped = false;\n        e.propagationImmediatelyStopped = false;\n\n        this.propagate(e, type);\n        this.dispatch.emit(type || e.type, e);\n    }\n\n    /**\n     * Maps the given upstream event through the event boundary and propagates it downstream.\n     * @param e - The event to map.\n     */\n    public mapEvent(e: FederatedEvent): void\n    {\n        if (!this.rootTarget)\n        {\n            return;\n        }\n\n        const mappers = this.mappingTable[e.type];\n\n        if (mappers)\n        {\n            for (let i = 0, j = mappers.length; i < j; i++)\n            {\n                mappers[i].fn(e);\n            }\n        }\n        else\n        {\n            // #if _DEBUG\n            warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n            // #endif\n        }\n    }\n\n    /**\n     * Finds the Container that is the target of a event at the given coordinates.\n     *\n     * The passed (x,y) coordinates are in the world space above this event boundary.\n     * @param x - The x coordinate of the event.\n     * @param y - The y coordinate of the event.\n     */\n    public hitTest(\n        x: number,\n        y: number,\n    ): Container\n    {\n        EventsTicker.pauseUpdate = true;\n        // if we are using global move events, we need to hit test the whole scene graph\n        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n        const fn = useMove ? 'hitTestMoveRecursive' : 'hitTestRecursive';\n        const invertedPath = this[fn](\n            this.rootTarget,\n            this.rootTarget.eventMode,\n            tempHitLocation.set(x, y),\n            this.hitTestFn,\n            this.hitPruneFn,\n        );\n\n        return invertedPath && invertedPath[0];\n    }\n\n    /**\n     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n     * target `e.target`.\n     * @param e - The event to propagate.\n     * @param type - The type of event to propagate. Defaults to `e.type`.\n     */\n    public propagate(e: FederatedEvent, type?: string): void\n    {\n        if (!e.target)\n        {\n            // This usually occurs when the scene graph is not interactive.\n            return;\n        }\n\n        const composedPath = e.composedPath();\n\n        // Capturing phase\n        e.eventPhase = e.CAPTURING_PHASE;\n\n        for (let i = 0, j = composedPath.length - 1; i < j; i++)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n\n        // At target phase\n        e.eventPhase = e.AT_TARGET;\n        e.currentTarget = e.target;\n\n        this.notifyTarget(e, type);\n\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n\n        // Bubbling phase\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        for (let i = composedPath.length - 2; i >= 0; i--)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n\n    /**\n     * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.\n     *\n     * This is used in the `globalpointermove` event.\n     * @param e - The emitted event.\n     * @param type - The listeners to notify.\n     * @param targets - The targets to notify.\n     */\n    public all(e: FederatedEvent, type?: string | string[], targets = this._allInteractiveElements): void\n    {\n        if (targets.length === 0) return;\n\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        const events = Array.isArray(type) ? type : [type];\n\n        // loop through all interactive elements and notify them of the event\n        // loop through targets backwards\n        for (let i = targets.length - 1; i >= 0; i--)\n        {\n            events.forEach((event) =>\n            {\n                e.currentTarget = targets[i];\n                this.notifyTarget(e, event);\n            });\n        }\n    }\n\n    /**\n     * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n     * `target`. The last element in the path is `target`.\n     * @param target - The target to find the propagation path to.\n     */\n    public propagationPath(target: Container): Container[]\n    {\n        const propagationPath = [target];\n\n        for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++)\n        {\n            if (!target.parent)\n            {\n                throw new Error('Cannot find propagation path to disconnected target');\n            }\n\n            propagationPath.push(target.parent);\n\n            target = target.parent;\n        }\n\n        propagationPath.reverse();\n\n        return propagationPath;\n    }\n\n    protected hitTestMoveRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean,\n        ignore = false\n    ): Container[]\n    {\n        let shouldReturn = false;\n\n        // only bail out early if it is not interactive\n        if (this._interactivePrune(currentTarget)) return null;\n\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestMoveRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    location,\n                    testFn,\n                    pruneFn,\n                    ignore || pruneFn(currentTarget, location)\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive)\n                    {\n                        if (isInteractive) this._allInteractiveElements.push(currentTarget);\n                        nestedHit.push(currentTarget);\n                    }\n\n                    // store all hit elements to be returned once we have traversed the whole tree\n                    if (this._hitElements.length === 0) this._hitElements = nestedHit;\n\n                    shouldReturn = true;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);\n\n        // we don't carry on hit testing something once we have found a hit,\n        // now only care about gathering the interactive elements\n        if (ignore || this._hitElements.length > 0) return null;\n\n        if (shouldReturn) return this._hitElements as Container[];\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location)))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    /**\n     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n     * @param currentTarget - The Container that is to be hit tested.\n     * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n     * @param location - The location that is being tested for overlap.\n     * @param testFn - Callback that determines whether the target passes hit testing. This callback\n     *  can assume that `pruneFn` failed to prune the container.\n     * @param pruneFn - Callback that determiness whether the target and all of its children\n     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n     *  of the scene graph.\n     * @returns An array holding the hit testing target and all its ancestors in order. The first element\n     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n     */\n    protected hitTestRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean\n    ): Container[]\n    {\n        // Attempt to prune this Container and its subtree as an optimization.\n        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))\n        {\n            return null;\n        }\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        // Find a child that passes the hit testing and return one, if any.\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n            const relativeLocation = location;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    relativeLocation,\n                    testFn,\n                    pruneFn\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && testFn(currentTarget, location))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    private _isInteractive(int: EventMode): int is 'static' | 'dynamic'\n    {\n        return int === 'static' || int === 'dynamic';\n    }\n\n    private _interactivePrune(container: Container): boolean\n    {\n        // If container is a mask, invisible, or not renderable then it cannot be hit directly.\n        if (!container || !container.visible || !container.renderable || !container.measurable)\n        {\n            return true;\n        }\n\n        // If this Container is none then it cannot be hit by anything.\n        if (container.eventMode === 'none')\n        {\n            return true;\n        }\n\n        // If this Container is passive and it has no interactive children then it cannot be hit\n        if (container.eventMode === 'passive' && !container.interactiveChildren)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container or any of its children cannot pass the hit test at all.\n     *\n     * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n     * and {@link Container._maskEffect} for pruning.\n     * @param container - The container to prune.\n     * @param location - The location to test for overlap.\n     */\n    protected hitPruneFn(container: Container, location: Point): boolean\n    {\n        if (container.hitArea)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y))\n            {\n                return true;\n            }\n        }\n\n        if (container.effects && container.effects.length)\n        {\n            for (let i = 0; i < container.effects.length; i++)\n            {\n                const effect = container.effects[i];\n\n                if (effect.containsPoint)\n                {\n                    const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n\n                    if (!effectContainsPoint)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container passes hit testing for the given location.\n     * @param container - The container to test.\n     * @param location - The location to test for overlap.\n     * @returns - Whether `container` passes hit testing for `location`.\n     */\n    protected hitTestFn(container: Container, location: Point): boolean\n    {\n        // If the container failed pruning with a hitArea, then it must pass it.\n        if (container.hitArea)\n        {\n            return true;\n        }\n\n        if ((container as Renderable)?.containsPoint)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            return (container as Renderable).containsPoint(tempLocalMapping) as boolean;\n        }\n\n        // TODO: Should we hit test based on bounds?\n\n        return false;\n    }\n\n    /**\n     * Notify all the listeners to the event's `currentTarget`.\n     *\n     * If the `currentTarget` contains the property `on<type>`, then it is called here,\n     * simulating the behavior from version 6.x and prior.\n     * @param e - The event passed to the target.\n     * @param type - The type of event to notify. Defaults to `e.type`.\n     */\n    protected notifyTarget(e: FederatedEvent, type?: string): void\n    {\n        if (!e.currentTarget.isInteractive())\n        {\n            return;\n        }\n\n        type ??= e.type;\n\n        // call the `on${type}` for the current target if it exists\n        const handlerKey = `on${type}` as keyof Container;\n\n        (e.currentTarget[handlerKey] as FederatedEventHandler<FederatedEvent>)?.(e);\n\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n\n        this._notifyListeners(e, key);\n\n        if (e.eventPhase === e.AT_TARGET)\n        {\n            this._notifyListeners(e, type);\n        }\n    }\n\n    /**\n     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n     *\n     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n     * @param from - The upstream `pointerdown` event.\n     */\n    protected mapPointerDown(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerdown');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchstart');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        trackingData.pressTargetsByButton[from.button] = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n     *\n     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n     * @param from - The upstream `pointermove` event.\n     */\n    protected mapPointerMove(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n        this._isPointerMoveEvent = true;\n        const e = this.createPointerEvent(from);\n\n        this._isPointerMoveEvent = false;\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n        const trackingData = this.trackingData(from.pointerId);\n        const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n        // First pointerout/pointerleave\n        if (trackingData.overTargets?.length > 0 && outTarget !== e.target)\n        {\n            // pointerout always occurs on the overTarget when the pointer hovers over another element.\n            const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';\n            const outEvent = this.createPointerEvent(from, outType, outTarget);\n\n            this.dispatchEvent(outEvent, 'pointerout');\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n            // is dispatched to all ancestors that no longer capture the pointer.\n            if (!e.composedPath().includes(outTarget))\n            {\n                const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target))\n                {\n                    leaveEvent.currentTarget = leaveEvent.target;\n\n                    this.notifyTarget(leaveEvent);\n                    if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                    leaveEvent.target = leaveEvent.target.parent;\n                }\n\n                this.freeEvent(leaveEvent);\n            }\n\n            this.freeEvent(outEvent);\n        }\n\n        // Then pointerover\n        if (outTarget !== e.target)\n        {\n            // pointerover always occurs on the new overTarget\n            const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';\n            const overEvent = this.clonePointerEvent(e, overType);// clone faster\n\n            this.dispatchEvent(overEvent, 'pointerover');\n            if (isMouse) this.dispatchEvent(overEvent, 'mouseover');\n\n            // Probe whether the newly hovered Container is an ancestor of the original overTarget.\n            let overTargetAncestor = outTarget?.parent;\n\n            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent)\n            {\n                if (overTargetAncestor === e.target) break;\n\n                overTargetAncestor = overTargetAncestor.parent;\n            }\n\n            // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n            // event.\n            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n\n            if (didPointerEnter)\n            {\n                const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n                enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n                while (enterEvent.target\n                        && enterEvent.target !== outTarget\n                        && enterEvent.target !== this.rootTarget.parent)\n                {\n                    enterEvent.currentTarget = enterEvent.target;\n\n                    this.notifyTarget(enterEvent);\n                    if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n                    enterEvent.target = enterEvent.target.parent;\n                }\n\n                this.freeEvent(enterEvent);\n            }\n\n            this.freeEvent(overEvent);\n        }\n\n        const allMethods: string[] = [];\n        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n\n        this.moveOnAll ? allMethods.push('pointermove') : this.dispatchEvent(e, 'pointermove');\n        allowGlobalPointerEvents && allMethods.push('globalpointermove');\n\n        // Then pointermove\n        if (e.pointerType === 'touch')\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'touchmove') : this.dispatchEvent(e, 'touchmove');\n            allowGlobalPointerEvents && allMethods.push('globaltouchmove');\n        }\n\n        if (isMouse)\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'mousemove') : this.dispatchEvent(e, 'mousemove');\n            allowGlobalPointerEvents && allMethods.push('globalmousemove');\n            this.cursor = e.target?.cursor;\n        }\n\n        if (allMethods.length > 0)\n        {\n            this.all(e, allMethods);\n        }\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n     *\n     * The tracking data for the specific pointer gets a new `overTarget`.\n     * @param from - The upstream `pointerover` event.\n     */\n    protected mapPointerOver(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n\n        this.dispatchEvent(e, 'pointerover');\n        if (isMouse) this.dispatchEvent(e, 'mouseover');\n        if (e.pointerType === 'mouse') this.cursor = e.target?.cursor;\n\n        // pointerenter events must be fired since the pointer entered from upstream.\n        const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent)\n        {\n            enterEvent.currentTarget = enterEvent.target;\n\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n            enterEvent.target = enterEvent.target.parent;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n        this.freeEvent(enterEvent);\n    }\n\n    /**\n     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n     *\n     * The tracking data for the specific pointer is cleared of a `overTarget`.\n     * @param from - The upstream `pointerout` event.\n     */\n    protected mapPointerOut(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        if (trackingData.overTargets)\n        {\n            const isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';\n            const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n            // pointerout first\n            const outEvent = this.createPointerEvent(from, 'pointerout', outTarget);\n\n            this.dispatchEvent(outEvent);\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n            // get an upstream pointerout event (upstream events do not know rootTarget has descendants).\n            const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n            leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent)\n            {\n                leaveEvent.currentTarget = leaveEvent.target;\n\n                this.notifyTarget(leaveEvent);\n                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                leaveEvent.target = leaveEvent.target.parent;\n            }\n\n            trackingData.overTargets = null;\n\n            this.freeEvent(outEvent);\n            this.freeEvent(leaveEvent);\n        }\n\n        this.cursor = null;\n    }\n\n    /**\n     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n     * and `click`/`rightclick`/`pointertap` events, in that order.\n     *\n     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n     * specific pointer types.\n     * @param from - The upstream `pointerup` event.\n     */\n    protected mapPointerUp(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const now = performance.now();\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerup');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchend');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n\n        let clickTarget = pressTarget;\n\n        // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n        // the pointerup location.\n        if (pressTarget && !e.composedPath().includes(pressTarget))\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget && !e.composedPath().includes(currentTarget))\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    const isRightButton = e.button === 2;\n\n                    this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n\n            // currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n            // targets. That is - it's our click target!\n            clickTarget = currentTarget;\n        }\n\n        // click!\n        if (clickTarget)\n        {\n            const clickEvent = this.clonePointerEvent(e, 'click');\n\n            clickEvent.target = clickTarget;\n            clickEvent.path = null;\n\n            if (!trackingData.clicksByButton[from.button])\n            {\n                trackingData.clicksByButton[from.button] = {\n                    clickCount: 0,\n                    target: clickEvent.target,\n                    timeStamp: now,\n                };\n            }\n\n            const clickHistory = trackingData.clicksByButton[from.button];\n\n            if (clickHistory.target === clickEvent.target\n                && now - clickHistory.timeStamp < 200)\n            {\n                ++clickHistory.clickCount;\n            }\n            else\n            {\n                clickHistory.clickCount = 1;\n            }\n\n            clickHistory.target = clickEvent.target;\n            clickHistory.timeStamp = now;\n\n            clickEvent.detail = clickHistory.clickCount;\n\n            if (clickEvent.pointerType === 'mouse')\n            {\n                const isRightButton = clickEvent.button === 2;\n\n                this.dispatchEvent(clickEvent, isRightButton ? 'rightclick' : 'click');\n            }\n            else if (clickEvent.pointerType === 'touch')\n            {\n                this.dispatchEvent(clickEvent, 'tap');\n            }\n\n            this.dispatchEvent(clickEvent, 'pointertap');\n\n            this.freeEvent(clickEvent);\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n     * `pointerdown` target to `rootTarget`.\n     *\n     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n     * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n     *\n     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n     * @param from - The upstream `pointerupoutside` event.\n     */\n    protected mapPointerUpOutside(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        const e = this.createPointerEvent(from);\n\n        if (pressTarget)\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget)\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `wheel` event to a downstream `wheel` event.\n     * @param from - The upstream `wheel` event.\n     */\n    protected mapWheel(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedWheelEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-wheel event as a wheel event');\n            // #endif\n\n            return;\n        }\n\n        const wheelEvent = this.createWheelEvent(from);\n\n        this.dispatchEvent(wheelEvent);\n        this.freeEvent(wheelEvent);\n    }\n\n    /**\n     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n     *\n     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n     * or `pointerover` target was unmounted from the scene graph.\n     * @param propagationPath - The propagation path was valid in the past.\n     * @returns - The most specific event-target still mounted at the same location in the scene graph.\n     */\n    protected findMountedTarget(propagationPath: Container[]): Container\n    {\n        if (!propagationPath)\n        {\n            return null;\n        }\n\n        let currentTarget = propagationPath[0];\n\n        for (let i = 1; i < propagationPath.length; i++)\n        {\n            // Set currentTarget to the next target in the path only if it is still attached to the\n            // scene graph (i.e. parent still points to the expected ancestor).\n            if (propagationPath[i].parent === currentTarget)\n            {\n                currentTarget = propagationPath[i];\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return currentTarget;\n    }\n\n    /**\n     * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The `originalEvent` for the returned event.\n     * @param [type=from.type] - The type of the returned event.\n     * @param target - The target of the returned event.\n     */\n    protected createPointerEvent(\n        from: FederatedPointerEvent,\n        type?: string,\n        target?: Container\n    ): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = target\n            ?? this.hitTest(event.global.x, event.global.y) as Container\n            ?? this._hitElements[0];\n\n        if (typeof type === 'string')\n        {\n            event.type = type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Creates a wheel event whose `originalEvent` is `from`.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The upstream wheel event.\n     */\n    protected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent\n    {\n        const event = this.allocateEvent(FederatedWheelEvent);\n\n        this.copyWheelData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = this.hitTest(event.global.x, event.global.y);\n\n        return event;\n    }\n\n    /**\n     * Clones the event `from`, with an optional `type` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The event to clone.\n     * @param [type=from.type] - The type of the returned event.\n     */\n    protected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from.originalEvent;\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        // copy propagation path for perf\n        event.target = from.target;\n        event.path = from.composedPath().slice();\n        event.type = type ?? event.type;\n\n        return event;\n    }\n\n    /**\n     * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.\n     *\n     * The following properties are copied:\n     * + deltaMode\n     * + deltaX\n     * + deltaY\n     * + deltaZ\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void\n    {\n        to.deltaMode = from.deltaMode;\n        to.deltaX = from.deltaX;\n        to.deltaY = from.deltaY;\n        to.deltaZ = from.deltaZ;\n    }\n\n    /**\n     * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.\n     *\n     * The following properties are copied:\n     * + pointerId\n     * + width\n     * + height\n     * + isPrimary\n     * + pointerType\n     * + pressure\n     * + tangentialPressure\n     * + tiltX\n     * + tiltY\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyPointerData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n\n        to.pointerId = from.pointerId;\n        to.width = from.width;\n        to.height = from.height;\n        to.isPrimary = from.isPrimary;\n        to.pointerType = from.pointerType;\n        to.pressure = from.pressure;\n        to.tangentialPressure = from.tangentialPressure;\n        to.tiltX = from.tiltX;\n        to.tiltY = from.tiltY;\n        to.twist = from.twist;\n    }\n\n    /**\n     * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.\n     *\n     * The following properties are copied:\n     * + altKey\n     * + button\n     * + buttons\n     * + clientX\n     * + clientY\n     * + metaKey\n     * + movementX\n     * + movementY\n     * + pageX\n     * + pageY\n     * + x\n     * + y\n     * + screen\n     * + shiftKey\n     * + global\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyMouseData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n\n        to.altKey = from.altKey;\n        to.button = from.button;\n        to.buttons = from.buttons;\n        to.client.copyFrom(from.client);\n        to.ctrlKey = from.ctrlKey;\n        to.metaKey = from.metaKey;\n        to.movement.copyFrom(from.movement);\n        to.screen.copyFrom(from.screen);\n        to.shiftKey = from.shiftKey;\n        to.global.copyFrom(from.global);\n    }\n\n    /**\n     * Copies base {@link FederatedEvent} data from `from` into `to`.\n     *\n     * The following properties are copied:\n     * + isTrusted\n     * + srcElement\n     * + timeStamp\n     * + type\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        to.isTrusted = from.isTrusted;\n        to.srcElement = from.srcElement;\n        to.timeStamp = performance.now();\n        to.type = from.type;\n        to.detail = from.detail;\n        to.view = from.view;\n        to.which = from.which;\n        to.layer.copyFrom(from.layer);\n        to.page.copyFrom(from.page);\n    }\n\n    /**\n     * @param id - The pointer ID.\n     * @returns The tracking data stored for the given pointer. If no data exists, a blank\n     *  state will be created.\n     */\n    protected trackingData(id: number): TrackingData\n    {\n        if (!this.mappingState.trackingData[id])\n        {\n            this.mappingState.trackingData[id] = {\n                pressTargetsByButton: {},\n                clicksByButton: {},\n                overTarget: null\n            };\n        }\n\n        return this.mappingState.trackingData[id];\n    }\n\n    /**\n     * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n     *\n     * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n     * boundary.\n     * @param constructor - The event's constructor.\n     */\n    protected allocateEvent<T extends FederatedEvent>(\n        constructor: { new(boundary: EventBoundary): T }\n    ): T\n    {\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        const event = this.eventPool.get(constructor as any).pop() as T\n            || new constructor(this);\n\n        event.eventPhase = event.NONE;\n        event.currentTarget = null;\n        event.defaultPrevented = false;\n        event.path = null;\n        event.target = null;\n\n        return event;\n    }\n\n    /**\n     * Frees the event and puts it back into the event pool.\n     *\n     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n     *\n     * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n     * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n     * it to be allocated twice & result in overwriting.\n     * @param event - The event to be freed.\n     * @throws Error if the event is managed by another event boundary.\n     */\n    protected freeEvent<T extends FederatedEvent>(event: T): void\n    {\n        if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');\n\n        const constructor = event.constructor;\n\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        this.eventPool.get(constructor as any).push(event);\n    }\n\n    /**\n     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n     * is set on the event.\n     * @param e - The event to call each listener with.\n     * @param type - The event key.\n     */\n    private _notifyListeners(e: FederatedEvent, type: string): void\n    {\n        const listeners = ((e.currentTarget as any)._events as EmitterListeners)[type];\n\n        if (!listeners) return;\n\n        if ('fn' in listeners)\n        {\n            if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, undefined, true);\n            listeners.fn.call(listeners.context, e);\n        }\n        else\n        {\n            for (\n                let i = 0, j = listeners.length;\n                i < j && !e.propagationImmediatelyStopped;\n                i++)\n            {\n                if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, undefined, true);\n                listeners[i].fn.call(listeners[i].context, e);\n            }\n        }\n    }\n}\n","import { UPDATE_PRIORITY } from '../ticker/const.mjs';\nimport { Ticker } from '../ticker/Ticker.mjs';\n\n\"use strict\";\nclass EventsTickerClass {\n  constructor() {\n    /** The frequency that fake events will be fired. */\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this._tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  /**\n   * Initializes the event ticker.\n   * @param events - The event system.\n   */\n  init(events) {\n    this.removeTickerListener();\n    this.events = events;\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this._tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  /** Whether to pause the update checks or not. */\n  get pauseUpdate() {\n    return this._pauseUpdate;\n  }\n  set pauseUpdate(paused) {\n    this._pauseUpdate = paused;\n  }\n  /** Adds the ticker listener. */\n  addTickerListener() {\n    if (this._tickerAdded || !this.domElement) {\n      return;\n    }\n    Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n    this._tickerAdded = true;\n  }\n  /** Removes the ticker listener. */\n  removeTickerListener() {\n    if (!this._tickerAdded) {\n      return;\n    }\n    Ticker.system.remove(this._tickerUpdate, this);\n    this._tickerAdded = false;\n  }\n  /** Sets flag to not fire extra events when the user has already moved there mouse */\n  pointerMoved() {\n    this._didMove = true;\n  }\n  /** Updates the state of interactive objects. */\n  _update() {\n    if (!this.domElement || this._pauseUpdate) {\n      return;\n    }\n    if (this._didMove) {\n      this._didMove = false;\n      return;\n    }\n    const rootPointerEvent = this.events[\"_rootPointerEvent\"];\n    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === \"touch\") {\n      return;\n    }\n    globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent(\"pointermove\", {\n      clientX: rootPointerEvent.clientX,\n      clientY: rootPointerEvent.clientY,\n      pointerType: rootPointerEvent.pointerType,\n      pointerId: rootPointerEvent.pointerId\n    }) : new MouseEvent(\"mousemove\", {\n      clientX: rootPointerEvent.clientX,\n      clientY: rootPointerEvent.clientY\n    }));\n  }\n  /**\n   * Updates the state of interactive objects if at least {@link interactionFrequency}\n   * milliseconds have passed since the last invocation.\n   *\n   * Invoked by a throttled ticker update from {@link Ticker.system}.\n   * @param ticker - The throttled ticker.\n   */\n  _tickerUpdate(ticker) {\n    this._deltaTime += ticker.deltaTime;\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n    this._deltaTime = 0;\n    this._update();\n  }\n}\nconst EventsTicker = new EventsTickerClass();\n\nexport { EventsTicker };\n//# sourceMappingURL=EventTicker.mjs.map\n","import { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { EventSystem } from './EventSystem';\n\n/** @advanced */\nclass EventsTickerClass\n{\n    /** The event system. */\n    public events: EventSystem;\n    /** The DOM element to listen to events on. */\n    public domElement: HTMLElement;\n    /** The frequency that fake events will be fired. */\n    public interactionFrequency = 10;\n\n    private _deltaTime = 0;\n    private _didMove = false;\n    private _tickerAdded = false;\n    private _pauseUpdate = true;\n\n    /**\n     * Initializes the event ticker.\n     * @param events - The event system.\n     */\n    public init(events: EventSystem): void\n    {\n        this.removeTickerListener();\n        this.events = events;\n        this.interactionFrequency = 10;\n        this._deltaTime = 0;\n        this._didMove = false;\n        this._tickerAdded = false;\n        this._pauseUpdate = true;\n    }\n\n    /** Whether to pause the update checks or not. */\n    get pauseUpdate(): boolean\n    {\n        return this._pauseUpdate;\n    }\n\n    set pauseUpdate(paused: boolean)\n    {\n        this._pauseUpdate = paused;\n    }\n\n    /** Adds the ticker listener. */\n    public addTickerListener(): void\n    {\n        if (this._tickerAdded || !this.domElement)\n        {\n            return;\n        }\n\n        Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n\n        this._tickerAdded = true;\n    }\n\n    /** Removes the ticker listener. */\n    public removeTickerListener(): void\n    {\n        if (!this._tickerAdded)\n        {\n            return;\n        }\n\n        Ticker.system.remove(this._tickerUpdate, this);\n\n        this._tickerAdded = false;\n    }\n\n    /** Sets flag to not fire extra events when the user has already moved there mouse */\n    public pointerMoved(): void\n    {\n        this._didMove = true;\n    }\n\n    /** Updates the state of interactive objects. */\n    private _update(): void\n    {\n        if (!this.domElement || this._pauseUpdate)\n        {\n            return;\n        }\n\n        // if the user move the mouse this check has already been done using the mouse move!\n        if (this._didMove)\n        {\n            this._didMove = false;\n\n            return;\n        }\n\n        // eslint-disable-next-line dot-notation\n        const rootPointerEvent = this.events['_rootPointerEvent'];\n\n        if (this.events.supportsTouchEvents && (rootPointerEvent as PointerEvent).pointerType === 'touch')\n        {\n            return;\n        }\n\n        globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent('pointermove', {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY,\n            pointerType: rootPointerEvent.pointerType,\n            pointerId: rootPointerEvent.pointerId,\n        }) : new MouseEvent('mousemove', {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY,\n        }));\n    }\n\n    /**\n     * Updates the state of interactive objects if at least {@link interactionFrequency}\n     * milliseconds have passed since the last invocation.\n     *\n     * Invoked by a throttled ticker update from {@link Ticker.system}.\n     * @param ticker - The throttled ticker.\n     */\n    private _tickerUpdate(ticker: Ticker): void\n    {\n        this._deltaTime += ticker.deltaTime;\n\n        if (this._deltaTime < this.interactionFrequency)\n        {\n            return;\n        }\n\n        this._deltaTime = 0;\n\n        this._update();\n    }\n}\n\n/**\n * This class handles automatic firing of PointerEvents\n * in the case where the pointer is stationary for too long.\n * This is to ensure that hit-tests are still run on moving objects.\n * @since 7.2.0\n * @category events\n * @class\n * @advanced\n */\nexport const EventsTicker = new EventsTickerClass();\n","import { Point } from '../maths/point/Point.mjs';\nimport { FederatedEvent } from './FederatedEvent.mjs';\n\n\"use strict\";\nclass FederatedMouseEvent extends FederatedEvent {\n  constructor() {\n    super(...arguments);\n    /** The coordinates of the mouse event relative to the canvas. */\n    this.client = new Point();\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    this.movement = new Point();\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    this.offset = new Point();\n    /** The pointer coordinates in world space. */\n    this.global = new Point();\n    /**\n     * The pointer coordinates in the renderer's {@link AbstractRenderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    this.screen = new Point();\n  }\n  /** @readonly */\n  get clientX() {\n    return this.client.x;\n  }\n  /** @readonly */\n  get clientY() {\n    return this.client.y;\n  }\n  /**\n   * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n   * @readonly\n   */\n  get x() {\n    return this.clientX;\n  }\n  /**\n   * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n   * @readonly\n   */\n  get y() {\n    return this.clientY;\n  }\n  /** @readonly */\n  get movementX() {\n    return this.movement.x;\n  }\n  /** @readonly */\n  get movementY() {\n    return this.movement.y;\n  }\n  /** @readonly */\n  get offsetX() {\n    return this.offset.x;\n  }\n  /** @readonly */\n  get offsetY() {\n    return this.offset.y;\n  }\n  /** @readonly */\n  get globalX() {\n    return this.global.x;\n  }\n  /** @readonly */\n  get globalY() {\n    return this.global.y;\n  }\n  /**\n   * The pointer coordinates in the renderer's screen. Alias for `screen.x`.\n   * @readonly\n   */\n  get screenX() {\n    return this.screen.x;\n  }\n  /**\n   * The pointer coordinates in the renderer's screen. Alias for `screen.y`.\n   * @readonly\n   */\n  get screenY() {\n    return this.screen.y;\n  }\n  /**\n   * Converts global coordinates into container-local coordinates.\n   *\n   * This method transforms coordinates from world space to a container's local space,\n   * useful for precise positioning and hit testing.\n   * @param container - The Container to get local coordinates for\n   * @param point - Optional Point object to store the result. If not provided, a new Point will be created\n   * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used\n   * @returns The local coordinates as a Point object\n   * @example\n   * ```ts\n   * // Basic usage - get local coordinates relative to a container\n   * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n   *     // Get position relative to the sprite\n   *     const localPos = event.getLocalPosition(sprite);\n   *     console.log('Local position:', localPos.x, localPos.y);\n   * });\n   * // Using custom global coordinates\n   * const customGlobal = new Point(100, 100);\n   * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n   *     // Transform custom coordinates\n   *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);\n   *     console.log('Custom local position:', localPos.x, localPos.y);\n   * });\n   * ```\n   * @see {@link Container.worldTransform} For the transformation matrix\n   * @see {@link Point} For the point class used to store coordinates\n   */\n  getLocalPosition(container, point, globalPos) {\n    return container.worldTransform.applyInverse(globalPos || this.global, point);\n  }\n  /**\n   * Whether the modifier key was pressed when this event natively occurred.\n   * @param key - The modifier key.\n   */\n  getModifierState(key) {\n    return \"getModifierState\" in this.nativeEvent && this.nativeEvent.getModifierState(key);\n  }\n  /**\n   * Not supported.\n   * @param _typeArg\n   * @param _canBubbleArg\n   * @param _cancelableArg\n   * @param _viewArg\n   * @param _detailArg\n   * @param _screenXArg\n   * @param _screenYArg\n   * @param _clientXArg\n   * @param _clientYArg\n   * @param _ctrlKeyArg\n   * @param _altKeyArg\n   * @param _shiftKeyArg\n   * @param _metaKeyArg\n   * @param _buttonArg\n   * @param _relatedTargetArg\n   * @deprecated since 7.0.0\n   * @ignore\n   */\n  // eslint-disable-next-line max-params\n  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n\nexport { FederatedMouseEvent };\n//# sourceMappingURL=FederatedMouseEvent.mjs.map\n","import { Point } from '../maths/point/Point';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { Container } from '../scene/container/Container';\nimport type { PixiTouch } from './FederatedEvent';\n\n/**\n * A specialized event class for mouse interactions in PixiJS applications.\n * Extends {@link FederatedEvent} to provide mouse-specific properties and methods\n * while maintaining compatibility with the DOM MouseEvent interface.\n *\n * Key features:\n * - Tracks mouse button states\n * - Provides modifier key states\n * - Supports coordinate systems (client, screen, global)\n * - Enables precise position tracking\n * @example\n * ```ts\n * // Basic mouse event handling\n * sprite.on('mousemove', (event: FederatedMouseEvent) => {\n *     // Get coordinates in different spaces\n *     console.log('Global position:', event.global.x, event.global.y);\n *     console.log('Client position:', event.client.x, event.client.y);\n *     console.log('Screen position:', event.screen.x, event.screen.y);\n *\n *     // Check button and modifier states\n *     if (event.buttons === 1 && event.ctrlKey) {\n *         console.log('Left click + Control key');\n *     }\n *\n *     // Get local coordinates relative to any container\n *     const localPos = event.getLocalPosition(container);\n *     console.log('Local position:', localPos.x, localPos.y);\n * });\n *\n * // Handle mouse button states\n * sprite.on('mousedown', (event: FederatedMouseEvent) => {\n *     console.log('Mouse button:', event.button); // 0=left, 1=middle, 2=right\n *     console.log('Active buttons:', event.buttons);\n * });\n * ```\n * @category events\n * @see {@link FederatedEvent} For base event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} DOM MouseEvent Interface\n * @standard\n */\nexport class FederatedMouseEvent extends FederatedEvent<\nMouseEvent | PointerEvent | PixiTouch\n> implements MouseEvent\n{\n    /** Whether the \"alt\" key was pressed when this mouse event occurred. */\n    public altKey: boolean;\n\n    /** The specific button that was pressed in this mouse event. */\n    public button: number;\n\n    /** The button depressed when this event occurred. */\n    public buttons: number;\n\n    /** Whether the \"control\" key was pressed when this mouse event occurred. */\n    public ctrlKey: boolean;\n\n    /** Whether the \"meta\" key was pressed when this mouse event occurred. */\n    public metaKey: boolean;\n\n    /** This is currently not implemented in the Federated Events API. */\n    public relatedTarget: EventTarget;\n\n    /** Whether the \"shift\" key was pressed when this mouse event occurred. */\n    public shiftKey: boolean;\n\n    /** The coordinates of the mouse event relative to the canvas. */\n    public client: Point = new Point();\n\n    /** @readonly */\n    public get clientX(): number { return this.client.x; }\n\n    /** @readonly */\n    public get clientY(): number { return this.client.y; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n     * @readonly\n     */\n    get x(): number { return this.clientX; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n     * @readonly\n     */\n    get y(): number { return this.clientY; }\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    public movement: Point = new Point();\n\n    /** @readonly */\n    get movementX(): number { return this.movement.x; }\n\n    /** @readonly */\n    get movementY(): number { return this.movement.y; }\n\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    public offset: Point = new Point();\n\n    /** @readonly */\n    get offsetX(): number { return this.offset.x; }\n\n    /** @readonly */\n    get offsetY(): number { return this.offset.y; }\n\n    /** The pointer coordinates in world space. */\n    public global: Point = new Point();\n\n    /** @readonly */\n    get globalX(): number { return this.global.x; }\n\n    /** @readonly */\n    get globalY(): number { return this.global.y; }\n\n    /**\n     * The pointer coordinates in the renderer's {@link AbstractRenderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    public screen: Point = new Point();\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for `screen.x`.\n     * @readonly\n     */\n    get screenX(): number { return this.screen.x; }\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for `screen.y`.\n     * @readonly\n     */\n    get screenY(): number { return this.screen.y; }\n\n    /**\n     * Converts global coordinates into container-local coordinates.\n     *\n     * This method transforms coordinates from world space to a container's local space,\n     * useful for precise positioning and hit testing.\n     * @param container - The Container to get local coordinates for\n     * @param point - Optional Point object to store the result. If not provided, a new Point will be created\n     * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used\n     * @returns The local coordinates as a Point object\n     * @example\n     * ```ts\n     * // Basic usage - get local coordinates relative to a container\n     * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n     *     // Get position relative to the sprite\n     *     const localPos = event.getLocalPosition(sprite);\n     *     console.log('Local position:', localPos.x, localPos.y);\n     * });\n     * // Using custom global coordinates\n     * const customGlobal = new Point(100, 100);\n     * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n     *     // Transform custom coordinates\n     *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);\n     *     console.log('Custom local position:', localPos.x, localPos.y);\n     * });\n     * ```\n     * @see {@link Container.worldTransform} For the transformation matrix\n     * @see {@link Point} For the point class used to store coordinates\n     */\n    public getLocalPosition<P extends PointData = Point>(container: Container, point?: P, globalPos?: PointData): P\n    {\n        return container.worldTransform.applyInverse<P>(globalPos || this.global, point);\n    }\n\n    /**\n     * Whether the modifier key was pressed when this event natively occurred.\n     * @param key - The modifier key.\n     */\n    public getModifierState(key: string): boolean\n    {\n        return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);\n    }\n\n    /**\n     * Not supported.\n     * @param _typeArg\n     * @param _canBubbleArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     * @param _screenXArg\n     * @param _screenYArg\n     * @param _clientXArg\n     * @param _clientYArg\n     * @param _ctrlKeyArg\n     * @param _altKeyArg\n     * @param _shiftKeyArg\n     * @param _metaKeyArg\n     * @param _buttonArg\n     * @param _relatedTargetArg\n     * @deprecated since 7.0.0\n     * @ignore\n     */\n    // eslint-disable-next-line max-params\n    public initMouseEvent(\n        _typeArg: string,\n        _canBubbleArg: boolean,\n        _cancelableArg: boolean,\n        _viewArg: Window,\n        _detailArg: number,\n        _screenXArg: number,\n        _screenYArg: number,\n        _clientXArg: number,\n        _clientYArg: number,\n        _ctrlKeyArg: boolean,\n        _altKeyArg: boolean,\n        _shiftKeyArg: boolean,\n        _metaKeyArg: boolean,\n        _buttonArg: number,\n        _relatedTargetArg: EventTarget\n    ): void\n    {\n        throw new Error('Method not implemented.');\n    }\n}\n","import { FederatedMouseEvent } from './FederatedMouseEvent.mjs';\n\n\"use strict\";\nclass FederatedPointerEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    this.width = 0;\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    this.height = 0;\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    this.isPrimary = false;\n  }\n  /**\n   * Only included for completeness for now\n   * @ignore\n   */\n  getCoalescedEvents() {\n    if (this.type === \"pointermove\" || this.type === \"mousemove\" || this.type === \"touchmove\") {\n      return [this];\n    }\n    return [];\n  }\n  /**\n   * Only included for completeness for now\n   * @ignore\n   */\n  getPredictedEvents() {\n    throw new Error(\"getPredictedEvents is not supported!\");\n  }\n}\n\nexport { FederatedPointerEvent };\n//# sourceMappingURL=FederatedPointerEvent.mjs.map\n","import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A specialized event class for pointer interactions in PixiJS applications.\n * Extends {@link FederatedMouseEvent} to provide advanced pointer-specific features\n * while maintaining compatibility with the DOM PointerEvent interface.\n *\n * Key features:\n * - Supports multi-touch interactions\n * - Provides pressure sensitivity\n * - Handles stylus input\n * - Tracks pointer dimensions\n * - Supports tilt detection\n * @example\n * ```ts\n * // Basic pointer event handling\n * sprite.on('pointerdown', (event: FederatedPointerEvent) => {\n *     // Access pointer information\n *     console.log('Pointer ID:', event.pointerId);\n *     console.log('Pointer Type:', event.pointerType);\n *     console.log('Is Primary:', event.isPrimary);\n *\n *     // Get pressure and tilt data\n *     console.log('Pressure:', event.pressure);\n *     console.log('Tilt:', event.tiltX, event.tiltY);\n *\n *     // Access contact geometry\n *     console.log('Size:', event.width, event.height);\n * });\n *\n * // Handle stylus-specific features\n * sprite.on('pointermove', (event: FederatedPointerEvent) => {\n *     if (event.pointerType === 'pen') {\n *         // Handle stylus tilt\n *         const tiltAngle = Math.atan2(event.tiltY, event.tiltX);\n *         console.log('Tilt angle:', tiltAngle);\n *\n *         // Use barrel button pressure\n *         console.log('Tangential pressure:', event.tangentialPressure);\n *     }\n * });\n * ```\n * @see {@link FederatedMouseEvent} For base mouse event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent} DOM PointerEvent Interface\n * @see {@link EventSystem} For the event management system\n * @category events\n * @standard\n */\nexport class FederatedPointerEvent extends FederatedMouseEvent implements PointerEvent\n{\n    /**\n     * The unique identifier of the pointer.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId}\n     */\n    public pointerId: number;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    public width = 0;\n\n    /**\n     * The angle in radians of a pointer or stylus measuring the vertical angle between\n     * the device's surface to the pointer or stylus.\n     * A stylus at 0 degrees would be directly parallel whereas at /2 degrees it would be perpendicular.\n     * @see https://developer.mozilla.org/docs/Web/API/PointerEvent/altitudeAngle)\n     */\n    public altitudeAngle: number;\n\n    /**\n     * The angle in radians of a pointer or stylus measuring an arc from the X axis of the device to\n     * the pointer or stylus projected onto the screen's plane.\n     * A stylus at 0 degrees would be pointing to the \"0 o'clock\" whereas at /2 degrees it would be pointing at \"6 o'clock\".\n     * @see https://developer.mozilla.org/docs/Web/API/PointerEvent/azimuthAngle)\n     */\n    public azimuthAngle: number;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    public height = 0;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    public isPrimary = false;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     */\n    public pointerType: string;\n\n    /**\n     * Pressure applied by the pointing device during the event.\n     *s\n     * A Touch's force property will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     */\n    public pressure: number;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public tangentialPressure: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     */\n    public tiltX: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     */\n    public tiltY: number;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public twist: number;\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    /**\n     * Only included for completeness for now\n     * @ignore\n     */\n    public getCoalescedEvents(): PointerEvent[]\n    {\n        if (this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove')\n        {\n            return [this];\n        }\n\n        return [];\n    }\n\n    /**\n     * Only included for completeness for now\n     * @ignore\n     */\n    public getPredictedEvents(): PointerEvent[]\n    {\n        throw new Error('getPredictedEvents is not supported!');\n    }\n}\n","import { FederatedMouseEvent } from './FederatedMouseEvent.mjs';\n\n\"use strict\";\nclass FederatedWheelEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    /**\n     * Units specified in pixels.\n     * @ignore\n     */\n    this.DOM_DELTA_PIXEL = 0;\n    /**\n     * Units specified in lines.\n     * @ignore\n     */\n    this.DOM_DELTA_LINE = 1;\n    /**\n     * Units specified in pages.\n     * @ignore\n     */\n    this.DOM_DELTA_PAGE = 2;\n  }\n}\n/**\n * Units specified in pixels.\n * @ignore\n */\nFederatedWheelEvent.DOM_DELTA_PIXEL = 0;\n/**\n * Units specified in lines.\n * @ignore\n */\nFederatedWheelEvent.DOM_DELTA_LINE = 1;\n/**\n * Units specified in pages.\n * @ignore\n */\nFederatedWheelEvent.DOM_DELTA_PAGE = 2;\n\nexport { FederatedWheelEvent };\n//# sourceMappingURL=FederatedWheelEvent.mjs.map\n","import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A specialized event class for wheel/scroll interactions in PixiJS applications.\n * Extends {@link FederatedMouseEvent} to provide wheel-specific properties while\n * maintaining compatibility with the DOM WheelEvent interface.\n *\n * Key features:\n * - Provides scroll delta information\n * - Supports different scroll modes (pixel, line, page)\n * - Inherits mouse event properties\n * - Normalizes cross-browser wheel events\n * @example\n * ```ts\n * // Basic wheel event handling\n * sprite.on('wheel', (event: FederatedWheelEvent) => {\n *     // Get scroll amount\n *     console.log('Vertical scroll:', event.deltaY);\n *     console.log('Horizontal scroll:', event.deltaX);\n *\n *     // Check scroll mode\n *     if (event.deltaMode === FederatedWheelEvent.DOM_DELTA_LINE) {\n *         console.log('Scrolling by lines');\n *     } else if (event.deltaMode === FederatedWheelEvent.DOM_DELTA_PAGE) {\n *         console.log('Scrolling by pages');\n *     } else {\n *         console.log('Scrolling by pixels');\n *     }\n *\n *     // Get scroll position\n *     console.log('Scroll at:', event.global.x, event.global.y);\n * });\n *\n * // Common use case: Zoom control\n * container.on('wheel', (event: FederatedWheelEvent) => {\n *     // Prevent page scrolling\n *     event.preventDefault();\n *\n *     // Zoom in/out based on scroll direction\n *     const zoomFactor = 1 + (event.deltaY / 1000);\n *     container.scale.set(container.scale.x * zoomFactor);\n * });\n * ```\n * @see {@link FederatedMouseEvent} For base mouse event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent} DOM WheelEvent Interface\n * @see {@link EventSystem} For the event management system\n * @category events\n * @standard\n */\nexport class FederatedWheelEvent extends FederatedMouseEvent implements WheelEvent\n{\n    /**\n     * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,\n     * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.\n     */\n    public deltaMode: number;\n\n    /** Horizontal scroll amount */\n    public deltaX: number;\n\n    /** Vertical scroll amount */\n    public deltaY: number;\n\n    /** z-axis scroll amount. */\n    public deltaZ: number;\n\n    /**\n     * Units specified in pixels.\n     * @ignore\n     */\n    public static readonly DOM_DELTA_PIXEL = 0;\n\n    /**\n     * Units specified in pixels.\n     * @ignore\n     */\n    public readonly DOM_DELTA_PIXEL = 0;\n\n    /**\n     * Units specified in lines.\n     * @ignore\n     */\n    public static readonly DOM_DELTA_LINE = 1;\n\n    /**\n     * Units specified in lines.\n     * @ignore\n     */\n    public readonly DOM_DELTA_LINE = 1;\n\n    /**\n     * Units specified in pages.\n     * @ignore\n     */\n    public static readonly DOM_DELTA_PAGE = 2;\n\n    /**\n     * Units specified in pages.\n     * @ignore\n     */\n    public readonly DOM_DELTA_PAGE = 2;\n}\n","import { EventSystem } from './EventSystem.mjs';\nimport { FederatedEvent } from './FederatedEvent.mjs';\n\n\"use strict\";\nconst FederatedContainer = {\n  onclick: null,\n  onmousedown: null,\n  onmouseenter: null,\n  onmouseleave: null,\n  onmousemove: null,\n  onglobalmousemove: null,\n  onmouseout: null,\n  onmouseover: null,\n  onmouseup: null,\n  onmouseupoutside: null,\n  onpointercancel: null,\n  onpointerdown: null,\n  onpointerenter: null,\n  onpointerleave: null,\n  onpointermove: null,\n  onglobalpointermove: null,\n  onpointerout: null,\n  onpointerover: null,\n  onpointertap: null,\n  onpointerup: null,\n  onpointerupoutside: null,\n  onrightclick: null,\n  onrightdown: null,\n  onrightup: null,\n  onrightupoutside: null,\n  ontap: null,\n  ontouchcancel: null,\n  ontouchend: null,\n  ontouchendoutside: null,\n  ontouchmove: null,\n  onglobaltouchmove: null,\n  ontouchstart: null,\n  onwheel: null,\n  get interactive() {\n    return this.eventMode === \"dynamic\" || this.eventMode === \"static\";\n  },\n  set interactive(value) {\n    this.eventMode = value ? \"static\" : \"passive\";\n  },\n  _internalEventMode: void 0,\n  get eventMode() {\n    return this._internalEventMode ?? EventSystem.defaultEventMode;\n  },\n  set eventMode(value) {\n    this._internalEventMode = value;\n  },\n  isInteractive() {\n    return this.eventMode === \"static\" || this.eventMode === \"dynamic\";\n  },\n  interactiveChildren: true,\n  hitArea: null,\n  addEventListener(type, listener, options) {\n    const capture = typeof options === \"boolean\" && options || typeof options === \"object\" && options.capture;\n    const signal = typeof options === \"object\" ? options.signal : void 0;\n    const once = typeof options === \"object\" ? options.once === true : false;\n    const context = typeof listener === \"function\" ? void 0 : listener;\n    type = capture ? `${type}capture` : type;\n    const listenerFn = typeof listener === \"function\" ? listener : listener.handleEvent;\n    const emitter = this;\n    if (signal) {\n      signal.addEventListener(\"abort\", () => {\n        emitter.off(type, listenerFn, context);\n      });\n    }\n    if (once) {\n      emitter.once(type, listenerFn, context);\n    } else {\n      emitter.on(type, listenerFn, context);\n    }\n  },\n  removeEventListener(type, listener, options) {\n    const capture = typeof options === \"boolean\" && options || typeof options === \"object\" && options.capture;\n    const context = typeof listener === \"function\" ? void 0 : listener;\n    type = capture ? `${type}capture` : type;\n    listener = typeof listener === \"function\" ? listener : listener.handleEvent;\n    this.off(type, listener, context);\n  },\n  dispatchEvent(e) {\n    if (!(e instanceof FederatedEvent)) {\n      throw new Error(\"Container cannot propagate events outside of the Federated Events API\");\n    }\n    e.defaultPrevented = false;\n    e.path = null;\n    e.target = this;\n    e.manager.dispatchEvent(e);\n    return !e.defaultPrevented;\n  }\n};\n\nexport { FederatedContainer };\n//# sourceMappingURL=FederatedEventTarget.mjs.map\n","import { EventSystem } from './EventSystem';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type EventEmitter from 'eventemitter3';\nimport type { Container } from '../scene/container/Container';\nimport type { AllFederatedEventMap } from './FederatedEventMap';\nimport type { FederatedPointerEvent } from './FederatedPointerEvent';\nimport type { FederatedWheelEvent } from './FederatedWheelEvent';\n\n/**\n * The type of cursor to use when the mouse pointer is hovering over an interactive element.\n * Accepts any valid CSS cursor value.\n * @example\n * ```ts\n * // Basic cursor types\n * sprite.cursor = 'pointer';    // Hand cursor for clickable elements\n * sprite.cursor = 'grab';       // Grab cursor for draggable elements\n * sprite.cursor = 'crosshair';  // Precise cursor for selection\n *\n * // Direction cursors\n * sprite.cursor = 'n-resize';   // North resize\n * sprite.cursor = 'ew-resize';  // East-west resize\n * sprite.cursor = 'nesw-resize';// Northeast-southwest resize\n *\n * // Custom cursor with fallback\n * sprite.cursor = 'url(\"custom.png\"), auto';\n * ```\n *\n * Common cursor values:\n * - Basic: `auto`, `default`, `none`, `pointer`, `wait`\n * - Text: `text`, `vertical-text`\n * - Links: `alias`, `copy`, `move`\n * - Selection: `cell`, `crosshair`\n * - Drag: `grab`, `grabbing`\n * - Disabled: `not-allowed`, `no-drop`\n * - Resize: `n-resize`, `e-resize`, `s-resize`, `w-resize`\n * - Bidirectional: `ns-resize`, `ew-resize`, `nesw-resize`, `nwse-resize`\n * - Other: `help`, `progress`\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Documentation\n * @category events\n * @standard\n */\nexport type Cursor = 'auto'\n| 'default'\n| 'none'\n| 'context-menu'\n| 'help'\n| 'pointer'\n| 'progress'\n| 'wait'\n| 'cell'\n| 'crosshair'\n| 'text'\n| 'vertical-text'\n| 'alias'\n| 'copy'\n| 'move'\n| 'no-drop'\n| 'not-allowed'\n| 'e-resize'\n| 'n-resize'\n| 'ne-resize'\n| 'nw-resize'\n| 's-resize'\n| 'se-resize'\n| 'sw-resize'\n| 'w-resize'\n| 'ns-resize'\n| 'ew-resize'\n| 'nesw-resize'\n| 'col-resize'\n| 'nwse-resize'\n| 'row-resize'\n| 'all-scroll'\n| 'zoom-in'\n| 'zoom-out'\n| 'grab'\n| 'grabbing';\n\n/**\n * Interface defining a hit area for pointer interaction. The hit area specifies\n * the region in which pointer events should be captured by a display object.\n * @example\n * ```ts\n * // Create a rectangular hit area\n * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n *\n * // Create a circular hit area\n * sprite.hitArea = new Circle(50, 50, 50);\n *\n * // Custom hit area implementation\n * sprite.hitArea = {\n *     contains(x: number, y: number) {\n *         // Custom hit testing logic\n *         return x >= 0 && x <= 100 && y >= 0 && y <= 100;\n *     }\n * };\n * ```\n * @remarks\n * - Hit areas override the default bounds-based hit testing\n * - Can improve performance by simplifying hit tests\n * - Useful for irregular shapes or precise interaction areas\n * - Common implementations include Rectangle, Circle, Polygon\n * @see {@link Container.eventMode} For enabling interactivity\n * @see {@link Container.interactive} For backwards compatibility\n * @category events\n * @standard\n */\nexport interface IHitArea\n{\n    /**\n     * Checks if the given coordinates are inside this hit area.\n     * @param {number} x - The x coordinate to check\n     * @param {number} y - The y coordinate to check\n     * @returns True if the coordinates are inside the hit area\n     */\n    contains(x: number, y: number): boolean;\n}\n\n/**\n * Function type for handlers, e.g., onclick\n * @category events\n * @advanced\n */\nexport type FederatedEventHandler<T = FederatedPointerEvent> = (event: T) => void;\n\n/**\n * The type of interaction behavior for a Container. This is set via the {@link Container#eventMode} property.\n * @example\n * ```ts\n * // Basic event mode setup\n * const sprite = new Sprite(texture);\n * sprite.eventMode = 'static';    // Enable standard interaction\n * sprite.on('pointerdown', () => { console.log('clicked!'); });\n *\n * // Different event modes\n * sprite.eventMode = 'none';      // Disable all interaction\n * sprite.eventMode = 'passive';   // Only allow interaction on children\n * sprite.eventMode = 'auto';      // Like DOM pointer-events: auto\n * sprite.eventMode = 'dynamic';   // For moving/animated objects\n * ```\n *\n * Available modes:\n * - `'none'`: Ignores all interaction events, even on its children\n * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive children.\n * Interactive children will still emit events.\n * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7\n * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from\n * a ticker to allow for interaction when the mouse isn't moving\n *\n * Performance tips:\n * - Use `'none'` for pure visual elements\n * - Use `'passive'` for containers with some interactive children\n * - Use `'static'` for standard buttons/controls\n * - Use `'dynamic'` only for moving/animated interactive elements\n * @since 7.2.0\n * @category events\n * @standard\n */\nexport type EventMode = 'none' | 'passive' | 'auto' | 'static' | 'dynamic';\n\n/**\n * The properties available for any interactive object. This interface defines the core interaction\n * properties and event handlers that can be set on any Container in PixiJS.\n * @example\n * ```ts\n * // Basic interactive setup\n * const sprite = new Sprite(texture);\n * sprite.eventMode = 'static';\n * sprite.cursor = 'pointer';\n *\n * // Using event handlers\n * sprite.on('click', (event) => console.log('Sprite clicked!', event));\n * sprite.on('pointerdown', (event) => console.log('Pointer down!', event));\n *\n * // Using property-based event handlers\n * sprite.onclick = (event) => console.log('Clicked!');\n * sprite.onpointerenter = () => sprite.alpha = 0.7;\n * sprite.onpointerleave = () => sprite.alpha = 1.0;\n *\n * // Custom hit area\n * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n * ```\n *\n * Core Properties:\n * - `eventMode`: Controls how the object handles interaction events\n * - `cursor`: Sets the mouse cursor when hovering\n * - `hitArea`: Defines custom hit testing area\n * - `interactive`: Alias for `eventMode` to enable interaction with \"static\" or \"passive\" modes\n * - `interactiveChildren`: Controls hit testing on children\n *\n * Event Handlers:\n * - Mouse: click, mousedown, mouseup, mousemove, mouseenter, mouseleave\n * - Touch: touchstart, touchend, touchmove, tap\n * - Pointer: pointerdown, pointerup, pointermove, pointerover\n * - Global: globalpointermove, globalmousemove, globaltouchmove\n * > [!IMPORTANT] Global events are fired when the pointer moves even if it is outside the bounds of the Container.\n * @see {@link EventMode} For interaction mode details\n * @see {@link Cursor} For cursor style options\n * @see {@link IHitArea} For hit area implementation\n * @category events\n * @standard\n */\nexport interface FederatedOptions\n{\n    /**\n     * The cursor style to display when the mouse pointer is hovering over the object.\n     * Accepts any valid CSS cursor value or custom cursor URL.\n     * @example\n     * ```ts\n     * // Common cursor types\n     * sprite.cursor = 'pointer';     // Hand cursor for clickable elements\n     * sprite.cursor = 'grab';        // Grab cursor for draggable elements\n     * sprite.cursor = 'crosshair';   // Precise cursor for selection\n     * sprite.cursor = 'not-allowed'; // Indicate disabled state\n     *\n     * // Direction cursors\n     * sprite.cursor = 'n-resize';    // North resize\n     * sprite.cursor = 'ew-resize';   // East-west resize\n     * sprite.cursor = 'nesw-resize'; // Northeast-southwest resize\n     *\n     * // Custom cursor with fallback\n     * sprite.cursor = 'url(\"custom.png\"), auto';\n     * sprite.cursor = 'url(\"cursor.cur\") 2 2, pointer'; // With hotspot offset\n     * ```\n     * @type {Cursor | string}\n     * @default undefined\n     * @see {@link EventSystem.cursorStyles} For setting global cursor styles\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Documentation\n     */\n    cursor?: Cursor | (string & {});\n    /**\n     * Enable interaction events for the Container. Touch, pointer and mouse events are supported.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     *\n     * // Enable standard interaction (like buttons)\n     * sprite.eventMode = 'static';\n     * sprite.on('pointerdown', () => console.log('clicked!'));\n     *\n     * // Enable for moving objects\n     * sprite.eventMode = 'dynamic';\n     * sprite.on('pointermove', () => updatePosition());\n     *\n     * // Disable all interaction\n     * sprite.eventMode = 'none';\n     *\n     * // Only allow child interactions\n     * sprite.eventMode = 'passive';\n     * ```\n     *\n     * Available modes:\n     *\n     * - `'none'`: Ignores all interaction events, even on its children. Best for pure visuals.\n     * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive\n     * children. Interactive children will still emit events.\n     * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7.\n     * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7. Best for buttons/UI.\n     * - `'dynamic'`: Like static but also receives synthetic events when pointer is idle. Best for moving objects.\n     *\n     * Performance tips:\n     * - Use `'none'` for pure visual elements\n     * - Use `'passive'` for containers with some interactive children\n     * - Use `'static'` for standard UI elements\n     * - Use `'dynamic'` only when needed for moving/animated elements\n     * @since 7.2.0\n     */\n    eventMode?: EventMode;\n    /**\n     * Whether this object should fire UI events. This is an alias for `eventMode` set to `'static'` or `'passive'`.\n     * Setting this to true will enable interaction events like `pointerdown`, `click`, etc.\n     * Setting it to false will disable all interaction events on this object.\n     * @see {@link Container.eventMode}\n     * @example\n     * ```ts\n     * // Enable interaction events\n     * sprite.interactive = true;  // Sets eventMode = 'static'\n     * sprite.interactive = false; // Sets eventMode = 'passive'\n     * ```\n     */\n    interactive?: boolean\n    /**\n     * Controls whether children of this container can receive pointer events.\n     *\n     * Setting this to false allows PixiJS to skip hit testing on all children,\n     * improving performance for containers with many non-interactive children.\n     * @default true\n     * @example\n     * ```ts\n     * // Container with many visual-only children\n     * const container = new Container();\n     * container.interactiveChildren = false; // Skip hit testing children\n     *\n     * // Menu with interactive buttons\n     * const menu = new Container();\n     * menu.interactiveChildren = true; // Test all children\n     * menu.addChild(button1, button2, button3);\n     *\n     * // Performance optimization\n     * background.interactiveChildren = false;\n     * foreground.interactiveChildren = true;\n     * ```\n     */\n    interactiveChildren?: boolean;\n    /**\n     * Defines a custom hit area for pointer interaction testing. When set, this shape will be used\n     * for hit testing instead of the container's standard bounds.\n     * @example\n     * ```ts\n     * import { Rectangle, Circle, Sprite } from 'pixi.js';\n     *\n     * // Rectangular hit area\n     * const button = new Sprite(texture);\n     * button.eventMode = 'static';\n     * button.hitArea = new Rectangle(0, 0, 100, 50);\n     *\n     * // Circular hit area\n     * const icon = new Sprite(texture);\n     * icon.eventMode = 'static';\n     * icon.hitArea = new Circle(32, 32, 32);\n     *\n     * // Custom hit area with polygon\n     * const custom = new Sprite(texture);\n     * custom.eventMode = 'static';\n     * custom.hitArea = new Polygon([0,0, 100,0, 100,100, 0,100]);\n     *\n     * // Custom hit testing logic\n     * sprite.hitArea = {\n     *     contains(x: number, y: number) {\n     *         // Custom collision detection\n     *         return x >= 0 && x <= width && y >= 0 && y <= height;\n     *     }\n     * };\n     * ```\n     * @remarks\n     * - Takes precedence over the container's bounds for hit testing\n     * - Can improve performance by simplifying collision checks\n     * - Useful for irregular shapes or precise click areas\n     */\n    hitArea?: IHitArea | null;\n\n    /**\n     * Property-based event handler for the `click` event.\n     * Fired when a pointer device (mouse, touch, etc.) completes a click action.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('click', (event) => {\n     *    console.log('Sprite clicked at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onclick = (event) => {\n     *     console.log('Clicked at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onclick?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mousedown` event.\n     * Fired when a mouse button is pressed while the pointer is over the object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mousedown', (event) => {\n     *    sprite.alpha = 0.5; // Visual feedback\n     *    console.log('Mouse button:', event.button);\n     * });\n     * // Using property-based handler\n     * sprite.onmousedown = (event) => {\n     *     sprite.alpha = 0.5; // Visual feedback\n     *     console.log('Mouse button:', event.button);\n     * };\n     * ```\n     * @default null\n     */\n    onmousedown?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseenter` event.\n     * Fired when the mouse pointer enters the bounds of the object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseenter', (event) => {\n     *     sprite.scale.set(1.1);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseenter = (event) => {\n     *     sprite.scale.set(1.1);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseenter?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseleave` event.\n     * Fired when the pointer leaves the bounds of the display object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseleave', (event) => {\n     *    sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseleave = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseleave?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mousemove` event.\n     * Fired when the pointer moves while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mousemove', (event) => {\n     *    // Get coordinates relative to the sprite\n     *   console.log('Local:', event.getLocalPosition(sprite));\n     * });\n     * // Using property-based handler\n     * sprite.onmousemove = (event) => {\n     *     // Get coordinates relative to the sprite\n     *     console.log('Local:', event.getLocalPosition(sprite));\n     * };\n     * ```\n     * @default null\n     */\n    onmousemove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `globalmousemove` event.\n     *\n     * Fired when the mouse moves anywhere, regardless of whether the pointer is over this object.\n     * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('globalmousemove', (event) => {\n     *     // Move sprite to mouse position\n     *     sprite.position.copyFrom(event.global);\n     * });\n     * // Using property-based handler\n     * sprite.onglobalmousemove = (event) => {\n     *     // Move sprite to mouse position\n     *     sprite.position.copyFrom(event.global);\n     * };\n     * ```\n     * @default null\n     * @remarks\n     * - Fires even when the mouse is outside the object's bounds\n     * - Useful for drag operations or global mouse tracking\n     * - Must have `eventMode` set appropriately to receive events\n     * - Part of the global move events family along with `globalpointermove` and `globaltouchmove`\n     */\n    onglobalmousemove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseout` event.\n     * Fired when the pointer moves out of the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseout', (event) => {\n     *    sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseout = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseout?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseover` event.\n     * Fired when the pointer moves onto the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseover', (event) => {\n     *      sprite.scale.set(1.1);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseover = (event) => {\n     *     sprite.scale.set(1.1);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseover?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseup` event.\n     * Fired when a mouse button is released over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseup', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseup = (event) => {\n     *      sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseup?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseupoutside` event.\n     * Fired when a mouse button is released outside the display object that initially\n     * registered a mousedown.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseupoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseupoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseupoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointercancel` event.\n     * Fired when a pointer device interaction is canceled or lost.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointercancel', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointercancel = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointercancel?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerdown` event.\n     * Fired when a pointer device button (mouse, touch, pen, etc.) is pressed.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerdown', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerdown = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerdown?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerenter` event.\n     * Fired when a pointer device enters the bounds of the display object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerenter', (event) => {\n     *     sprite.scale.set(1.2);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerenter = (event) => {\n     *     sprite.scale.set(1.2);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerenter?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerleave` event.\n     * Fired when a pointer device leaves the bounds of the display object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * // Using emitter handler\n     * sprite.on('pointerleave', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerleave = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerleave?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointermove` event.\n     * Fired when a pointer device moves while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointermove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onpointermove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onpointermove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `globalpointermove` event.\n     *\n     * Fired when the pointer moves anywhere, regardless of whether the pointer is over this object.\n     * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('globalpointermove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onglobalpointermove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     * @remarks\n     * - Fires even when the mouse is outside the object's bounds\n     * - Useful for drag operations or global mouse tracking\n     * - Must have `eventMode` set appropriately to receive events\n     * - Part of the global move events family along with `globalpointermove` and `globaltouchmove`\n     */\n    onglobalpointermove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerout` event.\n     * Fired when the pointer moves out of the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerout', (event) => {\n     *    sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerout = (event) => {\n     *    sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerout?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerover` event.\n     * Fired when the pointer moves over the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerover', (event) => {\n     *     sprite.scale.set(1.2);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerover = (event) => {\n     *     sprite.scale.set(1.2);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerover?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointertap` event.\n     * Fired when a pointer device completes a tap action (e.g., touch or mouse click).\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointertap', (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onpointertap = (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onpointertap?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerup` event.\n     * Fired when a pointer device button (mouse, touch, pen, etc.) is released.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerup', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerup = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerup?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerupoutside` event.\n     * Fired when a pointer device button is released outside the bounds of the display object\n     * that initially registered a pointerdown.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerupoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerupoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerupoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightclick` event.\n     * Fired when a right-click (context menu) action is performed on the object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightclick', (event) => {\n     *     console.log('Right-clicked at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onrightclick = (event) => {\n     *     console.log('Right-clicked at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onrightclick?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightdown` event.\n     * Fired when a right mouse button is pressed down over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightdown', (event) => {\n     *     sprite.scale.set(0.9);\n     * });\n     * // Using property-based handler\n     * sprite.onrightdown = (event) => {\n     *     sprite.scale.set(0.9);\n     * };\n     * ```\n     * @default null\n     */\n    onrightdown?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightup` event.\n     * Fired when a right mouse button is released over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightup', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onrightup = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onrightup?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightupoutside` event.\n     * Fired when a right mouse button is released outside the bounds of the display object\n     * that initially registered a rightdown.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightupoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onrightupoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onrightupoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `tap` event.\n     * Fired when a tap action (touch) is completed on the object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('tap', (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.ontap = (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    ontap?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchcancel` event.\n     * Fired when a touch interaction is canceled, such as when the touch is interrupted.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchcancel', (event) => {\n     *     console.log('Touch canceled at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchcancel = (event) => {\n     *     console.log('Touch canceled at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchcancel?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchend` event.\n     * Fired when a touch interaction ends, such as when the finger is lifted from the screen.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchend', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchend = (event) => {\n     *    sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchend?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchendoutside` event.\n     * Fired when a touch interaction ends outside the bounds of the display object\n     * that initially registered a touchstart.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchendoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchendoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchendoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchmove` event.\n     * Fired when a touch interaction moves while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchmove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchmove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchmove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `globaltouchmove` event.\n     *\n     * Fired when a touch interaction moves anywhere, regardless of whether the pointer is over this object.\n     * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('globaltouchmove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onglobaltouchmove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     * @remarks\n     * - Fires even when the touch is outside the object's bounds\n     * - Useful for drag operations or global touch tracking\n     * - Must have `eventMode` set appropriately to receive events\n     * - Part of the global move events family along with `globalpointermove` and `globalmousemove`\n     */\n    onglobaltouchmove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchstart` event.\n     * Fired when a touch interaction starts, such as when a finger touches the screen.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchstart', (event) => {\n     *     sprite.scale.set(0.9);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchstart = (event) => {\n     *     sprite.scale.set(0.9);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchstart?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `wheel` event.\n     * Fired when the mouse wheel is scrolled while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('wheel', (event) => {\n     *     sprite.scale.x += event.deltaY * 0.01; // Zoom in/out\n     *     sprite.scale.y += event.deltaY * 0.01; // Zoom in/out\n     * });\n     * // Using property-based handler\n     * sprite.onwheel = (event) => {\n     *     sprite.scale.x += event.deltaY * 0.01; // Zoom in/out\n     *     sprite.scale.y += event.deltaY * 0.01; // Zoom in/out\n     * };\n     * ```\n     * @default null\n     */\n    onwheel?: FederatedEventHandler<FederatedWheelEvent> | null;\n}\n\n/**\n * The options for the `addEventListener` method.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener}\n * @category events\n * @advanced\n */\nexport type AddListenerOptions = boolean | AddEventListenerOptions;\n/**\n * The options for the `removeEventListener` method.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener}\n * @category events\n * @advanced\n */\nexport type RemoveListenerOptions = boolean | EventListenerOptions;\n\n/**\n * Additional properties for a Container that is used for interaction events.\n * @category events\n * @advanced\n */\nexport interface IFederatedContainer extends FederatedOptions\n{\n    /** The parent of this event target. */\n    readonly parent?: Container;\n\n    /** The children of this event target. */\n    readonly children?: ReadonlyArray<Container>;\n\n    /** @private */\n    _internalEventMode: EventMode;\n\n    /**\n     * Determines if the container is interactive or not\n     * @returns {boolean} Whether the container is interactive or not\n     * @since 7.2.0\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'dynamic';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'none';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'passive';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'auto';\n     * sprite.isInteractive(); // false\n     */\n    isInteractive: () => boolean;\n    /**\n     * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`\n     * seeks to be compatible with the DOM's `addEventListener` with support for options.\n     * @param {any} type - The type of event to listen to.\n     * @param {any} listener - The listener callback or object.\n     * @param {any} options - Listener options, used for capture phase.\n     * @example\n     * // Tell the user whether they did a single, double, triple, or nth click.\n     * button.addEventListener('click', {\n     *     handleEvent(e): {\n     *         let prefix;\n     *\n     *         switch (e.detail) {\n     *             case 1: prefix = 'single'; break;\n     *             case 2: prefix = 'double'; break;\n     *             case 3: prefix = 'triple'; break;\n     *             default: prefix = e.detail + 'th'; break;\n     *         }\n     *\n     *         console.log('That was a ' + prefix + 'click');\n     *     }\n     * });\n     *\n     * // But skip the first click!\n     * button.parent.addEventListener('click', function blockClickOnce(e) {\n     *     e.stopImmediatePropagation();\n     *     button.parent.removeEventListener('click', blockClickOnce, true);\n     * }, {\n     *     capture: true,\n     * });\n     */\n    addEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: AddListenerOptions\n    ): void;\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    ): void;\n    /**\n     * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`\n     * seeks to be compatible with the DOM's `removeEventListener` with support for options.\n     * @param {K} type - The type of event the listener is bound to.\n     * @param {any} listener - The listener callback or object.\n     * @param {RemoveListenerOptions} options - The original listener options.\n     * This is required to deregister a capture phase listener.\n     */\n    removeEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: RemoveListenerOptions\n    ): void;\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    ): void;\n    /**\n     * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.\n     *\n     * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.\n     * @param {FederatedEvent} e - The event to dispatch.\n     * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.\n     * @example\n     * // Reuse a click event!\n     * button.dispatchEvent(clickEvent);\n     */\n    dispatchEvent(e: FederatedEvent): boolean;\n}\n\n/** @internal */\nexport const FederatedContainer: IFederatedContainer = {\n    onclick: null,\n    onmousedown: null,\n    onmouseenter: null,\n    onmouseleave: null,\n    onmousemove: null,\n    onglobalmousemove: null,\n    onmouseout: null,\n    onmouseover:  null,\n    onmouseup:  null,\n    onmouseupoutside: null,\n    onpointercancel: null,\n    onpointerdown:  null,\n    onpointerenter: null,\n    onpointerleave:  null,\n    onpointermove:  null,\n    onglobalpointermove:  null,\n    onpointerout:  null,\n    onpointerover:  null,\n    onpointertap:  null,\n    onpointerup:  null,\n    onpointerupoutside:  null,\n    onrightclick:  null,\n    onrightdown:  null,\n    onrightup:  null,\n    onrightupoutside:  null,\n    ontap:  null,\n    ontouchcancel:  null,\n    ontouchend:  null,\n    ontouchendoutside:  null,\n    ontouchmove:  null,\n    onglobaltouchmove:  null,\n    ontouchstart:  null,\n    onwheel:  null,\n    get interactive()\n    {\n        return this.eventMode === 'dynamic' || this.eventMode === 'static';\n    },\n    set interactive(value: boolean)\n    {\n        this.eventMode = value ? 'static' : 'passive';\n    },\n    _internalEventMode: undefined,\n    get eventMode()\n    {\n        return this._internalEventMode ?? EventSystem.defaultEventMode;\n    },\n    set eventMode(value)\n    {\n        this._internalEventMode = value;\n    },\n    isInteractive(): boolean\n    {\n        return this.eventMode === 'static' || this.eventMode === 'dynamic';\n    },\n    interactiveChildren: true,\n    hitArea: null,\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n        || (typeof options === 'object' && options.capture);\n        const signal = typeof options === 'object' ? options.signal : undefined;\n        const once = typeof options === 'object' ? (options.once === true) : false;\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        const listenerFn = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        const emitter = (this as unknown as EventEmitter);\n\n        if (signal)\n        {\n            signal.addEventListener('abort', () =>\n            {\n                emitter.off(type, listenerFn, context);\n            });\n        }\n\n        if (once)\n        {\n            emitter.once(type, listenerFn, context);\n        }\n        else\n        {\n            emitter.on(type, listenerFn, context);\n        }\n    },\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n            || (typeof options === 'object' && options.capture);\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        listener = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        (this as unknown as EventEmitter).off(type, listener, context);\n    },\n    dispatchEvent(e: Event): boolean\n    {\n        if (!(e instanceof FederatedEvent))\n        {\n            throw new Error('Container cannot propagate events outside of the Federated Events API');\n        }\n\n        e.defaultPrevented = false;\n        e.path = null;\n        e.target = this as Container;\n        e.manager.dispatchEvent(e);\n\n        return !e.defaultPrevented;\n    }\n};\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { DOMPipe } from './DOMPipe.mjs';\nimport './index.mjs';\nexport { DOMContainer } from './DOMContainer.mjs';\n\n\"use strict\";\nextensions.add(DOMPipe);\n\nexport { DOMPipe };\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { DOMPipe } from './DOMPipe';\n\nexport * from './index';\n\nextensions.add(DOMPipe);\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass DOMPipe {\n  /**\n   * Constructor for the DOMPipe class.\n   * @param renderer - The renderer instance that this DOMPipe will be associated with.\n   */\n  constructor(renderer) {\n    /** Array to keep track of attached DOM elements */\n    this._attachedDomElements = [];\n    this._renderer = renderer;\n    this._renderer.runners.postrender.add(this);\n    this._domElement = document.createElement(\"div\");\n    this._domElement.style.position = \"absolute\";\n    this._domElement.style.top = \"0\";\n    this._domElement.style.left = \"0\";\n    this._domElement.style.pointerEvents = \"none\";\n    this._domElement.style.zIndex = \"1000\";\n  }\n  /**\n   * Adds a renderable DOM container to the list of attached elements.\n   * @param domContainer - The DOM container to be added.\n   * @param _instructionSet - The instruction set (unused).\n   */\n  addRenderable(domContainer, _instructionSet) {\n    if (!this._attachedDomElements.includes(domContainer)) {\n      this._attachedDomElements.push(domContainer);\n    }\n  }\n  /**\n   * Updates a renderable DOM container.\n   * @param _domContainer - The DOM container to be updated (unused).\n   */\n  updateRenderable(_domContainer) {\n  }\n  /**\n   * Validates a renderable DOM container.\n   * @param _domContainer - The DOM container to be validated (unused).\n   * @returns Always returns true as validation is not required.\n   */\n  validateRenderable(_domContainer) {\n    return true;\n  }\n  /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */\n  postrender() {\n    const attachedDomElements = this._attachedDomElements;\n    if (attachedDomElements.length === 0) {\n      this._domElement.remove();\n      return;\n    }\n    const canvas = this._renderer.view.canvas;\n    if (this._domElement.parentNode !== canvas.parentNode) {\n      canvas.parentNode?.appendChild(this._domElement);\n    }\n    const sx = parseFloat(canvas.style.width) / canvas.width * this._renderer.resolution;\n    const sy = parseFloat(canvas.style.height) / canvas.height * this._renderer.resolution;\n    this._domElement.style.transform = `translate(${canvas.offsetLeft}px, ${canvas.offsetTop}px) scale(${sx}, ${sy})`;\n    for (let i = 0; i < attachedDomElements.length; i++) {\n      const domContainer = attachedDomElements[i];\n      const element = domContainer.element;\n      if (!domContainer.parent || domContainer.globalDisplayStatus < 7) {\n        element?.remove();\n        attachedDomElements.splice(i, 1);\n        i--;\n      } else {\n        if (!this._domElement.contains(element)) {\n          element.style.position = \"absolute\";\n          element.style.pointerEvents = \"auto\";\n          this._domElement.appendChild(element);\n        }\n        const wt = domContainer.worldTransform;\n        const anchor = domContainer._anchor;\n        const ax = domContainer.width * anchor.x;\n        const ay = domContainer.height * anchor.y;\n        element.style.transformOrigin = `${ax}px ${ay}px`;\n        element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;\n        element.style.opacity = domContainer.groupAlpha.toString();\n      }\n    }\n  }\n  /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */\n  destroy() {\n    this._renderer.runners.postrender.remove(this);\n    for (let i = 0; i < this._attachedDomElements.length; i++) {\n      const domContainer = this._attachedDomElements[i];\n      domContainer.element?.remove();\n    }\n    this._attachedDomElements.length = 0;\n    this._domElement.remove();\n    this._renderer = null;\n  }\n}\n/**\n * Static property defining the extension type and name for the DOMPipe.\n * This is used to register the DOMPipe with different rendering pipelines.\n */\nDOMPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"dom\"\n};\n\nexport { DOMPipe };\n//# sourceMappingURL=DOMPipe.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\nimport { type DOMContainer } from './DOMContainer';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\n\n/**\n * The DOMPipe class is responsible for managing and rendering DOM elements within a PixiJS scene.\n * It maps dom elements to the canvas and ensures they are correctly positioned and visible.\n * @internal\n */\nexport class DOMPipe implements RenderPipe<DOMContainer>\n{\n    /**\n     * Static property defining the extension type and name for the DOMPipe.\n     * This is used to register the DOMPipe with different rendering pipelines.\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'dom',\n    } as const;\n\n    private _renderer: Renderer;\n\n    /** Array to keep track of attached DOM elements */\n    private readonly _attachedDomElements: DOMContainer[] = [];\n    /** The main DOM element that acts as a container for other DOM elements */\n    private readonly _domElement: HTMLDivElement;\n\n    /**\n     * Constructor for the DOMPipe class.\n     * @param renderer - The renderer instance that this DOMPipe will be associated with.\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n\n        // Add this DOMPipe to the postrender runner of the renderer\n        // we want to dom elements are calculated after all things have been rendered\n        this._renderer.runners.postrender.add(this);\n\n        // Create a main DOM element to contain other DOM elements\n        this._domElement = document.createElement('div');\n        this._domElement.style.position = 'absolute';\n        this._domElement.style.top = '0';\n        this._domElement.style.left = '0';\n        this._domElement.style.pointerEvents = 'none';\n        this._domElement.style.zIndex = '1000';\n    }\n\n    /**\n     * Adds a renderable DOM container to the list of attached elements.\n     * @param domContainer - The DOM container to be added.\n     * @param _instructionSet - The instruction set (unused).\n     */\n    public addRenderable(domContainer: DOMContainer, _instructionSet: InstructionSet): void\n    {\n        if (!this._attachedDomElements.includes(domContainer))\n        {\n            this._attachedDomElements.push(domContainer);\n        }\n    }\n\n    /**\n     * Updates a renderable DOM container.\n     * @param _domContainer - The DOM container to be updated (unused).\n     */\n    public updateRenderable(_domContainer: DOMContainer): void\n    {\n        // Updates happen in postrender\n    }\n\n    /**\n     * Validates a renderable DOM container.\n     * @param _domContainer - The DOM container to be validated (unused).\n     * @returns Always returns true as validation is not required.\n     */\n    public validateRenderable(_domContainer: DOMContainer): boolean\n    {\n        return true;\n    }\n\n    /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */\n    public postrender(): void\n    {\n        const attachedDomElements = this._attachedDomElements;\n\n        if (attachedDomElements.length === 0)\n        {\n            this._domElement.remove();\n\n            return;\n        }\n\n        const canvas = this._renderer.view.canvas as HTMLCanvasElement;\n\n        if (this._domElement.parentNode !== canvas.parentNode)\n        {\n            canvas.parentNode?.appendChild(this._domElement);\n        }\n\n        const sx = (parseFloat(canvas.style.width) / canvas.width) * this._renderer.resolution;\n        const sy = (parseFloat(canvas.style.height) / canvas.height) * this._renderer.resolution;\n        // scale according to the canvas scale and translate\n\n        this._domElement.style.transform = `translate(${canvas.offsetLeft}px, ${canvas.offsetTop}px) scale(${sx}, ${sy})`;\n\n        for (let i = 0; i < attachedDomElements.length; i++)\n        {\n            const domContainer = attachedDomElements[i];\n            const element = domContainer.element;\n\n            if (!domContainer.parent || domContainer.globalDisplayStatus < 0b111)\n            {\n                element?.remove();\n                attachedDomElements.splice(i, 1);\n                i--;\n            }\n            else\n            {\n                if (!this._domElement.contains(element))\n                {\n                    element.style.position = 'absolute';\n                    element.style.pointerEvents = 'auto';\n                    this._domElement.appendChild(element);\n                }\n\n                const wt = domContainer.worldTransform;\n                const anchor = domContainer._anchor;\n                const ax = domContainer.width * anchor.x;\n                const ay = domContainer.height * anchor.y;\n\n                element.style.transformOrigin = `${ax}px ${ay}px`;\n                element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;\n                element.style.opacity = domContainer.groupAlpha.toString();\n            }\n        }\n    }\n\n    /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */\n    public destroy(): void\n    {\n        this._renderer.runners.postrender.remove(this);\n\n        for (let i = 0; i < this._attachedDomElements.length; i++)\n        {\n            const domContainer = this._attachedDomElements[i];\n\n            domContainer.element?.remove();\n        }\n\n        this._attachedDomElements.length = 0;\n        this._domElement.remove();\n        this._renderer = null;\n    }\n}\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link GlStateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @category rendering\n * @advanced\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    /** @internal */\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","/**\n * @param rgb\n * @param alpha\n * @param out\n * @param offset\n * @internal\n */\nexport function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\n/**\n * @param abgr\n * @param out\n * @param offset\n * @internal\n */\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n  destroy() {\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @internal\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n\n    public destroy()\n    {\n        // BOOM!\n    }\n}\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","/** @internal */\nexport const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\n/** @internal */\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\n/** @internal */\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$arnWa","$39lGH","$3FyDp","$ftgKc","extensions","add","AccessibilitySystem","mixin","Container","accessibilityTarget","$0d635074c2b7a040$export$982526b2aa4fb64c","$1KB1X","$4IeSv","$eFJqo","$0d635074c2b7a040$var$_AccessibilitySystem","_AccessibilitySystem","renderer","_mobileInfo","isMobile","debug","_activateOnTab","_deactivateOnMouseMove","_isActive","_isMobileAccessibility","_div","_pool","_renderId","_children","_androidUpdateCount","_androidUpdateFrequency","_hookDiv","tablet","phone","_createTouchHook","_renderer","isActive","isMobileAccessibility","hookDiv","document","createElement","style","width","height","position","top","left","zIndex","$0d635074c2b7a040$var$DIV_HOOK_ZINDEX","backgroundColor","title","addEventListener","_activate","_destroyTouchHook","body","appendChild","removeChild","$0d635074c2b7a040$var$DIV_TOUCH_ZINDEX","pointerEvents","_onKeyDown","bind","_onMouseMove","canvas","view","parentNode","_initAccessibilitySetup","observer","MutationObserver","disconnect","observe","childList","subtree","runners","postrender","lastObjectRendered","_updateAccessibleObjects","_deactivate","child","removeEventListener","remove","_accessibleDiv","_accessibleActive","forEach","div","container","visible","accessibleChildren","accessible","_addChild","children","i","length","init","options","mergedOptions","accessibilityOptions","defaultOptions","activateOnTab","deactivateOnMouseMove","enabledByDefault","now","performance","android","device","renderingToScreen","activeIds","Set","indexOf","has","push","removeItems","x","y","viewWidth","viewHeight","screen","hitArea","getBounds","rectangle","wt","worldTransform","sx","resolution","sy","tx","a","ty","d","_capHitArea","_updateDebugHTML","innerHTML","type","tabIndex","pop","accessibleType","cssText","accessibleText","innerText","borderStyle","navigator","userAgent","toLowerCase","includes","setAttribute","match","_onClick","_onFocus","_onFocusOut","accessiblePointerEvents","accessibleTitle","accessibleHint","interactive","_dispatchEvent","target","boundary","events","rootBoundary","event","assign","FederatedEvent","rootTarget","type2","dispatchEvent","getAttribute","keyCode","movementX","movementY","destroy","setAccessibilityEnabled","enabled","extension","ExtensionType","WebGLSystem","WebGPUSystem","name","$721d8b14c206e73c$export$5d10db92bb959d8a","$gmxRF","manager","bubbles","cancelBubble","cancelable","composed","defaultPrevented","eventPhase","prototype","NONE","propagationStopped","propagationImmediatelyStopped","layer","Point","page","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","layerX","layerY","pageX","pageY","data","composedPath","path","propagationPath","initEvent","_type","_bubbles","_cancelable","Error","initUIEvent","_typeArg","_bubblesArg","_cancelableArg","_viewArg","_detailArg","preventDefault","nativeEvent","Event","stopImmediatePropagation","stopPropagation","$d52e978f520f6185$export$d0a8044dce8ff2fc","$kOAor","$d52e978f520f6185$var$isMobileCall","default","$f274b51b862d63d3$export$2e2bcd8739ae039","$f274b51b862d63d3$var$appleIphone","$f274b51b862d63d3$var$appleIpod","$f274b51b862d63d3$var$appleTablet","$f274b51b862d63d3$var$appleUniversal","$f274b51b862d63d3$var$androidPhone","$f274b51b862d63d3$var$androidTablet","$f274b51b862d63d3$var$amazonPhone","$f274b51b862d63d3$var$amazonTablet","$f274b51b862d63d3$var$windowsPhone","$f274b51b862d63d3$var$windowsTablet","$f274b51b862d63d3$var$otherBlackBerry","$f274b51b862d63d3$var$otherBlackBerry10","$f274b51b862d63d3$var$otherOpera","$f274b51b862d63d3$var$otherChrome","$f274b51b862d63d3$var$otherFirefox","$f274b51b862d63d3$var$isAppleTabletOnIos13","navigator1","platform","maxTouchPoints","MSStream","param","nav","tmp","split","regex","test","result","apple","ipod","universal","amazon","windows","other","blackberry","blackberry10","opera","firefox","chrome","any","$af15c2f7e43544d6$export$fd4b6e2c3e09104f","$1XYIp","$f8xtB","EventSystem","FederatedContainer","$343253f2585e0d1c$export$bf477d624b56bf15","$lQTX9","$j41U2","$gaPze","$2tRWs","$343253f2585e0d1c$var$TOUCH_TO_POINTER","touchstart","touchend","touchendoutside","touchmove","touchcancel","$343253f2585e0d1c$var$_EventSystem","_EventSystem","supportsTouchEvents","supportsPointerEvents","PointerEvent","domElement","EventBoundary","EventsTicker","autoPreventDefault","_eventsAdded","_rootPointerEvent","FederatedPointerEvent","_rootWheelEvent","FederatedWheelEvent","cursorStyles","pointer","features","Proxy","defaultEventFeatures","key","value","enableGlobalMoveEvents","_onPointerDown","_onPointerMove","_onPointerUp","_onPointerOverOut","onWheel","defaultEventMode","_defaultEventMode","setTargetElement","eventMode","eventFeatures","globalMove","resolutionChange","_currentCursor","setCursor","mode","applyStyles","OffscreenCanvas","cursor","hasOwnProperty","call","click","_normalizeToPointerData","isNormalized","j","nativeEvent2","federatedEvent","_bootstrapEvent","mapEvent","move","pointerMoved","normalizedEvents","outside","wheel","wheelEvent","normalizeWheelEvent","element","_removeEvents","_addEvents","addTickerListener","msPointerEnabled","msContentZooming","msTouchAction","touchAction","passive","capture","removeTickerListener","mapPositionToPoint","point","rect","isConnected","getBoundingClientRect","resolutionMultiplier","TouchEvent","li","changedTouches","touch","button","buttons","isPrimary","touches","radiusX","radiusY","tiltX","tiltY","pointerType","pointerId","identifier","pressure","force","twist","tangentialPressure","offsetX","clientX","offsetY","clientY","MouseEvent","tempEvent","_transferMouseData","deltaX","deltaY","deltaZ","deltaMode","global","copyFrom","offset","originalEvent","isTrusted","startsWith","replace","srcElement","timeStamp","altKey","client","ctrlKey","metaKey","movement","relatedTarget","shiftKey","CanvasSystem","priority","$c7ca36a2eb4d0686$export$532e8c243078d2cd","$gpXaq","$cODmL","$1y6A0","$c7ca36a2eb4d0686$var$tempHitLocation","$c7ca36a2eb4d0686$var$tempLocalMapping","dispatch","__esModule","moveOnAll","mappingState","trackingData","eventPool","Map","_allInteractiveElements","_hitElements","_isPointerMoveEvent","hitPruneFn","hitTestFn","mapPointerDown","mapPointerMove","mapPointerOut","mapPointerOver","mapPointerUp","mapPointerUpOutside","mapWheel","mappingTable","addEventMapping","fn","sort","b","propagate","emit","mappers","warn","hitTest","pauseUpdate","invertedPath","useMove","currentTarget","notifyTarget","all","targets","Array","isArray","parent","reverse","hitTestMoveRecursive","location","testFn","pruneFn","ignore","shouldReturn","_interactivePrune","interactiveChildren","nestedHit","_isInteractive","isInteractive","isInteractiveMode","isInteractiveTarget","hitTestRecursive","int","renderable","measurable","applyInverse","contains","effects","effect","containsPoint","handlerKey","_notifyListeners","from","createPointerEvent","isRightButton","pressTargetsByButton","freeEvent","isMouse","outTarget","findMountedTarget","overTargets","outType","outEvent","leaveEvent","overType","overEvent","clonePointerEvent","overTargetAncestor","enterEvent","allMethods","allowGlobalPointerEvents","splice","pressTarget","clickTarget","clickEvent","clicksByButton","clickCount","clickHistory","detail","createWheelEvent","allocateEvent","copyPointerData","copyMouseData","copyData","copyWheelData","slice","to","FederatedMouseEvent","which","id","overTarget","constructor","listeners","_events","once","removeListener","context","$75701bf9f630df0d$export$57a493ed609e53ea","$kfZeU","$7LZE9","interactionFrequency","_deltaTime","_didMove","_tickerAdded","_pauseUpdate","paused","Ticker","system","_tickerUpdate","UPDATE_PRIORITY","INTERACTION","_update","rootPointerEvent","ticker","deltaTime","$968a1335872aaa6e$export$aeb79caab92d155a","arguments","globalX","globalY","screenX","screenY","getLocalPosition","globalPos","getModifierState","initMouseEvent","_canBubbleArg","_screenXArg","_screenYArg","_clientXArg","_clientYArg","_ctrlKeyArg","_altKeyArg","_shiftKeyArg","_metaKeyArg","_buttonArg","_relatedTargetArg","$55afba1b23327af0$export$44ac16aa0ab81db6","getCoalescedEvents","getPredictedEvents","$c4179de99dc711c4$export$1fd8b94eb532974d","DOM_DELTA_PIXEL","DOM_DELTA_LINE","DOM_DELTA_PAGE","$1b27ee9d63451714$export$403593d9e6c7baa6","onclick","onmousedown","onmouseenter","onmouseleave","onmousemove","onglobalmousemove","onmouseout","onmouseover","onmouseup","onmouseupoutside","onpointercancel","onpointerdown","onpointerenter","onpointerleave","onpointermove","onglobalpointermove","onpointerout","onpointerover","onpointertap","onpointerup","onpointerupoutside","onrightclick","onrightdown","onrightup","onrightupoutside","ontap","ontouchcancel","ontouchend","ontouchendoutside","ontouchmove","onglobaltouchmove","ontouchstart","onwheel","_internalEventMode","listener","signal","listenerFn","handleEvent","emitter","off","on","$cWKHz","DOMPipe","$ad168e3f95387bb9$export$ee59129a62c98408","_attachedDomElements","_domElement","addRenderable","domContainer","_instructionSet","updateRenderable","_domContainer","validateRenderable","attachedDomElements","parseFloat","transform","offsetLeft","offsetTop","globalDisplayStatus","anchor","_anchor","ax","ay","transformOrigin","c","opacity","groupAlpha","toString","WebGLPipes","WebGPUPipes","CanvasPipes","$7a0735955a6c768b$export$7254cc27399e90bd","$7a0735955a6c768b$var$blendModeIds","normal","multiply","overlay","erase","min","max","$7a0735955a6c768b$var$_State","_State","blendMode","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","for2d","state","default2d","$47b411752eea9339$export$2c68e848c5b81f5","abgr","out","alpha","$7da9a5be1a7b34c8$export$fe4bdc7069ee0b9c","batcherName","topology","attributeSize","indexSize","packAsQuad","roundPixels","_attributeStart","_batcher","_batch","groupBlendMode","color","groupColorAlpha","reset","texture","bounds","$82ae999195aec18d$export$1723ac05bd5e9336","$82ae999195aec18d$export$adb0f80794f644d9","$82ae999195aec18d$export$36099520d0a716a","vertex","header","main","end"],"version":3,"file":"browserAll.76ffaff7.js.map"}